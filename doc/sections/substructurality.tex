In \targetlang{} and all fragments considered so far, the structural rules of weakening, contraction and exchange were implicit, i.e., (co-)variables could be used multiple times or not at all and independent of the order in which they were introduced.
As a next step, we will make these rules explicit.
This means duplicating and dropping (co-)variables is done by an explicit language construct, so that the usage of resources is evident in the syntax which is of great help in memory management.
We will make the language constructs consume the variables they use.
Moreover, the order of the (co-)variables matters which helps to avoid register allocation as we will see later.
The only exceptions from this scheme are arithmetic operators and conditionals which do not consume the integers they operate on and which can access them freely.
We extend \targetsub{} with one language construct that encompasses all of the above structural rules at once, called explicit substitution.
Explicit substitution creates a new environment for the remaining statement $s$ based on the current environment.
Furthermore, annotate the closure environment in first-class usages of pattern matches and copattern matches to make explicit which part of the environment is consumed by the closure.
The extended calculus is called \targetsub.

\begin{definition}[Syntax of \targetsub{}]
  \[
    \begin{array}{rcll}
      s & \coloneqq & \ldots \mid \cut{\cocase{\overline{D\ \Gamma \Rightarrow s}}_{\Gamma}}{\tilde{\mu}x.s} \mid \cut{\mu\alpha.s}{\case{\overline{K\ \Gamma \Rightarrow s}}_{\Gamma}} \mid \ldots \mid \substitute{\Gamma \mapsto \Gamma}{s} & \emph{Statements}\\
    \end{array}
  \]
\end{definition}

We also have to reformulate the typing rules of \targetred{} for statements in \targetsub{} in the style of an ordered type system and add a typing rule for explicit substitution.
The rules are presented in \cref{fig:targetsub-rules}.

\begin{figure}[hbtp]
  \begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Typing Statements}{$\Theta\mid\Gamma\vdash s$}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta \mid \Gamma, x : \tyint \vdash s$}
      \RightLabel{\textsc{Lit}}
      \UnaryInfC{$\Theta \mid \Gamma \vdash \cut{\lit{n}}{\tilde\mu x.s}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$x_1 : \tyint \in \Gamma$}
      \AxiomC{$x_2 : \tyint \in \Gamma$}
      \AxiomC{$\Theta \mid \Gamma, x : \tyint \vdash s$}
      \RightLabel{\textsc{Op}}
      \TrinaryInfC{$\Theta \mid \Gamma \vdash \odot(x_1, x_2; \tilde\mu x.s)$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.90\textwidth}
    \begin{prooftree}
      \AxiomC{$x : \tyint \in \Gamma$}
      \AxiomC{$\Theta \mid \Gamma \vdash s_1$}
      \AxiomC{$\Theta \mid \Gamma \vdash s_2$}
      \RightLabel{\textsc{Ifz}}
      \TrinaryInfC{$\Theta \mid \Gamma \vdash \ifz{x}{s_1}{s_2}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.90\textwidth}
    \begin{prooftree}
      \AxiomC{$\data{T}{{\ldots, K\ \Gamma_0, \ldots}} \in \Theta$}
      \AxiomC{$\Theta \mid \Gamma, x : T \vdash s$}
      \RightLabel{\textsc{LetConstructor}}
      \BinaryInfC{$\Theta \mid \Gamma, \Gamma_0 \vdash \cut{K\ \Gamma_0}{\tilde\mu x.s}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.90\textwidth}
    \begin{prooftree}
      \AxiomC{$\codata{T}{{\ldots, D\ \Gamma_0, \ldots}} \in \Theta$}
      \AxiomC{$\Theta \mid \Gamma, \alpha \cnt T \vdash s$}
      \RightLabel{\textsc{LetDestructor}}
      \BinaryInfC{$\Theta \mid \Gamma, \Gamma_0 \vdash \cut{\mu\alpha.s}{D\ \Gamma_0}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.90\textwidth}
    \begin{prooftree}
      \AxiomC{$\data{T}{{\overline{K_i\ \Gamma_i}}} \in \Theta$}
      \AxiomC{$\overline{\Theta \mid \Gamma_i, \Gamma_0 \vdash s_i}$}
      \AxiomC{$\Theta \mid \Gamma, \alpha \cnt T \vdash s$}
      \RightLabel{\textsc{NewCase}}
      \TrinaryInfC{$\Theta \mid \Gamma, \Gamma_0 \vdash \cut{\mu\alpha.s}{\case{\overline{K_i\ \Gamma_i \Rightarrow s_i}}_{\Gamma_0}}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.90\textwidth}
    \begin{prooftree}
      \AxiomC{$\codata{T}{{\overline{D_i\ \Gamma_i}}} \in \Theta$}
      \AxiomC{$\overline{\Theta \mid \Gamma_i, \Gamma_0 \vdash s_i}$}
      \AxiomC{$\Theta \mid \Gamma, x : T \vdash s$}
      \RightLabel{\textsc{NewCocase}}
      \TrinaryInfC{$\Theta \mid \Gamma, \Gamma_0 \vdash \cut{\cocase{\overline{D_i\ \Gamma_i \Rightarrow s_i}}_{\Gamma_0}}{\tilde\mu x.s}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\data{T}{\overline{K_i\ \Gamma_i}} \in \Theta$}
      \AxiomC{$\overline{\Theta \mid \Gamma, \Gamma_i \vdash s_i}$}
      \RightLabel{\textsc{SwitchCase}}
      \BinaryInfC{$\Theta \mid \Gamma, x : T \vdash \cut{x}{\case{\overline{K_i \Gamma_i \Rightarrow s_i}}}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\codata{T}{\overline{D_i\ \Gamma_i}} \in \Theta$}
      \AxiomC{$\overline{\Theta \mid \Gamma, \Gamma_i \vdash s_i}$}
      \RightLabel{\textsc{SwitchCocase}}
      \BinaryInfC{$\Theta \mid \Gamma, \alpha \cnt T \vdash \cut{\cocase{\overline{D_i \Gamma_i \Rightarrow s_i}}}{\alpha}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\data{T}{\ldots, K\ \Gamma, \ldots} \in \Theta$}
      \RightLabel{\textsc{InvokeConstructor}}
      \UnaryInfC{$\Theta \mid \Gamma, \alpha \cnt T \vdash \cut{K\ \Gamma}{\alpha}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\codata{T}{\ldots, D\ \Gamma, \ldots} \in \Theta$}
      \RightLabel{\textsc{InvokeDestructor}}
      \UnaryInfC{$\Theta \mid \Gamma, x : T \vdash \cut{x}{D\ \Gamma}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.22\textwidth}
    \begin{prooftree}
      \AxiomC{\phantom{nothing}}
      \RightLabel{\textsc{Done}}
      \UnaryInfC{$\Theta \mid \Gamma \vdash \done$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.43\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta \mid v'_1 :^{p} \tau, \ldots \vdash s$}
      \AxiomC{$v_1 :^{p} \tau \in \Gamma \ldots$}
      \RightLabel{\textsc{Substitute}}
      \BinaryInfC{$\Theta \mid \Gamma \vdash \substitute{v'_1 \mapsto v_1, \ldots}{s}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.25\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{def}\ f\ \Gamma \in \Theta$}
      \RightLabel{\textsc{Call}}
      \UnaryInfC{$\Theta \mid \Gamma \vdash f\ \Gamma$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{minipage}
\caption{Typing rules for statements of \targetsub{}}
\label{fig:targetsub-rules}
\end{figure}

Rule \textsc{Substitute} for explicit substitutions makes the structural rules of weakening, contraction, and exchange explicit.
It is the only place where sharing and erasing of (co-)variables can occur and also the only way to reorder (co-)variables in the environment for the subsequent statement $s$.
All other typing rules, except those for arithmetic operators and conditionals, follow the rules of ordered logic.
For arithmetic operators and conditionals, the variables of type $\tyint$ are merely required to be present in the environment and are not consumed.
Rule \textsc{Call} ensures that the current type environment exactly matches the one assumed by the top-level definition when calling it, i.e., all superfluous (co-)variables must have been dropped and the remaining ones must be in the correct order.
The other rules are concerned with producers and consumers of data and codata types.
In the \textsc{Let} and \textsc{New} rules, an introduction rule meets an activation rule in a cut.
The introduced term is bound to a (co-)variable in the remaining statement $s$.
The \textsc{Let} rules have the variable restriction imposed for \targetvar{} baked in.
The only subderivation is for the remaining statement $s$, but there are no subderivations anymore for the introduction rule of the constructor or destructor, that is, no implicit substitutions.
As all of those requirements would be axioms, we omit them and instead simply require the type environment $\Gamma_0$ to exactly match the signature of the constructor or destructor.
This environment is consumed before the new binding is added.
Similarly, in the \textsc{New} rules, the closure environment $\Gamma_0$ of the branches is consumed.
It must be used in each clause in addition to the parameters $\Gamma_i$ of the corresponding constructor or destructor.
Dually, in the \textsc{Switch} and \textsc{Invoke} rules, an introduction meets an axiom in a cut.
The (co-)variable on the right of the environment is consumed in those rules.
In the \textsc{Switch} rules, the rest of the environment $\Gamma_0$ must be used in each clause in addition to the parameters $\Gamma_i$ of the corresponding constructor or destructor.
In the \textsc{Invoke} rules, the rest of the environment $\Gamma_0$ must exactly match the signature of the constructor or destructor, again because the variable restriction is baked into the rules.


Now, to translate from \targetred{} to \targetsub{}, we have to insert explicit subtitutions and anotate the environment captured by closures.
The overall target is to insert subtitutions in such a way that the register pressure is reduced as much as possible, that is, such that there are as few (co-)variables in the environment as possible.
Therefore the subtitutions aim to drop unneeded variables as early as possible and duplicate variables as late as possible.
To accomplish this, the translation function for statements receives as an additional input a type environment, which is supposed to be the environment the currently translated statement should be typed in, according to the rules of \targetsub.
For the translation of top-level definitions, the annotated environment $\Gamma$ is the environment its body $s$ is typed in.
However, there may be (co-)variables that are not used, i.e., that do not occur free in $s$.
Therefore, we insert a substitution before translating the body statement which only keeps the intersection $\Gamma'$ of $\Gamma$ with the free (co-)variables in $s$.
The environment passed into the translation of $s$ hence is $\Gamma'$, as this is the environment the translated statement is typed in.

\[
  \begin{array}{rcll}
    \multicolumn{4}{c}{\substruct{\cdot}{} : \emph{Definition}_{\targetred{}} \rightarrow \emph{Definition}_{\targetsub{}}}\\
    \substruct{\defi{f\ \Gamma}{s}}{} & \coloneq & \defi{f\ \Gamma}{\substitute{\Gamma' \mapsto \Gamma'}{\substruct{s}{\Gamma'}}} & \\
    \text{where} &  & \Gamma' = \Gamma \cap \free{s} & \\
    \\
    \multicolumn{4}{c}{\substruct{\cdot}{\cdot} : \emph{Statement}_{\targetred{}} \times \emph{Context}_{\targetsub{}} \rightarrow \emph{Statement}_{\targetsub{}}}\\
    \substruct{\cut{K\ \Gamma_0}{\tilde{\mu}x.s}}{\Gamma} & \coloneq & \substitute{\Gamma' \mapsto \Gamma', \Gamma_0 \mapsto \Gamma_0}{\cut{K\ \Gamma_0}{\tilde{\mu}x.\substruct{s}{\Gamma', x}}} & \\
    \text{where} &  & \Gamma' = \Gamma \cap \free{s} & \\
    \substruct{\cut{\mu\alpha.s}{D\ \Gamma_0}}{\Gamma} & \coloneq & \substitute{\Gamma' \mapsto \Gamma', \Gamma_0 \mapsto \Gamma_0}{\cut{\mu\alpha.\substruct{s}{\Gamma', \alpha}}{D\ \Gamma_0}} & \\
    \text{where} &  & \Gamma' = \Gamma \cap \free{s} & \\
    \substruct{\cut{K\ \Gamma_0}{\alpha}}{\Gamma} & \coloneq & \substitute{\Gamma_0 \mapsto \Gamma_0, \alpha \mapsto \alpha}{\cut{K\ \Gamma_0}{\alpha}} & \\
    \substruct{\cut{x}{D\ \Gamma_0}}{\Gamma} & \coloneq & \substitute{\Gamma_0 \mapsto \Gamma_0, x \mapsto x}{\cut{x}{D\ \Gamma_0}} & \\
    \substruct{\cut{x}{\case{\overline{K_i\ \Gamma_i \Rightarrow s_i}}}}{\Gamma} & \coloneq & \substitute{\Gamma' \mapsto \Gamma', x \mapsto x}{\cut{x}{\case{\overline{K_i\ \Gamma_i \Rightarrow \substruct{s_i}{\Gamma', \Gamma_i}}}}} & \\
    \text{where} &  & \Gamma' = \Gamma \cap \bigcup_i \free{s_i} & \\
    \substruct{\cut{\cocase{\overline{D_i\ \Gamma_i \Rightarrow s_i}}}{\alpha}}{\Gamma} & \coloneq & \substitute{\Gamma' \mapsto \Gamma', \alpha \mapsto \alpha}{\cut{\cocase{\overline{D_i\ \Gamma_i \Rightarrow \substruct{s_i}{\Gamma', \Gamma_i}}}}{\alpha}} & \\
    \text{where} &  & \Gamma' = \Gamma \cap \bigcup_i \free{s_i} & \\
    \substruct{\cut{\mu\alpha.s}{\case{\overline{K_i\ \Gamma_i \Rightarrow s_i}}}}{\Gamma} & \coloneq & \substitute{\Gamma' \mapsto \Gamma', \Gamma_0 \mapsto \Gamma_0}{\cut{\mu\alpha.\substruct{s}{\Gamma', \alpha}}{\case{\overline{K_i\ \Gamma_i \Rightarrow \substruct{s_i}{\Gamma_i, \Gamma_0}}}_{\Gamma_0}}} & \\
    \text{where} &  & \Gamma_0 = \Gamma \cap \bigcup_i \free{s_i}  \quad  \Gamma' = \Gamma \cap \free{s} & \\
    \substruct{\cut{\cocase{\overline{D_i\ \Gamma_i \Rightarrow s_i}}}{\tilde{\mu}x.s}}{\Gamma} & \coloneq & \substitute{\Gamma' \mapsto \Gamma', \Gamma_0 \mapsto \Gamma_0}{\cut{\cocase{\overline{D_i\ \Gamma_i \Rightarrow \substruct{s_i}{\Gamma_i, \Gamma_0}}}_{\Gamma_0}}{\tilde{\mu}x.\substruct{s}{\Gamma', x}}} & \\
    \text{where} &  & \Gamma_0 = \Gamma \cap \bigcup_i \free{s_i}  \quad  \Gamma' = \Gamma \cap \free{s} & \\
    \substruct{\cut{\lit{n}}{\tilde{\mu}x.s}}{\Gamma} & \coloneq & \substitute{\Gamma' \mapsto \Gamma'}{\cut{\lit{n}}{\tilde{\mu}x.\substruct{s}{\Gamma', x}}} & \\
    \text{where} &  & \Gamma' = \Gamma \cap \free{s} & \\
    \substruct{\odot(x_1, x_2; \tilde{\mu}x.s)}{\Gamma} & \coloneq & \substitute{\Gamma' \mapsto \Gamma'}{\odot(x_1, x_2; \tilde{\mu}x.\substruct{s}{\Gamma', x})} & \\
    \text{where} &  & \Gamma' = \Gamma \cap (x_1 \cup x_2 \cup \free{s}) & \\
    \substruct{\ifz{x}{s_1}{s_2}}{\Gamma}{} & \coloneq & \ifz{x}{\substruct{s_1}{\Gamma}}{\substruct{s_2}{\Gamma}} & \\
    \substruct{f\ \Gamma_0}{\Gamma} & \coloneq & \substitute{\Gamma_0 \mapsto \Gamma_0}{f\ \Gamma_0} & \\
    \substruct{\done}{\Gamma} & \coloneq & \done & \\
  \end{array}
\]

The cases for the translation of statements proceeds in a similar fashion.
At the beginning of the translation for each statement we insert a substitution which adapts the environment appropriately.
The only exceptions are the $\done$ statement which ends the program anyway, and the case of conditionals.
For the latter, we can relinquish a substitution at the beginning since there will be an appropriate substitution in each of the branches and since there are no newly bound (co-)variables in the branches, which means that no additional register will become occupied before descending into the substatements.
The other cases where no (co-)variable is newly bound are when a constructor or destructor is cut with a (co-)variable and the call of a top-level definition.
But all of these are leaves of the AST without any substatements and the typing rules precisely dictate what the environment has to look like.
Next, consider the cases where a constructor or destructor meets an activation in a cut.
Here, typing dictates that the environment $\Gamma_0$ passed to the constructor or destructor must be on the right.
The necessary environment for the substatement $s$ of the $\mu$- or $\tilde\mu$-binding consists of the intersection $\Gamma'$ of $\Gamma$ with the free (co-)variables of $s$, extended with the newly bound (co-)variable.
Therefore, the substitution consists of $\Gamma'$ and $\Gamma_0$, in this order.
There may be (co-)variables in $\Gamma$ which occur in both $\Gamma'$ and $\Gamma_0$, even multiple times, and the substitution will clone them accordingly.
All (co-)variables in $\Gamma$ that occur in neither $\Gamma'$ nor $\Gamma_0$ are dropped.
The order of the entries in $\Gamma'$ can be arbitrary, but it may be a good idea to keep them in the order in which they occur in $\Gamma$ or in the reverse order in which they are encountered in $s$.
In this translation, we assume that all bindings of (co-)variables are unique, i.e., there is no shadowing.
To account for shadowing, we could drop all shadowed (co-)variables.
For example, we could define $\Gamma' = (\Gamma - x) \cap \free{s}$ instead of $\Gamma' = \Gamma \cap \free{s}$ in the case of a constructor meeting a $\tilde\mu x.s$ in a cut.
Note, however, that we cannot in general do so when multiple branches share a part of the environment, since then a (co-)variable may be shadowed in one branch but not in another and can hence not be dropped before the branching is done.
This is visible in the translations involving pattern and copattern matches.
When they are cut with a (co-)variable, the latter has to be right-most in the environment and the remaining environment $\Gamma'$ is shared among the branches, so it is the intersection of $\Gamma$ with the union of the free (co-)variables in all branches.
The environment for the recursive translation of the substatement in each branch consists of $\Gamma'$ extended with the newly bound (co-)variables for that branch.
Similarly, when a pattern or copattern match is bound to a (co-)variable in an activation, the closure environment consists of the intersection $\Gamma_0$ of $\Gamma$ with the union of the free (co-)variables in all branches.
It has to be on the right in the environment.
For the recursive translation of the substatement in each branch $\Gamma_0$ extends the (co-)variables bound for the corresponding branch.
The remaining environment $\Gamma'$ is again the intersection of $\Gamma$ and the free (co-)variables of the body of the activation $s$.
For the recursive translation of $s$, $\Gamma'$ is again extended with the (co-)variable bound by the activation.
The cases for integer literals and arithmetic operators are similar.
The only difference for arithmetic operators is that the variables used as arguments cannot be dropped, even if they do not occur free in the remaining statement as they are not subjected to the ordered typing discipline.
