In this section we show how to translate terms of the surface language \surfacelang{} to producers of the intermediate language \targetlang.
We first introduce a simpler translation $\translate{\cdot}$ in \cref{subsec:translation:naive} which is straightforward but introduces administrative redexes.
We then introduce the optimized translation $\translatestar{\cdot}{}$ in \cref{subsec:translation:optimized} whis is more complicated, but which does not generate 
any additional administrative redexes.
We finish in \cref{subsec:translation:properties} by proving some core properties of these translation functions.

\[
  \begin{array}{rcll}
    \multicolumn{4}{c}{\translate{\cdot{}}{} : \emph{Declaration}_{Fun} \rightarrow \emph{Declaration}_{Core}}\\
    \translate{\mathbf{data}\ T \{ \overline{K_i\ \Gamma_i} \}}{} & \coloneq & \mathbf{data} \{ \overline{K_i\ \translate{\Gamma_i}}\}\\
    \translate{\mathbf{codata}\ T \{ \overline{D_i\ \Gamma_i} : \tau \}}{} & \coloneq & \mathbf{codata} \{ \overline{D_i\ \translate{\Gamma_i},\alpha\cnt\tau}\} & \fresh{\alpha}\\
    \multicolumn{4}{c}{\translate{\cdot{}}{} : \emph{Typing Context}_{Fun} \rightarrow \emph{Typing Context}_{Core}}\\
    \translate{\nil}{} & \coloneq & \nil \\
    \translate{\Gamma,x:\tau}{} & \coloneq & \translate{\Gamma}, x\prd\tau\\
    \translate{\Gamma,\alpha\cnt\tau}{} & \coloneq & \translate{\Gamma}, \alpha\cnt\tau
  \end{array}
\]

Translating Declarations and typing contexts are the same for both translations we will introduce. 
Here, the most important part of the translation is the fact that codata declarations no longer have a type $\tau$ used for destructor terms.
Instead, each destructor gets a fresh covariable argument $\alpha$ with this type.
As we will see in the translations for cocases, this will ensure types are preserved under translation.

%%
%% Subsection: Naive Translation
%%
\subsection{Naive Translation}
\label{subsec:translation:naive}

First, we will introduce the naive translation, turning terms in \surfacelang{} into producers in \targetlang{}. 
As we can see from the definitions of \targetlang{} (\cref{sec:core}), certain terms, for example cases and destructors, are consumers in \targetlang{}, and others, such as if zero and top-level calls are statements.
In order to correctly translate such terms to \targetlang{}, we thus introduce $\mu$-abstractions, turning statements into producers.
Where \targetlang{}-expressions are consumers, they are cut with some other producer to turn them into statements which then make a producer with the $\mu$-abstraction.
We assume that each covariable $\alpha$ appearing in a translated term is fresh with respect to the term that is translated.
For example, when translating a top-level call $f(\overline{t_i};\overline{\alpha_i})$, the $\alpha_j$ used in the translation does not appear free in any of the $t_i$ and is not equal to any of the $\alpha_j$.
\[
  \begin{array}{rcl rcl}
    \multicolumn{6}{c}{\translate{\cdot} : \emph{Term} \rightarrow \emph{Producer}}\\
    \\
    \translate{\lit{x}} & \coloneq & \lit{x} & 
    \translate{\ifz{t_1}{t_2}{t_3}} & \coloneq & \mu\alpha.\ifz{\translate{t_1}}{\cut{\translate{t_2}}{\alpha}}{\cut{\translate{t_3}}{\alpha}} \\
    \translate{\lit{n}} & \coloneq & \lit{n}  &  
    \translate{t_1 \odot t_2} & \coloneq & \mu\alpha.\odot(\translate{t_1}, \translate{t_2}; \alpha)  \\
    \translate{f(\overline{t_i}; \overline{\alpha_j})} & \coloneq & \mu\alpha.f(\overline{\translate{t_i}}; \overline{\alpha_j},\alpha)  & 
    \translate{\letin{x}{t_1}{t_2}} & \coloneq & \mu\alpha.\cut{\translate{t_1}}{\tilde{\mu}x.\cut{\translate{t_2}}{\alpha}} \\
    \translate{K(\overline{t_i})} & \coloneq & K(\overline{\translate{t_i}}) &  
    \translate{\caseof{t}{\overline{K_i(\overline{x_{i,j}}) \Rightarrow t_i}}} & \coloneq & \mu\alpha.\cut{\translate{t}}{\case{\overline{K_i(\overline{x_{i,j}}) \Rightarrow \cut{\translate{t_i}}{\alpha}}}}  \\
    \translate{t.D(\overline{t_i})} & \coloneq & \mu\alpha.\cut{\translate{t}}{D(\overline{\translate{t_i}}; \alpha)}   & 
    \translate{\cocase{\overline{D_i(\overline{x_{ij}})\Rightarrow t_i}}} & \coloneq & \cocase{\overline{D_i(\overline{x_{i,j}}; \alpha_i) \Rightarrow \cut{\translate{t_i}}{\alpha_i}}}  \\
    \translate{\lab{\alpha}{t}} & \coloneq & \mu\alpha.\cut{\translate{t}}{\alpha} & 
    \translate{\goto{t}{\alpha}} & \coloneq & \mu\beta.\cut{\translate{t}}{\alpha}  \\
    \\
    \multicolumn{6}{c}{\translate{\cdot{}}{} : \emph{Definition}_{Fun} \rightarrow \emph{Definition}_{Core}}\\
    \multicolumn{2}{r}{\translate{\defi{f(\overline{x}; \overline{\alpha})}{t}}{}} & \multicolumn{2}{c}{\coloneq} & \multicolumn{2}{l}{\defi{f(\overline{x}; \overline{\alpha}, \alpha)}{\cut{\translate{t}}{\alpha}}} \\
    \\
  \end{array}
\]
In order to see why this translation is inefficient, consider the following term and its translation.
\begin{example}
  \label{ex:translation_naive}
  \begin{align*}
    \translate{\letin{x}{\lit{2}}{x*x}} = \mu\alpha.\cut{\lit{2}}{\tilde\mu x.\cut{\mu\beta.*(x,x;\beta)}{\alpha}}
  \end{align*}
  Here, the statement bound by $\tilde\mu$ is the cut $\cut{\mu\beta.*(x,x;\beta)}{\alpha}$, which after a single reduction step becomes $*(x,x;\alpha)$.
\end{example}
Thus, whenever we introduce a new $\mu$-abstraction while translating a term in \surfacelang{}, there is a potential administrative redex generated  depending on the surrounding terms.
With these redexes included, we have two options on how to continue compilation. 
Either we keep them in the expressions and finally translate them into machine code, or we add an additional simplification step before we translate \targetlang{} to AxCut.
In each case, we will incur a performance overhead which we would like to avoid. 
To solve this issue, we will introduce the optimized translation, which keeps track of introduced covariables and only generate new ones where necessary.


%%
%% Subsection: Optimized Translation
%%
\subsection{Optimized Translation}
\label{subsec:translation:optimized}
We now introduce the optimized version of the translation introduced above.
This optimization works by splitting the function $\translate{\cdot}$ into the two functions $\translatestar{\cdot}{}$ and $\translatestar{\cdot}{k}$.
The intuition is that $\translatestar{p}{k}$ should be the same as $\cut{\translate{p}}{k}$, but whenever this results in a redex, for example if $\translate{p}$ has the form $\mu \alpha.s$, we reduce this administrative redex during the translation itself.
As before, we will again assume that any covariable $\alpha$ in the translation of a term is fresh with respect to the term being translated.

\[
  \begin{array}{rcl rcl}
    \multicolumn{6}{c}{\translatestar{\cdot}{} : \emph{Term} \rightarrow  \emph{Producer}}\\
    \translatestar{x}{} & \coloneqq & x & 
    \translatestar{\cocase{\overline{D_i(\overline{x_{i,j}}) \Rightarrow t_i}}}{} & \coloneq & \cocase{\overline{D_i(\overline{x_{i,j}}; \alpha_i) \Rightarrow \translatestar{t_i}{\alpha_i}}} \\
    \translatestar{\lit{n}}{} & \coloneqq & \lit{n}  &
    \translatestar{\lambda x.t}{} & \coloneq & \cocase{\mathtt{ap}(x; \alpha) \Rightarrow \translatestar{t}{\alpha}} \\
    \translatestar{K(\overline{t_i})}{} & \coloneqq & K(\overline{\translatestar{t_i}{}}) &
    \translatestar{\lab{\alpha}{t}}{} & \coloneq & \mu \alpha.\translatestar{t}{\alpha}{} \\
    \translatestar{t}{} & \coloneqq & \mu\alpha.\translatestar{t}{\alpha} & \fresh{\alpha} &
    \\
    \multicolumn{6}{c}{\translatestar{\cdot}{\cdot} : \emph{Term} \times \emph{Consumer} \rightarrow \emph{Statement}}\\
    \translatestar{x}{c} & \coloneq & \cut{x}{c} & 
    \translatestar{t_1 \odot t_2}{c} & \coloneq & \odot(\translatestar{t_1}{}, \translatestar{t_2}{}; c)  \\
    \translatestar{\lit{n}}{c} & \coloneq & \cut{\lit{n}}{c} & 
    \translatestar{\ifz{t_1}{t_2}{t_2}}{c} & \coloneq & \ifz{\translatestar{t_1}{}}{\translatestar{t_2}{c}}{\translatestar{t_3}{c}}  \\
    \translatestar{\letin{x}{t_1}{t_2}}{c} & \coloneq & \translatestar{t_1}{\tilde{\mu}x.\translatestar{t_2}{c}} & 
    \translatestar{f(\overline{t_i}; \overline{\alpha_j})}{c} & \coloneq & f(\overline{\translatestar{t_i}{}}; \overline{\alpha_j}, c) \\
    \translatestar{K(\overline{t_i})}{c} & \coloneq & \cut{K(\overline{\translatestar{t_i}{}})}{c} & 
    \translatestar{\caseof{t}{\overline{K_i(\overline{x_{i,j}}) \Rightarrow t_i}}}{c} & \coloneq & \translatestar{t}{\case{\overline{K_i(\overline{x_{i,j}}) \Rightarrow \translatestar{t_i}{c}}}} \\
    \translatestar{t.D(\overline{t_i})}{c} & \coloneq & \translatestar{t}{D(\overline{\translatestar{t_i}{}}; c)} &
    \translatestar{\cocase{\overline{D_i(\overline{x_{i,j}}) \Rightarrow t_i}}}{c} & \coloneq & \cut{\cocase{\overline{D_i(\overline{x_{i,j}}; \alpha_i) \Rightarrow \translatestar{t_i}{\alpha_i}}}}{c}  \\
    \translatestar{\lab{\alpha}{t}}{c} & \coloneq & \cut{\mu \alpha.\translatestar{t}{\alpha}}{c} & 
    \translatestar{\goto{t}{\alpha}}{c} & \coloneq & \translatestar{t}{\alpha} \\
    \\
    \multicolumn{6}{c}{\translatestar{\cdot}{} : \emph{Definition} \rightarrow \emph{Definition}}\\
    \multicolumn{2}{r}{\translatestar{\defi{f(\overline{x}; \overline{\alpha})}{t}}{}} & \multicolumn{2}{c}{\coloneq} & \multicolumn{2}{l}{\defi{f(\overline{x}; \overline{\alpha}, \alpha)}{\translatestar{t}{\alpha}}} 
  \end{array}
\]
To see how this translation removes administrative redexes, consider again the example \cref{example:translation:naive}
\begin{example}
  \begin{align*}
    \translate{\letin{x}{\lit{2}}{x*x}}^* = \mu\alpha.\cut{\lit{2}}{\tilde\mu x.*(x,x;\alpha)}
  \end{align*}
  The resulting producer in \targetlang{} is exactly the same as the one generated from the naive translation after reducing the administrative redex.
\end{example}
As we will see below (\cref{teo:correctness}), this property holds in general.

%%
%% Section Properties
%%
\subsection{Properties}
\label{subsec:translation:properties}

\begin{lemma}
  If $\Gamma \vdash t : \tau$ and $\Gamma' \vdash k \cnt \tau$, then $\Gamma' \vdash \translatestar{t}{k}$.
\end{lemma}
\begin{proof}
  TODO: Figure out correct statement w.r.t. $\Gamma$ and $\Gamma'$.
\end{proof}

\begin{theorem}[Type Preservation]
  Let $t$ be a term in \surfacelang, and let $\tau$ be a type.
  If $\Gamma \vdash t: \tau$, then both $\Gamma \vdash \translate{t} \prd \tau$ and $\Gamma \vdash \translatestar{t}{} \prd \tau$.
\end{theorem}

\begin{theorem}[Correctness]
  \label{teo:correctness}
  Let $t$ be a term in \surfacelang. Then there are a finite number of reduction steps (where reduction here also means reduction under binders) such that $\focus{\translate{t}} \reducesto^{\ast} \focus{\translatestar{t}{}}$, where $\focus{\cdot}$ is the focusing translation.
\end{theorem}
