In this section we show how to translate terms of the surface language \surfacelang{} to producers of the intermediate language \targetlang.
We first introduce a simpler translation $\translate{\cdot}$ in \cref{subsec:translation:naive} which is straightforward but introduces administrative redexes.
We then introduce the optimized translation $\translatestar{\cdot}{}$ in \cref{subsec:translation:optimized} whis is more complicated, but which does not generate
any additional administrative redexes.
We finish in \cref{subsec:translation:properties} by proving some core properties of these translation functions.

\[
  \begin{array}{rcll}
    \translate{\codata{T}{\overline{D_i\ \Gamma_i} : \tau}}{} & \coloneq & \codata{T}{\overline{D_i\ \Gamma_i,\alpha\cnt\tau}} & \fresh{\alpha}\\
  \end{array}
\]

Translating Declarations and typing contexts are the same for both translations we will introduce.
Here, the most important part of the translation is the fact that codata declarations no longer have a type $\tau$ used for destructor terms.
Instead, each destructor gets a fresh covariable argument $\alpha$ with this type.
As we will see in the translations for cocases, this will ensure types are preserved under translation.

%%
%% Subsection: Naive Translation
%%
\subsection{Naive Translation}
\label{subsec:translation:naive}

First, we will introduce the naive translation, turning terms in \surfacelang{} into producers in \targetlang{}.
As we can see from the definitions of \targetlang{} (\cref{sec:core}), certain terms, for example cases and destructors, are consumers in \targetlang{}, and others, such as if zero and top-level calls are statements.
In order to correctly translate such terms to \targetlang{}, we thus introduce $\mu$-abstractions, turning statements into producers.
Where \targetlang{}-expressions are consumers, they are cut with some other producer to turn them into statements which then make a producer with the $\mu$-abstraction.
We assume that each covariable $\alpha$ appearing in a translated term is fresh with respect to the term that is translated (except for those already present in the source term).
For example, when translating a top-level call $f(\overline{t_i};\overline{\alpha_i})$, the $\alpha_j$ used in the translation does not appear free in any of the $t_i$ and is not equal to any of the $\alpha_j$.
Additionally, whenever a typing context $\Gamma$ appears on the left-hand side, we also write $\Gamma$ for the corresponding typing context in \targetlang{}, since for translating contexts there is nothing to do.
Any context $\Gamma$ containing variables $x:\tau$ and covariables $\alpha\cnt\tau$ is either valid in both \surfacelang{} and \targetlang{} or in neither, so we can keep the same contexts.
\[
  \begin{array}{rcl rcl}
    \multicolumn{6}{c}{\translate{\cdot} : \emph{Term} \rightarrow \emph{Producer}} \\
    \translate{x} & \coloneq & x &
    \translate{\ifz{t_1}{t_2}{t_3}} & \coloneq & \mu\alpha.\ifz{\translate{t_1}}{\cut{\translate{t_2}}{\alpha}}{\cut{\translate{t_3}}{\alpha}} \\
    \translate{\lit{n}} & \coloneq & \lit{n}  &
    \translate{t_1 \odot t_2} & \coloneq & \mu\alpha.\odot(\translate{t_1}, \translate{t_2}; \alpha)  \\
    \translate{f\ \sigma} & \coloneq & \mu\alpha.f\ \translate{\sigma, \alpha}  &
    \translate{\letin{x}{t_1}{t_2}} & \coloneq & \mu\alpha.\cut{\translate{t_1}}{\tilde{\mu}x.\cut{\translate{t_2}}{\alpha}} \\
    \translate{K\ \sigma} & \coloneq & K\ \translate{\sigma} &
    \translate{\caseof{t}{\overline{K_i\ \Gamma_i \Rightarrow t_i}}} & \coloneq & \mu\alpha.\cut{\translate{t}}{\case{\overline{K_i\ \Gamma_i \Rightarrow \cut{\translate{t_i}}{\alpha}}}}  \\
    \translate{t.D\ \sigma} & \coloneq & \mu\alpha.\cut{\translate{t}}{D\ \translate{\sigma, \alpha}}   &
    \translate{\cocase{\overline{D_i\ \Gamma_i \Rightarrow t_i}}} & \coloneq & \cocase{\overline{D_i\ \Gamma_i,\alpha_i \Rightarrow \cut{\translate{t_i}}{\alpha_i}}}  \\
    \translate{\lab{\alpha}{t}} & \coloneq & \mu\alpha.\cut{\translate{t}}{\alpha} &
    \translate{\goto{t}{\alpha}} & \coloneq & \mu\beta.\cut{\translate{t}}{\alpha}  \\
    \\
    \multicolumn{3}{c}{\translate{\cdot{}}{} : \emph{Definition}_{\surfacelang{}} \rightarrow \emph{Definition}_{\targetlang{}}} &
    \multicolumn{3}{c}{\translate{\cdot{}}{}:\emph{Substitution}_{\surfacelang{}}\rightarrow\emph{Substitution}_{\targetlang{}}} \\
    \translate{\defi{f\ \Gamma : \tau}{t}}{} & \coloneq & \defi{f\ \Gamma, \alpha \cnt \tau}{\cut{\translate{t}}{\alpha}} &
    \multicolumn{3}{c}{\translate{\nil} \coloneq \nil \qquad
                       \translate{\sigma,t} \coloneq \translate{\sigma},\translate{t} \qquad
                       \translate{\sigma,\alpha} \coloneq \translate{\sigma}, \alpha} \\
    \\
  \end{array}
\]
In order to see why this translation is inefficient, consider the following term and its translation.
\begin{example}[Naive Translation of Let Bindings]
  \label{ex:translation:naive}
  \begin{align*}
    \translate{\letin{x}{\lit{2}}{x*x}} = \mu\alpha.\cut{\lit{2}}{\tilde\mu x.\cut{\mu\beta.*(x,x;\beta)}{\alpha}}
  \end{align*}
  Here, the statement bound by $\tilde\mu$ is the cut $\cut{\mu\beta.*(x,x;\beta)}{\alpha}$, which after a single reduction step becomes $*(x,x;\alpha)$.
\end{example}
Thus, whenever we introduce a new $\mu$-abstraction while translating a term in \surfacelang{}, there is a potential administrative redex generated  depending on the surrounding terms.
With these redexes included, we have two options on how to continue compilation.
Either we keep them in the expressions and finally translate them into machine code, or we add an additional simplification step before we translate \targetlang{} to AxCut.
In each case, we will incur a performance overhead which we would like to avoid.
To solve this issue, we will introduce the optimized translation, which keeps track of introduced covariables and only generate new ones where necessary.


%%
%% Subsection: Optimized Translation
%%
\subsection{Optimized Translation}
\label{subsec:translation:optimized}
We now introduce the optimized version of the translation introduced above.
This optimization works by splitting the function $\translate{\cdot}$ into the two functions $\translatestar{\cdot}{}$ and $\translatestar{\cdot}{k}$.
The intuition is that $\translatestar{p}{k}$ should be the same as $\cut{\translate{p}}{k}$, but whenever this results in a redex, for example if $\translate{p}$ has the form $\mu \alpha.s$, we reduce this administrative redex during the translation itself.
As before, we will again assume that any covariable $\alpha$ in the translation of a term (except for those already present in the source term) is fresh with respect to the term being translated.

\[
  \begin{array}{rcl rcl}
    \multicolumn{6}{c}{\translatestar{\cdot}{} : \emph{Term} \rightarrow  \emph{Producer}}\\
    \translatestar{x}{} & \coloneqq & x &
    \translatestar{\cocase{\overline{D_i(\overline{x_{i,j}}) \Rightarrow t_i}}}{} & \coloneq & \cocase{\overline{D_i\ \Gamma_i,\alpha_i \Rightarrow \translatestar{t_i}{\alpha_i}}} \\
    \translatestar{\lit{n}}{} & \coloneqq & \lit{n}  &
    \translatestar{\lab{\alpha}{t}}{} & \coloneq & \mu \alpha.\translatestar{t}{\alpha}{} \\
    \translatestar{K\ \sigma}{} & \coloneqq & K\ \translatestar{\sigma}{} &
    \translatestar{t}{} & \coloneqq & \mu\alpha.\translatestar{t}{\alpha}
    \\
    \multicolumn{6}{c}{\translatestar{\cdot}{\cdot} : \emph{Term} \times \emph{Consumer} \rightarrow \emph{Statement}}\\
    \translatestar{x}{c} & \coloneq & \cut{x}{c} &
    \translatestar{t_1 \odot t_2}{c} & \coloneq & \odot(\translatestar{t_1}{}, \translatestar{t_2}{}; c)  \\
    \translatestar{\lit{n}}{c} & \coloneq & \cut{\lit{n}}{c} &
    \translatestar{\ifz{t_1}{t_2}{t_2}}{c} & \coloneq & \ifz{\translatestar{t_1}{}}{\translatestar{t_2}{c}}{\translatestar{t_3}{c}}  \\
    \translatestar{\letin{x}{t_1}{t_2}}{c} & \coloneq & \translatestar{t_1}{\tilde{\mu}x.\translatestar{t_2}{c}} &
    \translatestar{f\ \Gamma}{c} & \coloneq & f\ \Gamma,c \\
    \translatestar{K\ \sigma}{c} & \coloneq & \cut{K\ \translatestar{\sigma}{}}{c} &
    \translatestar{\caseof{t}{\overline{K_i\ \Gamma_i \Rightarrow t_i}}}{c} & \coloneq & \translatestar{t}{\case{\overline{K_i\ \Gamma_i \Rightarrow \translatestar{t_i}{c}}}} \\
    \translatestar{t.D\ \sigma}{c} & \coloneq & \translatestar{t}{D\ \translatestar{\sigma}{}} &
    \translatestar{\cocase{\overline{D_i\ \Gamma_i \Rightarrow t_i}}}{c} & \coloneq & \cut{\cocase{\overline{D_i\ \Gamma_i,\alpha_i \Rightarrow \translatestar{t_i}{\alpha_i}}}}{c}  \\
    \translatestar{\lab{\alpha}{t}}{c} & \coloneq & \cut{\mu \alpha.\translatestar{t}{\alpha}}{c} &
    \translatestar{\goto{t}{\alpha}}{c} & \coloneq & \translatestar{t}{\alpha} \\
    \\
    \multicolumn{3}{c}{\translate{\cdot{}}{} : \emph{Definition}_{\surfacelang{}} \rightarrow \emph{Definition}_{\targetlang{}}} &
    \multicolumn{3}{c}{\translate{\cdot{}}{}:\emph{Substitution}_{\surfacelang{}}\rightarrow\emph{Substitution}_{\targetlang{}}} \\
    \translatestar{\defi{f\ \Gamma : \tau}{t}}{} & \coloneq & \defi{f\ \Gamma, \alpha \cnt \tau}{\translatestar{t}{\alpha}} &
    \multicolumn{3}{c}{\translatestar{\nil}{} \coloneq \nil \qquad
                       \translatestar{\sigma,t}{} \coloneq \translatestar{\sigma}{},\translatestar{t}{} \qquad
                       \translatestar{\sigma,\alpha}{} \coloneq \translatestar{\sigma}{}, \alpha} \\
    \\
  \end{array}
\]
To see how this translation removes administrative redexes, consider again the example \cref{ex:translation:naive}
\begin{example}[Optimized Translation of Let Bindings]
  \begin{align*}
    \translate{\letin{x}{\lit{2}}{x*x}}^* = \mu\alpha.\cut{\lit{2}}{\tilde\mu x.*(x,x;\alpha)}
  \end{align*}
  The resulting producer in \targetlang{} is exactly the same as the one generated from the naive translation after reducing the administrative redex.
\end{example}
As we will see below (\cref{teo:correctness}), this property holds in general.

%%
%% Section Properties
%%
\subsection{Properties}
\label{subsec:translation:properties}

\begin{lemma}
  If $\Gamma \vdash t : \tau$ and $\Gamma' \vdash k \cnt \tau$, then $\Gamma' \vdash \translatestar{t}{k}$.
\end{lemma}
\begin{proof}
  TODO: Figure out correct statement w.r.t. $\Gamma$ and $\Gamma'$.
\end{proof}

\begin{theorem}[Type Preservation]
  Let $t$ be a term in \surfacelang, and let $\tau$ be a type.
  If $\Gamma \vdash t: \tau$, then both $\Gamma \vdash \translate{t} : \tau$ and $\Gamma \vdash \translatestar{t}{} : \tau$.
\end{theorem}

\begin{theorem}[Correctness]
  \label{teo:correctness}
  Let $t$ be a term in \surfacelang. Then there are a finite number of reduction steps (where reduction here also means reduction under binders) such that $\focus{\translate{t}} \reducesto^{\ast} \focus{\translatestar{t}{}}$, where $\focus{\cdot}$ is the focusing translation.
\end{theorem}
