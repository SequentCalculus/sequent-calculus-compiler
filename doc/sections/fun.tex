\begin{definition}[Syntactic Conventions]
  We use the following metavariables for all languages:
  \[
    \begin{array}{rcll}
      \odot  & \coloneqq & + \mid - \mid * & \emph{Arithmetic Operators}
    \end{array}
  \]
\end{definition}

\begin{definition}[Syntax of \surfacelang{}]
  We assume an infinite set of names $\mathcal{N}$ containing type names $T\in\mathcal{N}$, constructor names $K\in\mathcal{N}$ and destructor names $D\in\mathcal{N}$.
  \[
    \begin{array}{r c l l}
      t & \coloneqq & x \mid \lit{n} \mid t \odot t \mid \ifz{t}{t}{t} \mid \letin{x}{t}{t} \mid f(\overline{t}; \overline{\alpha}) \mid \lab{\alpha}{t} \mid \goto{t}{\alpha} & \emph{Terms}\\
      & \mid & K(\sigma) \mid \caseof{t}{\overline{K\ \Gamma \Rightarrow t}} \mid t.D(\sigma) \mid \cocase{\overline{D\ \Gamma \Rightarrow t}} & \\
      \sigma & \coloneqq & \nil \mid \sigma,t \mid \sigma, \alpha & \emph{Substitutions}\\
      \tau & \coloneqq & \tyint \mid T & \emph{Types} \\
      \kappa & \coloneq & \mathbf{data} \mid \mathbf{codata} \mid \mathbf{prim} & \emph{Kinds} \\
      \Gamma & \Coloneqq & \nil \mid \Gamma, x : \tau \mid \Gamma, \alpha \cnt \tau & \emph{Typing Contexts} \\
      \delta & \coloneqq & \mathbf{data}\ T\ \{ \overline{K\ \Gamma} \}  \mid \mathbf{codata}\ T\ \{ \overline{D\ \Gamma : \tau}\} \mid \defi{f\ \Gamma}{t} & \emph{Declarations}\\
      \Theta & \coloneqq & \overline{\delta} & \emph{Programs}\\
    \end{array}
  \]
\end{definition}

In both the definitions for (co-) cases and for declarations we use typing contexts $\Gamma$ to encode the arguments of constructors and destructors.
This is a slight abuse of notation, since in data declarations, types for arguments are mandatory, while for clauses in (co-) cases, they are omitted.
Thus, the following is a valid program in \surfacelang{}.
\begin{example}
  \label{ex:fun-syntax}
  \begin{lstlisting}
  data ListInt {
  Nil,
  Cons(x:Int,xs:ListInt)
  }

  def tl(ls) := case ls of {
  Nil => Nil,
  Cons(x,xs) => xs
  }
  \end{lstlisting}
\end{example}
In the above example, the constructor $\mathtt{Cons}$ has arguments $x$ and $xs$, both of which are type annotated in the declaration of $\mathtt{ListInt}$.

%%
%% Subsec: Typing Rules
%%
\subsection{Typing Rules}
\label{subsec:fun:typing-rules}

\begin{figure}[hbtp]
  \begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Typing Terms}{$\Theta\mid\Gamma\vdash t : \tau$}

  \begin{minipage}{0.25\textwidth}
    \begin{prooftree}
      \AxiomC{$x : \tau \in \Gamma$}
      \RightLabel{\textsc{Var}}
      \UnaryInfC{$\Theta\mid\Gamma \vdash x : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.25\textwidth}
    \begin{prooftree}
      \AxiomC{\phantom{$x : \tau \in \Gamma$}}
      \RightLabel{\textsc{Lit}}
      \UnaryInfC{$\Theta\mid\Gamma \vdash \lit{n}:\tyint$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.4\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash t_1: \tyint \quad \Theta\mid\Gamma \vdash t_2: \tyint$}
      \RightLabel{\textsc{Op}}
      \UnaryInfC{$\Theta\mid\Gamma \vdash t_1\odot t_2 : \tyint$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash t : \tyint$}
      \AxiomC{$\Theta\mid\Gamma \vdash t_1 : \tau$}
      \AxiomC{$\Theta\mid\Gamma \vdash t_2 : \tau$}
      \RightLabel{\textsc{Ifz}}
      \TrinaryInfC{$\Theta\mid\Gamma \vdash \ifz{t}{t_1}{t_2} : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash t_1 : \tau_1$}
      \AxiomC{$\Theta\mid\Gamma, x : \tau_1 \vdash t_2 : \tau_2$}
      \RightLabel{\textsc{Let}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash \letin{x}{t_1}{t_2} :\tau_2$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.55\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash t : \tau$}
      \AxiomC{$\alpha \cnt \tau \in \Gamma$}
      \RightLabel{\textsc{Goto}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash \goto{t}{\alpha} : \tau'$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.4\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma, \alpha \cnt \tau \vdash t : \tau$}
      \RightLabel{\textsc{Label}}
      \UnaryInfC{$\Theta\mid\Gamma \vdash \lab{\alpha}{t} : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{data}\ T\ \{K\ \Gamma^{\prime}, \dots \}\in\Theta$}
      \AxiomC{$ \Theta\mid\Gamma \vdash \sigma:\Gamma^{\prime}$}
      \RightLabel{\textsc{Constructor}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash K\ \sigma : T$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{data}\ T\{\overline{K_i\ \Gamma_i)}\}\in \Theta$}
      \AxiomC{$\overline{\Theta\mid\Gamma,\Gamma_i\vdash t_i : \tau}$}
      \RightLabel{\textsc{Case}}
      \BinaryInfC{$\Theta\mid\Gamma\vdash \mathbf{case}\ t\ \mathbf{of}\ \{\overline{K_i\ \Gamma_i\Rightarrow t_i}\} : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{codata}\ T\ \{D\ \Gamma^{\prime}:\tau,\dots \}\in \Theta$}
      \AxiomC{$\Theta\mid\Gamma\vdash \sigma:\Gamma^{\prime}$}
      \AxiomC{$\Theta\mid\Gamma \vdash t :T$}
      \RightLabel{\textsc{Destructor}}
      \TrinaryInfC{$\Theta\mid\Gamma \vdash t.D\ \sigma : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{codata}\ T \{\overline{D_i\ \Gamma_i:\tau_i}\}\in \Theta$}
      \AxiomC{$\Theta\mid\Gamma,\Gamma_i \vdash t_i:\tau_i$}
      \RightLabel{\textsc{Cocase}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash \mathbf{cocase} \{ \overline{D_i\ \Gamma_i} \Rightarrow t_i \} : T$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{def}\ f\ \Gamma^{\prime} :\tau \in \Theta$}
      \AxiomC{$\Theta\mid\Gamma \vdash \sigma:\Gamma^{\prime} $}
      \RightLabel{\textsc{Call}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash f\ \sigma : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{minipage}
\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Substitution Typing}{$\Theta\mid\Gamma\vdash\sigma:\Gamma^{\prime}$}

  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma\vdash\sigma:\Gamma^{\prime} \quad \Theta\mid\Gamma\vdash t:\tau$}
      \RightLabel{\textsc{Subst}$_1$}
      \UnaryInfC{$\Theta\mid\Gamma \vdash \sigma,t : \Gamma^{\prime},x:\tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash \sigma:\Gamma^{\prime} \quad \alpha\cnt\tau\in\Gamma$}
      \RightLabel{\textsc{Subst}$_2$}
      \UnaryInfC{$\Theta\mid\Gamma \vdash \sigma,\alpha : \Gamma^{\prime}, \alpha\cnt \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.25\textwidth}
    \begin{prooftree}
      \AxiomC{\phantom{$\Theta\mid\Gamma \vdash \Gamma^{\prime}$}}
      \RightLabel{\textsc{Subst}$_3$}
      \UnaryInfC{$\Theta\mid\Gamma\vdash\nil:\nil$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{minipage}
\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Kinding Types}{$\Theta\vdash\tau:\kappa$}
  \begin{minipage}{0.2\textwidth}
    \begin{prooftree}
      \AxiomC{}
      \RightLabel{\textsc{PrimKind}}
      \UnaryInfC{$\Theta \vdash \tyint : \mathbf{prim}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{data}\ T\ \{\, \ldots \} \in \Theta$}
      \RightLabel{\textsc{DataKind}}
      \UnaryInfC{$\Theta \vdash T : \mathbf{data}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{codata}\ T\ \{\, \ldots \} \in \Theta$}
      \RightLabel{\textsc{CodataKind}}
      \UnaryInfC{$\Theta \vdash T : \mathbf{codata}$}
    \end{prooftree}
  \end{minipage}
  \vspace{1em}
\end{minipage}
\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Well-formed Programs}{$\vdash \wellformed{\Theta}$}
  \begin{minipage}{0.2\textwidth}
    \begin{prooftree}
      \AxiomC{}
      \RightLabel{\textsc{Wf-Empty}}
      \UnaryInfC{$\vdash \wellformed{\nil}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.75\textwidth}
    \begin{prooftree}
      \AxiomC{$\vdash \wellformed{\Theta}$}
      \AxiomC{$\overline{D},T$ do not occur in $\Theta$}
      \AxiomC{$\overline{\Theta\vdash\goodctx{\Gamma_i}}$}
      \AxiomC{$\overline{ \Gamma_i \vdash \tau_i:\kappa}$}
      \RightLabel{\textsc{Wf-Codata}}
      \QuaternaryInfC{$\vdash \wellformed{\Theta,\mathbf{codata}\ T\ \{ \overline{D_i\ \Gamma_i : \tau_i}\}}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\vdash \wellformed{\Theta}$}
      \AxiomC{$\overline{K},T$ do not occur in $\Theta$}
      \AxiomC{$\overline{\Theta\vdash\goodctx{\Gamma_i}}$}
      \RightLabel{\textsc{Wf-Data}}
      \TrinaryInfC{$\vdash \wellformed{\Theta,\mathbf{data}\ T\ \{ \overline{K_i\ \Gamma_i} \}}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\vdash \wellformed{\Theta}$}
      \AxiomC{$\Theta, \mathbf{def}\ \text{f}\ \Gamma\coloneq t \mid\Gamma \vdash t:\tau$}
      \RightLabel{\textsc{Wf-\surfacelang{}}}
      \BinaryInfC{$\vdash \wellformed{\Theta,\mathbf{def}\ \text{f}\ \Gamma \coloneq t}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{minipage}
\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Well-formed contexts}{$\Theta\vdash \goodctx{\Gamma}$}
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\vdash\goodctx{\Gamma} \quad x\notin\Gamma \quad \Theta\vdash\tau:\kappa$}
      \RightLabel{\textsc{Ctx}$_1$}
      \UnaryInfC{$\Theta\vdash\goodctx{\Gamma,x:\tau}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\vdash\goodctx{\Gamma} \quad \alpha\notin\Gamma \quad \Theta\vdash\tau:\kappa$}
      \RightLabel{\textsc{Ctx}$_2$}
      \UnaryInfC{$\Theta\vdash \goodctx{\Gamma,\alpha\cnt\tau}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
  \begin{minipage}{0.25\textwidth}
    \begin{prooftree}
      \AxiomC{\phantom{$x\in\nil$}}
      \RightLabel{\textsc{Ctx}$_3$}
      \UnaryInfC{$\Theta\vdash\goodctx{\nil}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{minipage}
\caption{Typing rules for \surfacelang{}}
\end{figure}
Typing terms in \surfacelang{} is split into five different judgement forms:
\begin{itemize}
  \item Typing Terms: $\Theta\mid\Gamma\vdash t:\tau$
  \item Substitution Typing: $\Theta\mid\Gamma\vdash\sigma:\Gamma^{\prime}$
  \item Kinding Types: $\Theta\mid\tau:\kappa$
  \item Well-formed programs: $\vdash \wellformed{\Theta}$
  \item Well-formed environments: $\Theta\vdash \goodctx{\Gamma}$
\end{itemize}
The rules for typing terms and kinding types are fairly standard.
Given a (well-formed) program $\Theta$ and a typing environment $\Gamma$, they assign types $\tau$ to terms $t$ and kinds $\kappa$ to types $\tau$, respectively.
Since we use typing contexts and substitutions for data and codata types, we have additional rules for typing $\sigma$ given a context $\Gamma^{\prime}$ (in a program $\Theta$ with context $\Gamma$).
These rules ensure that each term $t$ in $\sigma$ can be typechecked using the type $\tau$ assigned to its corresponding variable $x$ in $\Gamma$.
That is, given a data declaration of type $T$ with constructor $K$ that has defined environment $\Gamma^{\prime}$, a term $K\ \sigma$ has type $T$, if and only if $\sigma$ contains the same number of terms as $\Gamma$ contains variables, and for each $t$ in $\sigma$, the corresponding $x$ in $\Gamma$ has a type $\tau$ such that $\Theta\mid\Gamma\vdash t:\tau$.
The same goes for codata declarations and similarly for cases and cocases.
Here, the order of terms in both $\sigma$ and $\Gamma$ are important, as the order of constructor (or destructor) arguments defined in the declaration needs to be maintained.
\begin{example}
  Take the example program in \cref{ex:fun-syntax}. 
  In this case, we have the program $\Theta= \mathbf{data}\ Listint\{\mathtt{Nil}\ \Gamma_1, \mathtt{Cons}\ \Gamma_2\}$, where $\Gamma_1=\nil$ and $\Gamma_2 = x:\mathtt{Int}, xs:\mathtt{ListInt}$.
  When we then want to type check the body of $\mathtt{tl}$, $\caseof{ls}{\mathtt{Nil}\Rightarrow\mathtt{Nil}, \mathtt{Cons}(x,xs)\Rightarrow xs}$ within the program $\Theta$, we have to ensure the contexts for the constructors $\mathtt{Nil}$ and $\mathtt{Cons}$ in the case-expression match $\Gamma_1$ and $\Gamma_2$ in the data declaration (which in this case works).\\
  On the other hand, if we have a term \lstinline{Cons(1,Nil)}, we have the substitution $\sigma = 1,\mathtt{Nil}$, and type checking this term amounts to checking $\Theta\mid\Gamma \vdash 1:\mathtt{Int}$ and $\Theta\mid\Gamma\vdash \mathtt{Nil}:\mathtt{ListInt}$.
\end{example}

The last two judgements ensure well-formedness for programs and contexts used in the other rules.
A well-formed program is one where each constructor, destructor and type name appears only once, each type defined for a codata type can be kinded, each body of a top-level definition in a program can be type checked (using the typing environment defined by the top-level definition), and that each context appearing in the program is well-formed.
Environments are well-formed if they contain each variable and covariable only once, and each of its types can be kinded.

