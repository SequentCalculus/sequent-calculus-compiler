\begin{definition}[Syntactic Conventions]
  We use the following metavariables for all languages:
  \[
    \begin{array}{rcll}
      \odot  & \coloneqq & + \mid - \mid * & \emph{Arithmetic Operators}
    \end{array}
  \]
\end{definition}

\begin{definition}[Syntax of \surfacelang{}]
  We assume an infinite set of names $\mathcal{N}$ containing type names $T\in\mathcal{N}$, constructor names $K\in\mathcal{N}$ and destructor names $D\in\mathcal{N}$.
  \[
    \begin{array}{r c l l}
      t & \coloneqq & x \mid \lit{n} \mid t \odot t \mid \ifz{t}{t}{t} \mid \letin{x}{t}{t} \mid \lab{\alpha}{t} \mid \goto{t}{\alpha}  & \emph{Terms}\\
      & \mid & K(\sigma) \mid \caseof{t}{\overline{K\ \Gamma \Rightarrow t}} \mid t.D(\sigma) \mid \cocase{\overline{D\ \Gamma \Rightarrow t}} \mid f(\sigma)& \\
      c & \coloneqq & \alpha & \emph{Consumers}\\
      \sigma & \coloneqq & \nil \mid \sigma,t \mid \sigma, c & \emph{Substitutions}\\
      \tau & \coloneqq & \tyint \mid T & \emph{Types} \\
      \kappa & \coloneq & \mathbf{prim}\mid\mathbf{data} \mid \mathbf{codata} & \emph{Kinds} \\
      \Gamma & \Coloneqq & \nil \mid \Gamma, x : \tau \mid \Gamma, \alpha \cnt \tau & \emph{Typing Contexts} \\
      \delta & \coloneqq & \mathbf{data}\ T\ \{ \overline{K\ \Gamma} \}  \mid \mathbf{codata}\ T\ \{ \overline{D\ \Gamma : \tau}\} \mid \defi{f\ \Gamma}{t} & \emph{Declarations}\\
      \Theta & \coloneqq & \overline{\delta} & \emph{Programs}\\
    \end{array}
  \]
\end{definition}
In both the definitions for (co-) cases and for declarations we use typing contexts $\Gamma$ to encode the arguments of constructors and destructors.
This is a slight abuse of notation, since in data declarations, types for arguments are mandatory, while for clauses in (co-) cases, they are omitted.
Thus, the following is a valid program in \surfacelang{}.
\begin{example}
  \label{ex:fun-syntax}
  Consider the example of lists of integers:
  \begin{lstlisting}
  data ListInt {  Nil,   Cons(x:Int,xs:ListInt)  }
  def tl(ls) := case ls of { Nil => Nil, Cons(x,xs) => xs }
  \end{lstlisting}
  Here, the constructor $\mathtt{Cons}$ has arguments $x$ and $xs$, both of which are type annotated in the declaration of $\mathtt{ListInt}$, but not in the case expression.
\end{example}

%%
%% Subsec: Typing Rules
%%
\subsection{Typing Rules}
\label{subsec:fun:typing-rules}

\begin{figure}[hbtp]
  \begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Typing Terms}{$\Theta\mid\Gamma\vdash t : \tau$}

  \begin{minipage}{0.25\textwidth}
    \begin{prooftree}
      \AxiomC{$x : \tau \in \Gamma$}
      \RightLabel{\textsc{Var}}
      \UnaryInfC{$\Theta\mid\Gamma \vdash x : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.25\textwidth}
    \begin{prooftree}
      \AxiomC{\phantom{$x : \tau \in \Gamma$}}
      \RightLabel{\textsc{Lit}}
      \UnaryInfC{$\Theta\mid\Gamma \vdash \lit{n}:\tyint$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.4\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash t_1: \tyint \quad \Theta\mid\Gamma \vdash t_2: \tyint$}
      \RightLabel{\textsc{Op}}
      \UnaryInfC{$\Theta\mid\Gamma \vdash t_1\odot t_2 : \tyint$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash t : \tyint$}
      \AxiomC{$\Theta\mid\Gamma \vdash t_1 : \tau$}
      \AxiomC{$\Theta\mid\Gamma \vdash t_2 : \tau$}
      \RightLabel{\textsc{Ifz}}
      \TrinaryInfC{$\Theta\mid\Gamma \vdash \ifz{t}{t_1}{t_2} : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash t_1 : \tau_1$}
      \AxiomC{$\Theta\mid\Gamma, x : \tau_1 \vdash t_2 : \tau_2$}
      \RightLabel{\textsc{Let}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash \letin{x}{t_1}{t_2} :\tau_2$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.4\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma, \alpha \cnt \tau \vdash t : \tau$}
      \RightLabel{\textsc{Label}}
      \UnaryInfC{$\Theta\mid\Gamma \vdash \lab{\alpha}{t} : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.55\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash t : \tau$}
      \AxiomC{$\alpha \cnt \tau \in \Gamma$}
      \RightLabel{\textsc{Goto}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash \goto{t}{\alpha} : \tau'$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{data}\ T\ \{K\ \Gamma^{\prime}, \dots \}\in\Theta$}
      \AxiomC{$ \Theta\mid\Gamma \vdash \sigma:\Gamma^{\prime}$}
      \RightLabel{\textsc{Constructor}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash K\ \sigma : T$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{data}\ T\{\overline{K_i\ \Gamma_i)}\}\in \Theta$}
      \AxiomC{$\overline{\Theta\mid\Gamma,\Gamma_i\vdash t_i : \tau}$}
      \RightLabel{\textsc{Case}}
      \BinaryInfC{$\Theta\mid\Gamma\vdash \mathbf{case}\ t\ \mathbf{of}\ \{\overline{K_i\ \Gamma_i\Rightarrow t_i}\} : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{codata}\ T\ \{D\ \Gamma^{\prime}:\tau,\dots \}\in \Theta$}
      \AxiomC{$\Theta\mid\Gamma\vdash \sigma:\Gamma^{\prime}$}
      \AxiomC{$\Theta\mid\Gamma \vdash t :T$}
      \RightLabel{\textsc{Destructor}}
      \TrinaryInfC{$\Theta\mid\Gamma \vdash t.D\ \sigma : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{codata}\ T \{\overline{D_i\ \Gamma_i:\tau_i}\}\in \Theta$}
      \AxiomC{$\Theta\mid\Gamma,\Gamma_i \vdash t_i:\tau_i$}
      \RightLabel{\textsc{Cocase}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash \mathbf{cocase} \{ \overline{D_i\ \Gamma_i} \Rightarrow t_i \} : T$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{def}\ f\ \Gamma^{\prime} :\tau \in \Theta$}
      \AxiomC{$\Theta\mid\Gamma \vdash \sigma:\Gamma^{\prime} $}
      \RightLabel{\textsc{Call}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash f\ \sigma : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{minipage}
\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Consumer Typing}{$\Theta\mid\Gamma\vdash c\cnt\tau$}
  \begin{minipage}{\textwidth}
    \begin{prooftree}
      \AxiomC{$\alpha\cnt \tau\in\Gamma$}
      \RightLabel{\textsc{Var}$_2$}
      \UnaryInfC{$\Theta\mid\Gamma\vdash \alpha \cnt \tau$}
    \end{prooftree}
  \end{minipage}
\end{minipage}
\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Substitution Typing}{$\Theta\mid\Gamma\vdash\sigma:\Gamma^{\prime}$}

  \begin{minipage}{0.25\textwidth}
    \begin{prooftree}
      \AxiomC{\phantom{$\Theta\mid\Gamma \vdash \Gamma^{\prime}$}}
      \RightLabel{\textsc{Subst}$_1$}
      \UnaryInfC{$\Theta\mid\Gamma\vdash\nil:\nil$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma\vdash\sigma:\Gamma^{\prime} \quad \Theta\mid\Gamma\vdash t:\tau$}
      \RightLabel{\textsc{Subst}$_2$}
      \UnaryInfC{$\Theta\mid\Gamma \vdash \sigma,t : \Gamma^{\prime},x:\tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash \sigma:\Gamma^{\prime} \quad \Theta\mid\Gamma\vdash c\cnt\tau$}
      \RightLabel{\textsc{Subst}$_3$}
      \UnaryInfC{$\Theta\mid\Gamma \vdash \sigma,c: \Gamma^{\prime}, \alpha \cnt \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{minipage}
\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Kinding Types}{$\Theta\vdash\tau:\kappa$}
  \begin{minipage}{0.2\textwidth}
    \begin{prooftree}
      \AxiomC{}
      \RightLabel{\textsc{PrimKind}}
      \UnaryInfC{$\Theta \vdash \tyint : \mathbf{prim}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{data}\ T\ \{\, \ldots \} \in \Theta$}
      \RightLabel{\textsc{DataKind}}
      \UnaryInfC{$\Theta \vdash T : \mathbf{data}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{codata}\ T\ \{\, \ldots \} \in \Theta$}
      \RightLabel{\textsc{CodataKind}}
      \UnaryInfC{$\Theta \vdash T : \mathbf{codata}$}
    \end{prooftree}
  \end{minipage}
  \vspace{1em}
\end{minipage}
\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Well-formed Programs}{$\vdash \wellformed{\Theta}$}
  \begin{minipage}{0.2\textwidth}
    \begin{prooftree}
      \AxiomC{}
      \RightLabel{\textsc{Wf-Empty}}
      \UnaryInfC{$\vdash \wellformed{\nil}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.75\textwidth}
    \begin{prooftree}
      \AxiomC{$\vdash \wellformed{\Theta}$}
      \AxiomC{$\overline{\Theta,\mathbf{codata}\ T \{\dots\}\vdash\goodctx{\Gamma_i}}$}
      \AxiomC{$\overline{ \Gamma_i \vdash \tau_i:\kappa}$}
      \RightLabel{\textsc{Wf-Codata}}
      \TrinaryInfC{$\vdash \wellformed{\Theta,\mathbf{codata}\ T\ \{ \overline{D_i\ \Gamma_i : \tau_i}\}}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\vdash \wellformed{\Theta}$}
      \AxiomC{$\Theta, \mathbf{def}\ \text{f}\ \Gamma\coloneq t \mid\Gamma \vdash t:\tau$}
      \RightLabel{\textsc{Wf-\surfacelang{}}}
      \BinaryInfC{$\vdash \wellformed{\Theta,\mathbf{def}\ \text{f}\ \Gamma \coloneq t}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\vdash \wellformed{\Theta}$}
      \AxiomC{$\overline{\Theta,\mathbf{data}\ T\{\dots\}\vdash\goodctx{\Gamma_i}}$}
      \RightLabel{\textsc{Wf-Data}}
      \BinaryInfC{$\vdash \wellformed{\Theta,\mathbf{data}\ T\ \{ \overline{K_i\ \Gamma_i} \}}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{minipage}
\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Well-formed contexts}{$\Theta\vdash \goodctx{\Gamma}$}
  \begin{minipage}{0.25\textwidth}
    \begin{prooftree}
      \AxiomC{\phantom{$x\in\nil$}}
      \RightLabel{\textsc{Ctx}$_1$}
      \UnaryInfC{$\Theta\vdash\goodctx{\nil}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\vdash\goodctx{\Gamma} \quad x\notin\Gamma \quad \Theta\vdash\tau:\kappa$}
      \RightLabel{\textsc{Ctx}$_2$}
      \UnaryInfC{$\Theta\vdash\goodctx{\Gamma,x:\tau}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\vdash\goodctx{\Gamma} \quad \alpha\notin\Gamma \quad \Theta\vdash\tau:\kappa$}
      \RightLabel{\textsc{Ctx}$_3$}
      \UnaryInfC{$\Theta\vdash \goodctx{\Gamma,\alpha\cnt\tau}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{minipage}
\caption{Typing rules for \surfacelang{}}
\label{fig:fun-rules}
\end{figure}
Typing terms in \surfacelang{} is split into five different judgement forms.
The forms $\Theta\mid\Gamma\vdash t:\tau$ and $\Theta\mid\Gamma\vdash\sigma:\Gamma^{\prime}$ are both used to type terms.
We use the subsititution rules to easily check arguments for constructors/destructors and if clauses in cases/cocases are well-formed.
For these rules, the order of variables in $\Gamma$ and terms in $\sigma$ is important, as we always want to keep the order of arguments defined in a declaration.
\begin{example}
  Take the example program in \cref{ex:fun-syntax}.
  In this case, we have following program
  \begin{align*}
    \Theta= \mathbf{data}\ \mathtt{Listint}\ \{\mathtt{Nil}\ \Gamma_1, \mathtt{Cons}\ \Gamma_2\} \quad
    \Gamma_1=\nil, \Gamma_2 = x:\mathtt{Int}, xs:\mathtt{ListInt}.
  \end{align*}
  When we then want to type check the body of $\mathtt{tl}$, within the program $\Theta$,
  we have to ensure the contexts for the constructors $\mathtt{Nil}$ and $\mathtt{Cons}$ in the case-expression match $\Gamma_1$ and $\Gamma_2$ in the data declaration (which in this case works).\\
  On the other hand, if we have a term \lstinline{Cons(1,Nil)}, we have the substitution $\sigma = 1,\mathtt{Nil}$, and type checking this term amounts to checking
  $\Theta\mid\Gamma \vdash 1:\mathtt{Int}$ and $\Theta\mid\Gamma\vdash \mathtt{Nil}:\mathtt{ListInt}$.
\end{example}
Next, instead of having a single kind $*$ for the inhabited kind, we instead have this split into three distinct kinds.
The $\mathbf{prim}$ kind should be self-explanatory, as it is often used for more efficient handling of primitive types such as integers or floats.
On the other hand, $\mathbf{data}$ and $\mathbf{codata}$ are less standard, even in sequent calculus based languages.
We have included them in the language, since, as we will later see, data and codata types are handled differently when being translated to machine code, and thus we always need to keep track of them.\\
Lastly, we have the judgements $\vdash \wellformed{\Theta}$ and $\Theta\vdash\goodctx{\Gamma}$ used to ensure typing contexts and programs are well-formed,
i.e. that all occurring terms can be typed and all occuring terms can be kinded.
The one additional check that needs to happen during the well-formedness checks is name checking.
That is, we need to ensure all types $T$, constructors $K$, destructors $D$ and top-level definitions $f$ are only defined once and there are no name clashes.
