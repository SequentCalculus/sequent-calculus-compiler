\begin{definition}[Syntactic Conventions]
  We use the following metavariables for all languages:
  \[
    \begin{array}{rcll}
      \odot  & \coloneqq & + \mid - \mid * & \emph{Arithmetic Operators}
    \end{array}
  \]
\end{definition}

\begin{definition}[Syntax of \surfacelang{}]
  We assume an infinite set of names $\mathcal{N}$ containing type names $T\in\mathcal{N}$, constructor names $K\in\mathcal{N}$ and destructor names $D\in\mathcal{N}$.
  \[ 
    \begin{array}{r c l l}
      t & \coloneqq & x \mid \lit{n} \mid t \odot t \mid \ifz{t}{t}{t} \mid \letin{x}{t}{t} \mid f(\overline{t}; \overline{\alpha}) \mid \lab{\alpha}{t} \mid \goto{t}{\alpha} & \emph{Terms}\\
      & \mid & K(\sigma) \mid \caseof{t}{\overline{K\ \Gamma \Rightarrow t}} \mid t.D(\sigma) \mid \cocase{\overline{D\ \Gamma \Rightarrow t}} & \\
      \sigma & \coloneqq & \nil \mid \sigma,t \mid \sigma, \alpha & \emph{Substitutions}\\
      \tau & \coloneqq & \tyint \mid T & \emph{Types} \\
      \kappa & \coloneq & \mathbf{data} \mid \mathbf{codata} \mid \mathbf{prim} & \emph{Kinds} \\
      \Gamma & \Coloneqq & \nil \mid \Gamma, x : \tau \mid \Gamma, \alpha \cnt \tau & \emph{Typing Contexts} \\
      \delta & \coloneqq & \mathbf{data}\ T\ \{ \overline{K\ \Gamma} \}  \mid \mathbf{codata}\ T\ \{ \overline{D\ \Gamma : \tau}\} \mid \defi{f\ \Gamma}{t} & \emph{Declarations}\\
      \Theta & \coloneqq & \overline{\delta} & \emph{Programs}\\
    \end{array}
  \]
\end{definition}

In both the definitions for (co-) cases and for declarations we use typing contexts $\Gamma$ to encode the arguments of constructors and destructors. 
This is a slight abuse of notation, since in data declarations, types for arguments are mandatory, while for clauses in (co-) cases, they are omitted.
Thus, the following is a valid program in \surfacelang{}.
\begin{lstlisting}
data ListInt { 
  Nil,
  Cons(x:Int,xs:ListInt)
}

def tl(ls) := case ls of { 
  Nil => Nil,
  Cons(x,xs) => xs
}
\end{lstlisting}
In the above example, the constructor $\mathtt{Cons}$ has arguments $x$ and $xs$, both of which are type annotated in the declaration of $\mathtt{ListInt}$. 

%%
%% Subsec: Typing Rules
%%
\subsection{Typing Rules}
\label{subsec:fun:typing-rules}


Typing Judgements have the form $\Theta\mid\Gamma\vdash t:\tau$ using a program $\Theta$ containing top-level definitions and (co-) data declarations and a typing context $\Gamma$ to infer the type $\tau$ of a term $t$.\\

\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Typing Terms}{$\Theta\mid\Gamma\vdash t : \tau$}

  \begin{minipage}{0.25\textwidth}
    \begin{prooftree}
      \AxiomC{$x : \tau \in \Gamma$}
      \RightLabel{\textsc{Var}}
      \UnaryInfC{$\Theta\mid\Gamma \vdash x : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.25\textwidth}
    \begin{prooftree}
      \AxiomC{\phantom{$x : \tau \in \Gamma$}}
      \RightLabel{\textsc{Lit}}
      \UnaryInfC{$\Theta\mid\Gamma \vdash \lit{n}:\tyint$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.4\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash t_1: \tyint \quad \Theta\mid\Gamma \vdash t_2: \tyint$}
      \RightLabel{\textsc{Op}}
      \UnaryInfC{$\Theta\mid\Gamma \vdash t_1\odot t_2 : \tyint$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash t : \tyint$}
      \AxiomC{$\Theta\mid\Gamma \vdash t_1 : \tau$}
      \AxiomC{$\Theta\mid\Gamma \vdash t_2 : \tau$}
      \RightLabel{\textsc{Ifz}}
      \TrinaryInfC{$\Theta\mid\Gamma \vdash \ifz{t}{t_1}{t_2} : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash t_1 : \tau_1$}
      \AxiomC{$\Theta\mid\Gamma, x : \tau_1 \vdash t_2 : \tau_2$}
      \RightLabel{\textsc{Let}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash \letin{x}{t_1}{t_2} :\tau_2$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.55\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash t : \tau$}
      \AxiomC{$\alpha \cnt \tau \in \Gamma$}
      \RightLabel{\textsc{Goto}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash \goto{t}{\alpha} : \tau'$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.4\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma, \alpha \cnt \tau \vdash t : \tau$}
      \RightLabel{\textsc{Label}}
      \UnaryInfC{$\Theta\mid\Gamma \vdash \lab{\alpha}{t} : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{data}\ T\ \{K\ \Gamma^{\prime}, \dots \}\in\Theta$}
      \AxiomC{$ \Theta\mid\Gamma \vdash \sigma:\Gamma^{\prime}$}
      \RightLabel{\textsc{Constructor}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash K\ \sigma : T$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{data}\ T\{\overline{K_i\ \Gamma_i)}\}\in \Theta$}
      \AxiomC{$\overline{\Theta\mid\Gamma,\Gamma_i\vdash t_i : \tau}$}
      \RightLabel{\textsc{Case}}
      \BinaryInfC{$\Theta\mid\Gamma\vdash \mathbf{case}\ t\ \mathbf{of}\ \{\overline{K_i\ \Gamma_i\Rightarrow t_i}\} : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{codata}\ T\ \{D\ \Gamma^{\prime}:\tau,\dots \}\in \Theta$}
      \AxiomC{$\Theta\mid\Gamma\vdash \sigma:\Gamma^{\prime}$}
      \AxiomC{$\Theta\mid\Gamma \vdash t :T$}
      \RightLabel{\textsc{Destructor}}
      \TrinaryInfC{$\Theta\mid\Gamma \vdash t.D\ \sigma : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{codata}\ T \{\overline{D_i\ \Gamma_i:\tau_i}\}\in \Theta$}
      \AxiomC{$\Theta\mid\Gamma,\Gamma_i \vdash t_i:\tau_i$}
      \RightLabel{\textsc{Cocase}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash \mathbf{cocase} \{ \overline{D_i\ \Gamma_i} \Rightarrow t_i \} : T$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{def}\ f\ \Gamma^{\prime} :\tau \in \Theta$}
      \AxiomC{$\Theta\mid\Gamma \vdash \sigma:\Gamma^{\prime} $}
      \RightLabel{\textsc{Call}}
      \BinaryInfC{$\Theta\mid\Gamma \vdash f\ \sigma : \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{minipage}
These rules are all fairly standard, but because we are using typing environments $\Gamma$ in some terms and substitutions $\sigma$ in others, we need an additional judgement to type substitutions.
These have the form $\Theta\mid\Gamma \vdash \sigma : \Gamma^{\prime}$, typing all terms $t$ in $\sigma$ with their respective types in $\Gamma^{\prime}$ using $\Theta$ and $\Gamma$ as above.
They can be read as ``The substitution $\sigma$ is valid given the environment $\Gamma^{\prime}$'', and a substitution being valid means that each term can be typed with the type given in $\Gamma^{\prime}$. 
Note that the order of elements in $\sigma$ and $\Gamma$ are important here, as constructor arguments in terms need to have the same order as in the declaration, for example.\\
\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Substitution Typing}{$\Theta\mid\Gamma\vdash\sigma:\Gamma^{\prime}$}

  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma\vdash\sigma:\Gamma^{\prime} \quad \Theta\mid\Gamma\vdash t:\tau$}
      \RightLabel{\textsc{Subst}$_1$}
      \UnaryInfC{$\Theta\mid\Gamma \vdash \sigma,t : \Gamma^{\prime},x:\tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\mid\Gamma \vdash \sigma:\Gamma^{\prime} \quad \alpha\cnt\tau\in\Gamma$}
      \RightLabel{\textsc{Subst}$_2$}
      \UnaryInfC{$\Theta\mid\Gamma \vdash \sigma,\alpha : \Gamma^{\prime}, \alpha\cnt \tau$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.25\textwidth}
    \begin{prooftree}
      \AxiomC{\phantom{$\Theta\mid\Gamma \vdash \Gamma^{\prime}$}}
      \RightLabel{\textsc{Subst}$_3$}
      \UnaryInfC{$\Theta\mid\Gamma\vdash\nil:\nil$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{minipage}
Next, each type needs to be kinded with one of the three primitive kinds defined above.
These judegements have the form $\Theta\vdash \tau : \kappa$, kinding a type $\tau$ with a kind $\kappa$ in a program $\Theta$.\\
\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Kinding Types}{$\Theta\vdash\tau:\kappa$}
  \begin{minipage}{0.2\textwidth}
    \begin{prooftree}
      \AxiomC{}
      \RightLabel{\textsc{PrimKind}}
      \UnaryInfC{$\Theta \vdash \tyint : \mathbf{prim}$}
    \end{prooftree}  
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{data}\ T\ \{\, \ldots \} \in \Theta$}
      \RightLabel{\textsc{DataKind}}
      \UnaryInfC{$\Theta \vdash T : \mathbf{data}$}
    \end{prooftree}  
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\mathbf{codata}\ T\ \{\, \ldots \} \in \Theta$}
      \RightLabel{\textsc{CodataKind}}
      \UnaryInfC{$\Theta \vdash T : \mathbf{codata}$}
    \end{prooftree}  
  \end{minipage}
  \vspace{1em}
\end{minipage}
Lastly, before we can type terms and kind types, we need to ensure the program $\Theta$ used in the judgements is well-formed, written as $\wellformed{\Theta}$ 
This is done using the following well-formedness rules, used to ensure constructors and destructors as well was type names are not defined multiple times, and to validate all terms and types in the program are also well-formed (i.e. they type check or kind check, respectively).
In order to check typing environments of decalarions and functions, we use a secondary judgement $\goodctx{\Gamma}$ to kind check all types in the environment. \\
\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Well-formed Programs}{$\vdash \wellformed{\Theta}$}
  \begin{minipage}{0.2\textwidth}
    \begin{prooftree}
      \AxiomC{}
      \RightLabel{\textsc{Wf-Empty}}
      \UnaryInfC{$\vdash \wellformed{\nil}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.75\textwidth}
    \begin{prooftree}
      \AxiomC{$\vdash \wellformed{\Theta}$}
      \AxiomC{$\overline{D},T$ do not occur in $\Theta$}
      \AxiomC{$\overline{\Theta\vdash\goodctx{\Gamma_i}}$}
      \AxiomC{$\overline{ \Gamma_i \vdash \tau_i:\kappa}$}
      \RightLabel{\textsc{Wf-Codata}}
      \QuaternaryInfC{$\vdash \wellformed{\Theta,\mathbf{codata}\ T\ \{ \overline{D_i\ \Gamma_i : \tau_i}\}}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}

  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\vdash \wellformed{\Theta}$}
      \AxiomC{$\overline{K},T$ do not occur in $\Theta$}
      \AxiomC{$\overline{\Theta\vdash\goodctx{\Gamma_i}}$}
      \RightLabel{\textsc{Wf-Data}}
      \TrinaryInfC{$\vdash \wellformed{\Theta,\mathbf{data}\ T\ \{ \overline{K_i\ \Gamma_i} \}}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \begin{prooftree}
      \AxiomC{$\vdash \wellformed{\Theta}$}
      \AxiomC{$\Theta, \mathbf{def}\ \text{f}\ \Gamma\coloneq t \mid\Gamma \vdash t:\tau$}
      \RightLabel{\textsc{Wf-\surfacelang{}}}
      \BinaryInfC{$\vdash \wellformed{\Theta,\mathbf{def}\ \text{f}\ \Gamma \coloneq t}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{minipage}
\begin{minipage}{\textwidth}
  \vspace{1em}
  \judgementbox{Well-formed contexts}{$\Theta\vdash \goodctx{\Gamma}$}
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\vdash\goodctx{\Gamma} \quad x\notin\Gamma \quad \Theta\vdash\tau:\kappa$}
      \RightLabel{\textsc{Ctx}$_1$}
      \UnaryInfC{$\Theta\vdash\goodctx{\Gamma,x:\tau}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
  \begin{minipage}{0.35\textwidth}
    \begin{prooftree}
      \AxiomC{$\Theta\vdash\goodctx{\Gamma} \quad \alpha\notin\Gamma \quad \Theta\vdash\tau:\kappa$}
      \RightLabel{\textsc{Ctx}$_2$}
      \UnaryInfC{$\Theta\vdash \goodctx{\Gamma,\alpha\cnt\tau}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
  \begin{minipage}{0.25\textwidth}
    \begin{prooftree}
      \AxiomC{\phantom{$x\in\nil$}}
      \RightLabel{\textsc{Ctx}$_3$}
      \UnaryInfC{$\Theta\vdash\goodctx{\nil}$}
    \end{prooftree}
  \end{minipage}
  \hfill
  \vspace{1em}
\end{minipage}
