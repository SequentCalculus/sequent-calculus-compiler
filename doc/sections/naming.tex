We now start transforming terms of the language \targetlang{} into a normal form suitable for compilation to machine code.
The first step is to give names to all subterms, similar to A-normal form \cite{Flanagan1993} or
continuation-passing style \cite{Kennedy2007continued}.
This is a generalization of the static focusing transformation \cite{Andreoli1992logicprogramming, Curien2000duality} which usually only names non-value producers of data types and non-value consumers of codata types.
The transformation targets the following fragment \targetvar{} of \targetlang{} where arguments of constructors, destructors and calls to top-level definitions as well as the producer arguments of conditionals and arithmetic operators are always (co-)variables.

\begin{definition}[Syntax of \targetvar{}]
  \[
    \begin{array}{rcll}
      p & \coloneqq & x \mid \lit{n} \mid \mu\alpha.s \mid K\ \Gamma \mid \cocase{\overline{D\ \Gamma \Rightarrow s}} & \emph{Producers}\\
      c & \coloneqq & \alpha \mid \tilde{\mu}x.s \mid D\ \Gamma \mid \case{\overline{K\ \Gamma \Rightarrow s}}& \emph{Consumers}\\
      s & \coloneqq & \cut{p}{c} \mid \ifz{x}{s}{s} \mid \odot(x, x; c) \mid f\ \Gamma \mid \done & \emph{Statements}\\
    \end{array}
  \]
\end{definition}

This means that substitutions now always consist of (co-)variables which is indicated in the syntax by replacing $\sigma$ by $\Gamma$.
For the corresponding typing rules we thus obtain

\vspace{1em}
\begin{minipage}{0.45\textwidth}
\begin{prooftree}
  \AxiomC{$\Theta \mid \Gamma \vdash \sigma : \Gamma^{\prime}$}
  \AxiomC{$x : \tau \in \Gamma$}
  \RightLabel{\textsc{Var}}
  \UnaryInfC{$\Theta \mid \Gamma \vdash x : \tau$}
  \RightLabel{\textsc{Subst}$_2$}
  \BinaryInfC{$\Theta \mid \Gamma \vdash \sigma, x : \Gamma^{\prime}, x : \tau$}
\end{prooftree}
\end{minipage}
\begin{minipage}{0.45\textwidth}
\begin{prooftree}
  \AxiomC{$\Theta \mid \Gamma \vdash \sigma : \Gamma^{\prime}$}
  \AxiomC{$\alpha \cnt \tau \in \Gamma$}
  \RightLabel{\textsc{Var}$_2$}
  \UnaryInfC{$\Theta \mid \Gamma \vdash \alpha \cnt \tau$}
  \RightLabel{\textsc{Subst}$_3$}
  \BinaryInfC{$\Theta \mid \Gamma \vdash \sigma, \alpha : \Gamma^{\prime}, \alpha \cnt \tau$}
\end{prooftree}
\end{minipage}
\vspace{1em}

\noindent The typing judgment for substitutions hence always becomes $\Theta \mid \Gamma \vdash \Gamma^{\prime} : \Gamma^{\prime}$ which we can abbreviate to $\Theta \mid \Gamma \vdash \Gamma^{\prime}$ with the meaning that for each $v :^{p} \tau \in \Gamma^{\prime}$ we have $v :^{p} \tau \in \Gamma$.

To make the transformation uniform, compositional and to avoid administrative redexes, it is split into three mutually recursive functions $\name{\cdot}$, $\bind{\cdot}{\cdot}$ and $\binds{\cdot}{\cdot}$, where the latter two both take a continuation as an additional argument.
The interesting part for $\name{\cdot}$ is its definition on statements for the cases where producers and consumers occur in argument positions
Therefore, the cases for a cut including a constructor or destructor are special-cased.
All other parts of $\name{\cdot}$ are simple congruences.
Types do not need to be transformed.
The idea is to lift all non-(co-)variable producers and consumers in argument positions by calling $\bind{\cdot}{\cdot}$ --- or $\binds{\cdot}{\cdot}$ in the case where a whole list of arguments is to be lifted --- and pass the statement itself in a continuation which binds fresh names for the arguments.
The function $\binds{\cdot}{\cdot}$ simply maps $\bind{\cdot}{\cdot}$ over a list of arguments, but in continuation-passing style.
The function $\bind{\cdot}{\cdot}$ pattern-matches on a given producer or consumer, transforms it recursively, creates a fresh (co-)variable and uses a $\mu$- or $\tilde\mu$-binding to bind the transformed term in a cut.
The body of the $\mu$- or $\tilde\mu$-binding consists of the given continuation applied to the freshly generated (co-)variable.
In the case where the producer or consumer is a (co-)variable already, the continuation is simply applied to it.
In the case where the producer or consumer is another constructor or destructor, the function $\binds{\cdot}{\cdot}$ is applied recursively to again lift the corresponding arguments.
Otherwise, the function $\name{\cdot}$ is recursively applied to all substatements.

\begin{gather*}
  \begin{array}{rclrcl}
    \multicolumn{3}{c}{\name{\cdot} : \emph{Statement}_{\targetlang{}} \rightarrow \emph{Statement}_{\targetvar{}}} &
    \multicolumn{3}{c}{\name{\cdot} : \emph{Definition}_{\targetlang{}} \rightarrow \emph{Definition}_{\targetvar{}}} \\
    \name{\cut{K\ \sigma}{c}} & \coloneq & \binds{\sigma}{\lambda as.\cut{K(as)}{\name{c}}} &
    \name{\defi{f\ \Gamma}{s}} & \coloneq & \defi{f\ \Gamma}{\name{s}} \\
    \name{\cut{p}{D\ \sigma}} & \coloneq & \binds{\sigma}{\lambda as.\cut{\name{p}}{D(as)}} \\
    \name{\cut{p}{c}} & \coloneq & \cut{\name{p}}{\name{c}} \\
    \name{\odot(p_1, p_2; c)}{} & \coloneq & \bind{p_1}{\lambda a_1.\bind{p_2}{\lambda a_2.\odot(a_1, a_2; c)}} \\
    \name{\ifz{p}{s_1}{s_2}}{} & \coloneq & \bind{p}{\lambda a.\ifz{a}{\name{s_1}}{\name{s_2}}} \\
    \name{f\ \sigma}{} & \coloneq & \binds{\sigma}{\lambda as.f(as)} \\
    \name{\done}{} & \coloneq & \done \\
    \\
    \multicolumn{3}{c}{\name{\cdot} : \emph{Producer}_{\targetlang{}} \rightarrow \emph{Producer}_{\targetvar{}}} &
    \multicolumn{3}{c}{\name{\cdot} : \emph{Consumer}_{\targetlang{}} \rightarrow \emph{Consumer}_{\targetvar{}}} \\
    \name{x} & \coloneq & x &
    \name{\alpha} & \coloneq & \alpha \\
    \name{\lit{n}} & \coloneq & \lit{n} & & & \\
    \name{\mu\alpha.s} & \coloneq & \mu\alpha.\name{s} &
    \name{\tilde{\mu}x.s} & \coloneq & \tilde{\mu}x.\name{s} \\
    \name{K\ \sigma} & \coloneq & \text{does not occur} &
    \name{D\ \sigma} & \coloneq & \text{does not occur} \\
    \name{\cocase{\overline{D_i\ \Gamma_i \Rightarrow s_i}}} & \coloneq & \cocase{\overline{D_i\ \Gamma_i \Rightarrow \name{s_i}}} &
    \name{\case{\overline{K_i\ \Gamma_i \Rightarrow s_i}}} & \coloneq & \case{\overline{K_i\ \Gamma_i \Rightarrow \name{s_i}}} \\
  \end{array}
  \\\\
  \begin{array}{rcll}
    \multicolumn{4}{c}{\bind{\cdot}{\cdot} : \emph{Producer}_{\targetlang{}} \times (\emph{Name} \rightarrow \emph{Statement}_{\targetvar{}}) \rightarrow \emph{Statement}_{\targetvar{}}}\\
    \bind{x}{k} & \coloneq & k(x) & \\
    \bind{\lit{n}}{k} & \coloneq & \cut{\lit{n}}{\tilde{\mu}x.k(x)} & \fresh{x} \\
    \bind{\mu\alpha.s}{k} & \coloneq & \cut{\mu\alpha.\name{s}}{\tilde{\mu}x.k(x)} & \fresh{x} \\
    \bind{K\ \sigma}{k} & \coloneq & \binds{\sigma}{\lambda as.\cut{K(as)}{\tilde{\mu}x.k(x)}} & \fresh{x} \\
    \bind{\cocase{\overline{D_i\ \Gamma_i \Rightarrow s_i}}}{k} & \coloneq & \cut{\cocase{\overline{D_i\ \Gamma_i \Rightarrow \name{s_i}}}}{\tilde{\mu}x.k(x)} & \fresh{x} \\
    \\
    \multicolumn{4}{c}{\bind{\cdot}{\cdot} : \emph{Consumer}_{\targetlang{}} \times (\emph{Name} \rightarrow \emph{Statement}_{\targetvar{}}) \rightarrow \emph{Statement}_{\targetvar{}}}\\
    \bind{\alpha}{k} & \coloneq & k(\alpha) & \\
    \bind{\tilde{\mu}x.s}{k} & \coloneq & \cut{\mu\alpha.k(\alpha)}{\tilde{\mu}x.\name{s}} & \fresh{\alpha} \\
    \bind{D\ \sigma}{k} & \coloneq & \binds{\sigma}{\lambda as.\cut{\mu\alpha.k(\alpha)}{D(as)}} & \fresh{\alpha} \\
    \bind{\case{\overline{K_i\ \Gamma_i \Rightarrow s_i}}}{k} & \coloneq & \cut{\mu\alpha.k(\alpha)}{\case{\overline{K_i\ \Gamma_i \Rightarrow \name{s_i}}}} & \fresh{\alpha} \\
    \\
    \multicolumn{4}{c}{\binds{\cdot}{\cdot} : \emph{Substitution} \times (\emph{List Name} \rightarrow \emph{Statement}_{\targetvar{}}) \rightarrow \emph{Statement}_{\targetvar{}}}\\
    \binds{\nil}{k} & \coloneq & k(\nil) & \\
    \binds{e :: \sigma}{k} & \coloneq & \bind{e}{\lambda a.\binds{\sigma}{\lambda as.k(a :: as)}} & \\
  \end{array}
\end{gather*}
