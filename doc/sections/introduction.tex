Compiling a modern functional programming language like Haskell or OCaml to efficient machine code is a complicated affair, since we have to cross many different levels of abstraction in order to bridge the gap between high-level conveniences and low-level concerns.
In this paper we present such a complete compilation pipeline, starting with a surface language which supports different calling conventions, codata types and control effects, and ending up with machine code for Risc-V and X86-64.
More concretely, we show how to implement all of the following stages in the compiler pipeline:
\medskip

\begin{center}
  \begin{tikzpicture}
    \draw (0,0) rectangle (2,2) node[pos=.5] {\surfacelang};
    \draw (3,0) rectangle (5,2) node[pos=.5] {\targetlang};
    \draw (6,0) rectangle (8,2) node[pos=.5] {\machinelang};
    \draw (9,0) rectangle (11,2) node[pos=.5] {Risc-V};
    \draw[->] (2,1) -- (3,1);
    \draw[->] (5,1) -- (6,1);
    \draw[->] (8,1) -- (9,1);
  \end{tikzpicture}
\end{center}

The rest of this article is structured as follows:
\begin{itemize}
    \item In \cref{sec:fun} we introduce the surface language \surfacelang.
    \item In \cref{sec:core} we introduce the intermediate language \targetlang.
    \item In \cref{sec:translation} we show how to translate programs from the surface language \surfacelang\ to the intermediate language \targetlang.
    \item In \cref{sec:naming-transformation} we show a transformation on programs in \targetlang\ which names all intermediate computations, similar to ANF or focusing transformations.
    \item In \cref{sec:redundancy-elimination} and \cref{sec:substructurality-analysis} we \ldots
    \item In \cref{sec:axcut} we introduce the low-level intermediate language \machinelang, and in \cref{sec:toaxcut} we show how to compile \targetlang\ to \machinelang.
\end{itemize}
We discuss related work in \cref{sec:related-work} and conclude in \cref{sec:conclusion}.
