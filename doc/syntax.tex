\documentclass[nonacm]{acmart}
\settopmatter{printfolios=true,printccs=true,printacmref=true}

\usepackage{mathtools}
\usepackage{amsmath}

%%
%% Macros
%%

\newcommand{\translate}[1]{\ensuremath{\llbracket#1 \rrbracket}}
\newcommand{\lit}[1]{\ensuremath{\ulcorner #1\urcorner}}
\newcommand{\cut}[2]{\ensuremath{\langle #1 \mid #2 \rangle}}
\newcommand{\letin}[3]{\ensuremath{\mathbf{let}\ #1 \coloneqq #2\ \mathbf{in}\ #3}}
\newcommand{\caseof}[2]{\ensuremath{\mathbf{case}\ #1\ \mathbf{of}\ \{ #2 \}}}
\newcommand{\translatestar}[2]{\ensuremath{\llbracket #1 \rrbracket_{#2}^*}}
\newcommand{\reducesto}{\ensuremath{\triangleright}}
\newcommand{\focus}[1]{\ensuremath{\mathcal{F}(#1)}}
\newcommand{\fresh}[1]{\ensuremath{(#1\text{ fresh})}}


\begin{document}
%%
%% Title information
%%
\title{Compiling Functional Languages To Machine Code}
\subtitle{A Complete Story}

%%
%% Keywords
%%
\keywords{Intermediate representations, continuations, codata types, control effects}

%%
%% CCS Classification
%%

\begin{CCSXML}
  <ccs2012>
     <concept>
         <concept_id>10003752.10003753.10003754.10003733</concept_id>
         <concept_desc>Theory of computation~Lambda calculus</concept_desc>
         <concept_significance>500</concept_significance>
         </concept>
     <concept>
         <concept_id>10011007.10011006.10011041</concept_id>
         <concept_desc>Software and its engineering~Compilers</concept_desc>
         <concept_significance>500</concept_significance>
         </concept>
     <concept>
         <concept_id>10011007.10011006.10011008.10011024.10011027</concept_id>
         <concept_desc>Software and its engineering~Control structures</concept_desc>
         <concept_significance>300</concept_significance>
         </concept>
   </ccs2012>
\end{CCSXML}
  
\ccsdesc[500]{Theory of computation~Lambda calculus}
\ccsdesc[500]{Software and its engineering~Compilers}
\ccsdesc[300]{Software and its engineering~Control structures}

%%
%% Author: David Binder
%%
\author{David Binder}
\orcid{0000-0003-1272-0972}
\affiliation{
  \department{Department of Computer Science}
  \institution{University of Tübingen}
  \city{Tübingen}
  \country{Germany}
}
\email{david.binder@uni-tuebingen.de}

%%
%% Author: Marco Tzschentke
%%
\author{Marco Tzschentke}
\orcid{0009-0004-8834-2984}
\affiliation{
  \department{Department of Computer Science}
  \institution{University of Tübingen}
  \city{Tübingen}
  \country{Germany}
}
\email{marco.tzschentke@uni-tuebingen.de}

%%
%% Author: Marius Müller
%%
\author{Marius Müller}
\orcid{0000-0002-0260-6298}
\affiliation{
  \department{Department of Computer Science}
  \institution{University of Tübingen}
  \city{Tübingen}
  \country{Germany}
}
\email{mari.mueller@uni-tuebingen.de}

%%
%% Author: Philipp Schuster
%%
\author{Philipp Schuster}
\orcid{0000-0001-8011-0506}
\affiliation{
  \department{Department of Computer Science}
  \institution{University of Tübingen}
  \city{Tübingen}
  \country{Germany}
}
\email{philipp.schuster@uni-tuebingen.de}

%%
%% Author: Jonathan Immanuel Brachthäuser
%%
\author{Jonathan Immanuel Brachthäuser}
\orcid{0000-0001-9128-0391}
\affiliation{
  \department{Department of Computer Science}
  \institution{University of Tübingen}
  \city{Tübingen}
  \country{Germany}
}
\email{jonathan.brachthaeuser@uni-tuebingen.de}

%%
%% Author: Klaus Ostermann
%%
\author{Klaus Ostermann}
\orcid{0000-0001-5294-5506}
\affiliation{
  \department{Department of Computer Science}
  \institution{University of Tübingen}
  \city{Tübingen}
  \country{Germany}
}
\email{klaus.ostermann@uni-tuebingen.de}

%%
%% Abstract
%%
\begin{abstract}
  Compiling a high-level functional programming language to machine code that can be executed efficiently on a modern machine is a complicated task, since we have to traverse many different levels of abstraction.
  In this paper we tell the complete story, starting from a ML-like functional programming language and ending up with Risc-V and x86-64 machine code.
  The novelty of our approach lies in the fact that we use the sequent calculus, and sequent calculus inspired languages, in specifying the intermediate stages of our compiler.
\end{abstract}

\maketitle


%%
%% Section: Syntax of Fun
%%
\section{Syntax of Fun}
\label{sec:syntax-of-fun}

\begin{definition}[Syntactic Conventions]
  We use the following metavariables for all languages:
  \[
    \begin{array}{rcll}
      K & \coloneqq & \mathtt{Nil}, \mathtt{Cons}, \mathtt{Tup} & \emph{Constructors}\\
      D & \coloneqq & \mathtt{hd}, \mathtt{tl}, \mathtt{fst}, \mathtt{snd} & \emph{Destructors}\\
      \odot  & \coloneqq & + \mid - \mid * & \emph{Arithmetic Operators}
    \end{array}
  \]
\end{definition}

\begin{definition}[Syntax of Fun]
  \[ 
    \begin{array}{r c l l}
      t & \coloneqq & x \mid \lit{n} \mid t \odot t \mid \mathbf{ifz}(t,t,t) \mid \letin{x}{t}{t} \mid f(\overline{t};\overline{\alpha}) & \emph{Terms}\\

      & \mid & K(\overline{t}) \mid \caseof{t}{\overline{K(\overline{x})} \Rightarrow t} \mid t.D(\overline{t}) \mid \mathbf{cocase} \{ \overline{ D(\overline{x})} \Rightarrow t \} &\\
      & \mid & \lambda x.t \mid t\ t \mid \mathbf{label}\ \alpha\ \{t\} \mid \mathbf{goto}(t;\alpha) & \\
      \Theta & \coloneqq & \emptyset \mid \mathbf{def}\ f(\overline{x};\overline{\alpha}) \coloneq t; \Theta & \emph{Programs}\\
    \end{array}
  \]
\end{definition}

%%
%% Section: Syntax of Core
%%
\section{Syntax of Core}
\label{sec:syntax-of-core}

\begin{definition}[Syntax of Core]
  \[
    \begin{array}{rcll}
      p & \coloneqq & x \mid \lit{n} \mid \mu \alpha.s \mid K(\overline{p};\overline{c}) \mid \mathbf{cocase} \{ \overline{D(\overline{x};\overline{\alpha}) \Rightarrow s}\} & \emph{Producers}\\
      c & \coloneqq & \alpha \mid \tilde{\mu} x.s \mid D(\overline{p};\overline{c}) \mid \mathbf{case} \{ \overline{K(\overline{x};\overline{\alpha}) \Rightarrow s} \}& \emph{Consumers}\\
      s & \coloneqq & \cut{p}{c} \mid \odot(p,p;c) \mid \mathbf{ifz}(p;s,s) \mid f(\overline{p};\overline{c}) \mid \mathbf{done} & \emph{Statements}\\
      \Theta & \coloneqq & \emptyset \mid \mathbf{def}\ f(\overline{x};\overline{\alpha}) \coloneq s; \Theta & \emph{Programs}\\
    \end{array}
  \]
\end{definition}

%%
%% Section: Translation
%%
\section{Translation}
\label{sec:translation}


\[
  \begin{array}{rcll}
    \multicolumn{4}{c}{\translate{\cdot} : \emph{Terms} \rightarrow \emph{Producers}}\\
    \\
    \translate{\mathbf{def}\ f(\overline{x};\overline{\alpha}) \coloneq t} & \coloneq & \mathbf{def}\ f(\overline{x};\overline{\alpha},\alpha) \coloneq \cut{\translate{t}}{\alpha} & \fresh{\alpha}\\
  \quad \\
    \translate{x} & \coloneq & x & \\
    \translate{n} & \coloneq & n & \\
    \translate{t_1 \odot t_2} & \coloneq & \mu \alpha.\odot(\translate{t_1},\translate{t_2};\alpha) & \fresh{\alpha}\\
    \translate{\mathbf{ifz}(t_1,t_2,t_3)} & \coloneq & \mu \alpha.\mathbf{ifz}(\translate{t_1},\cut{\translate{t_2}}{\alpha},\cut{\translate{t_3}}{\alpha}) & \fresh{\alpha}\\
    \translate{\letin{x}{t_1}{t_2}} & \coloneq & \mu \alpha.\cut{\translate{t_1}}{\tilde{\mu}x.\cut{\translate{t_2}}{\alpha}} & \fresh{\alpha}\\
    \translate{f(\overline{t_i};\overline{\alpha_j})} & \coloneq & \mu \alpha.f(\overline{\translate{t_i}};\overline{\alpha_j},\alpha) & \fresh{\alpha}\\
    \translate{K(\overline{t_i})} & \coloneq & K(\overline{\translate{t_i}}) & \\
    \translate{\caseof{t}{\overline{K_i(\overline{x_{i,j}}) \Rightarrow t_i}}} & \coloneq & \mu \alpha \cut{\translate{t}}{\mathbf{case}\ \{ \overline{K_i(\overline{x_{i,j}}) \Rightarrow \cut{\translate{t_i}}{\alpha}}\}} & \fresh{\alpha}\\
    \translate{t.D(\overline{t_i})} & \coloneq & \mu\alpha.\cut{\translate{t}}{D(\overline{\translate{t_i}};\alpha)} & \fresh{\alpha}\\
    \translate{\mathbf{cocase}\ \{\overline{D_i(\overline{x_{ij}})\Rightarrow t_i}\}} & \coloneq & \mathbf{cocase}\ \{ \overline{D_i(\overline{x_{i,j}};\alpha_i)\Rightarrow \cut{\translate{t_i}}{\alpha_i}} \} & \fresh{\overline{\alpha_i}}\\
    \translate{\lambda x.t} & \coloneq & \mathbf{cocase}\ \{ \mathtt{ap}(x;\alpha) \Rightarrow \cut{\translate{t}}{\alpha}\} & \fresh{\alpha}\\
    \translate{t_1\ t_2} & \coloneq & \mu \alpha. \cut{\translate{t_1}}{\mathtt{ap}(\translate{t_2};\alpha)} & \fresh{\alpha}\\
    \translate{\mathbf{label}\ \alpha \{t\}} & \coloneq & \mu\alpha. \cut{\translate{t}}{\alpha} & \\
    \translate{\mathbf{goto}(t;\alpha)} & \coloneq & \mu\beta.\cut{\translate{t}}{\alpha} & \fresh{\beta}
  \end{array}
\]

%%
%% Section: New Translation
%%
\section{New Translation}
\label{sec:new-translation}

\[
  \begin{array}{rcll}
    \multicolumn{4}{c}{\translate{\cdot}^* : \emph{Term} \rightarrow  \emph{Producer}}\\
    \translate{t}^* & \coloneqq & \mu \alpha. \translate{t}_{\alpha} & \fresh{\alpha}\\
    \\
    \multicolumn{4}{c}{\translate{\cdot}_{\cdot}^* : \emph{Term}\times \emph{Consumer} \rightarrow \emph{Statement}}\\
    \translatestar{x}{c} & \coloneq & \cut{x}{c} & \\
    \translate{\lit{n}}_{c}^* & \coloneq & \cut{\lit{n}}{c} & \\
    \translatestar{\odot(t_1,t_2)}{c} & \coloneq & \odot(\translate{t_1}^*,\translate{t_2}^*;c) & \\
    \translatestar{\mathbf{ifz}(t_1,t_2,t_2)}{c} & \coloneq & \mathbf{ifz}(\translate{t_1}^*,\translatestar{t_2}{c},\translatestar{t_3}{c}) & \\
    \translatestar{\letin{x}{t_1}{t_2}}{c} & \coloneq & \translatestar{t_1}{\tilde{\mu}x.\translatestar{t_2}{c}} & \\
    \translatestar{f(\overline{t_i};\overline{\alpha_j})}{c} & \coloneq & f(\overline{\translate{t_i}^*};\overline{\alpha_j},c) & \\
    \translatestar{K(\overline{t_i})}{c} & \coloneq & \cut{K(\overline{\translate{t_i}^*})}{c} & \\
    \translatestar{\caseof{t}{\overline{K_i(\overline{x_{i,j}})\Rightarrow t_i}}}{c} & \coloneq & \translatestar{t}{\mathbf{case}\{ \overline{K_i(\overline{x_{i,j}})\Rightarrow \translatestar{t_i}{c}}\}} & \\
    \translatestar{t.D(\overline{t_i})}{c} & \coloneq & \translatestar{t}{D(\overline{\translate{t_i}^*};c)} & \\
    \translatestar{\mathbf{cocase}\ \{\overline{D_i(\overline{x_{i,j}}) \Rightarrow t_i}\}}{c} & \coloneq & \cut{\mathbf{cocase}\{\overline{D_i(\overline{x_{i,j}};\alpha_i)\Rightarrow \translatestar{t_i}{\alpha_i}}\}}{c} & \fresh{\overline{\alpha_i}} \\
    \translatestar{\lambda x.t}{c} & \coloneq & \cut{\mathbf{cocase}\ \{ \mathtt{ap}(x;\alpha) \Rightarrow \translatestar{t}{\beta} \}}{c} & \fresh{\alpha} \\
    \translatestar{t_1\ t_2}{c} & \coloneq & \translatestar{t_1}{\mathtt{ap}(\translate{t_2}^*;c)} & \\
    \translatestar{\mathbf{label}\ \alpha\ \{t\}}{c} & \coloneq & \cut{\mu \alpha.\translatestar{t}{\alpha}}{c} & \\
    \translatestar{\mathbf{goto}(t;\alpha)}{c} & \coloneq & \translatestar{t}{\alpha} & \\
    \\
    \multicolumn{4}{c}{\translate{\cdot}^* : \emph{Definition} \rightarrow \emph{Definition}}\\
    \translate{\mathbf{def}\ f(\overline{x};\overline{\alpha}) \coloneq t}^* & \coloneq & \mathbf{def}f(\overline{x};\overline{\alpha},\alpha) \coloneq \translatestar{t}{\alpha} & \fresh{\alpha}
  \end{array}
\]

%%
%% Section Properties
%%
\section{Properties}
\label{sec:Properties}

\begin{theorem} (Correctness)
  Let $t$ be a Term in $\mathtt{Fun}$. Then there are a finite number of reduction steps (where reduction here also means reduction under binders) such that $\focus{\translate{t}} \reducesto^{\ast} \focus{\translate{t}^*}$, where $\focus{\cdot}$ is the focusing translation.
\end{theorem}
\end{document}
