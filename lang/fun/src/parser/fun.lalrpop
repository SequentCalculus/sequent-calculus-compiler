use crate::syntax::*;
use crate::syntax::terms::*;
use crate::syntax::declarations::*;
use std::rc::Rc;
use std::str::FromStr;

#[LALR]
grammar;


// Tokens
match {
    // Symbols
    "(", ")", "{", "}", "[", "]", ";", ":=", "=>", ",", ":", ".",
    "->", "\\", "=", "@",
    // Constructors
    "Nil", "Cons", "Tup",
    // Destructors
    "hd", "tl", "fst", "snd", "ap",
    // BinOps
    "+", "*", "-",
    // Names
    r"[a-z][a-zA-Z0-9_]*",
    // Literals
    r"0|[1-9][0-9]*",
    // Keywords
    "label", "goto",
    "ifz", "let", "in",
    "case", "of", "cocase",
    "def",
    // Comments and whitespace
    r"\s*" => { }, // Skip whitespace
    r"//(([^ \n\r]| [^\|\n\r])[^\n\r]*)?[\n\r]*" => { }, // Skip `//` comments
}
// Helper rules

Comma<Rule>: Vec<Rule> =
    <rules: (<Rule> ",")*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };

Parens<Rule>: Rule =
    "(" <rule: Rule> ")" => rule;

Braces<Rule>: Rule =
    "{" <rule: Rule> "}" => rule;

Brackets<Rule>: Rule =
    "[" <rule: Rule> "]" => rule;

ParenthesizedArgs<Rule>: Vec<Rule> = Parens<Comma<Rule>>;
OptParenthesizedArgs<Rule>: Vec<Rule> = <args: Parens<Comma<Rule>>?> => args.unwrap_or_default();

BracedArgs<Rule>: Vec<Rule> = Braces<Comma<Rule>>;
OptBracedArgs<Rule>: Vec<Rule> = <args: Braces<Comma<Rule>>?> => args.unwrap_or_default();

BracketedArgs<Rule>: Vec<Rule> = Brackets<Comma<Rule>>;
OptBracketedArgs<Rule>: Vec<Rule> = <args: Brackets<Comma<Rule>>?> => args.unwrap_or_default();

// Constructors and destructors
//
//

Ctor: Ctor = {
    "Nil" => Ctor::Nil,
    "Cons" => Ctor::Cons,
    "Tup" => Ctor::Tup,
}

Dtor: Dtor = {
    "hd" => Dtor::Hd,
    "tl" => Dtor::Tl,
    "fst" => Dtor::Fst,
    "snd" => Dtor::Snd,
    "ap" => Dtor::Ap,
}

BinOp: BinOp = {
    "+" => BinOp::Sum,
    "-" => BinOp::Sub,
    "*" => BinOp::Prod,
}

// Constituent parts of terms
//
//


Var: String = {
    // TODO: Think of regexp for vars :)
    <s: r"[a-z][a-zA-Z0-9_]*"> => s.to_string()
}

Args: (Vec<Term>, Vec<String>) = {
    <args: Comma<Term>> ";" <coargs: Comma<Var>> => (args, coargs)
}
Call: Term = {
    <v: Var><args: Parens<Args>> =>  Fun { name: v, args: args.0, coargs: args.1 }.into(),
}

Label: Label = {
    "label" <label: Var> "{" <term: Term> "}" => Label { label, term: Rc::new(term) }
}

Goto: Goto = {
    "goto" "(" <term: Term> ";" <target: Var> ")" => Goto { term: Rc::new(term), target },
}

IfZ: IfZ = {
    "ifz" "(" <ifc: Term> "," <thenc: Term> "," <elsec: Term> ")" => IfZ { ifc: Rc::new(ifc), thenc: Rc::new(thenc), elsec: Rc::new(elsec) }
}

Let: Let = {
    "let" <variable: Var> "=" <t1: Term> "in" <t2: Term> => Let { variable, bound_term: Rc::new(t1), in_term: Rc::new(t2)},
}

ConstructorWithArgs: Constructor = {
    <id: Ctor> <args: ParenthesizedArgs<Term>> => Constructor { id, args }
}

ConstructorNoArgs: Constructor = {
    <id: Ctor> => Constructor { id, args: vec![] }
}

Destructor: Destructor = {
    <e: Term3> "." <d: Dtor> <args: OptParenthesizedArgs<Term>> => Destructor { id: d, destructee: Rc::new(e), args }
}

CtorClause: Clause<Ctor> = {
    <c: Ctor> <vars: OptParenthesizedArgs<Var>> "=>" <e: Term> => Clause { xtor: c, vars, rhs: e }
}

DtorClause: Clause<Dtor> = {
    <d: Dtor> <vars: OptParenthesizedArgs<Var>> "=>" <e: Term> => Clause { xtor: d, vars, rhs: e }
}

Case: Case = {
    "case" <e: Term> "of" "{" <cases: Comma<CtorClause>> "}" => Case { destructee: Rc::new(e), cases }
}

Cocase: Cocase = {
    "cocase" "{" <cocases: Comma<DtorClause>> "}" => Cocase { cocases }
}

Num: i64 = {
    <s: r"0|[1-9][0-9]*"> => i64::from_str(s).unwrap()
}

Op: Op = {
    <fst: Term1> <op: BinOp> <snd: Term1> => Op { fst: Rc::new(fst), op, snd: Rc::new(snd) }
}

// Terms
//
//

Term0: Term = {
  "(" <t: Term> ")" => Paren { inner: Rc::new(t) }.into(),
}

Term1: Term = {
    <n: Num> => Term::Lit(n),
    <v: Var> => Term::Var(v).into(),
    <l: Label> => l.into(),
    <g: Goto> => g.into(),
    <c: Case> => c.into(),
    <c: Cocase> => c.into(),
    <i: IfZ> => i.into(),
    <c: ConstructorNoArgs> => c.into(),
    Term0,
}

Term2: Term = {
    <o: Op> => o.into(),
    Term1
}

Term3: Term = {
    <d: Destructor> => d.into(),
    Term2,
}

Term6: Term = {
    <l: Let> => l.into(),
    Term3,
}
pub Term: Term = {
    <c: ConstructorWithArgs> => c.into(),
    <c: Call> => c.into(),
    Term6
}

// Toplevel Declarations and programs
//
//

Def: Def<()> = {
    "def" <v: Var> "(" <args: Comma<Var>> ";" <cont: Comma<Var>> ")" ":=" <body: Term> ";" =>
    Def { name: v,
          args: args.iter().map(|v| (v.clone(),())).collect(),
          cont: cont.iter().map(|v| (v.clone(),())).collect(),
          body,
          ret_ty: ()
    }
}

pub Prog: Prog<()> = {
    <defs: Def*> => Prog { prog_defs: defs }
}
