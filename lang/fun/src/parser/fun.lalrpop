use crate::syntax::*;
use crate::syntax::terms::*;
use crate::syntax::declarations::*;
use crate::syntax::context::*;
use crate::syntax::substitution::*;
use crate::syntax::types::*;
use std::rc::Rc;
use std::str::FromStr;
use super::util::span;

#[LALR]
grammar;


// Tokens
match {
    // Symbols
    "(", ")", "{", "}", "[", "]", ";", ":=", "=>", ",", ":", ":cnt", ".",
    "->", "\\", "=", "@",
    // BinOps
    "+", "*", "-",
    // Names
    r"[a-z][a-zA-Z0-9_]*",
    r"'[a-z][a-zA-Z0-9_]*",
    r"[A-Z][a-zA-Z0-9_]*",
    // Literals
    r"0|[1-9][0-9]*",
    // Keywords
    "label", "goto",
    "ifz", "let", "in",
    "case", "of", "cocase",
    "def","data","codata","Int",
    // Comments and whitespace
    r"\s*" => { }, // Skip whitespace
    r"//(([^ \n\r]| [^\|\n\r])[^\n\r]*)?[\n\r]*" => { }, // Skip `//` comments
}
// Helper rules

Comma<Rule>: Vec<Rule> =
    <rules: (<Rule> ",")*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };

Parens<Rule>: Rule =
    "(" <rule: Rule> ")" => rule;

Braces<Rule>: Rule =
    "{" <rule: Rule> "}" => rule;

Brackets<Rule>: Rule =
    "[" <rule: Rule> "]" => rule;

ParenthesizedArgs<Rule>: Vec<Rule> = Parens<Comma<Rule>>;
OptParenthesizedArgs<Rule>: Vec<Rule> = <args: Parens<Comma<Rule>>?> => args.unwrap_or_default();

BracedArgs<Rule>: Vec<Rule> = Braces<Comma<Rule>>;
OptBracedArgs<Rule>: Vec<Rule> = <args: Braces<Comma<Rule>>?> => args.unwrap_or_default();

BracketedArgs<Rule>: Vec<Rule> = Brackets<Comma<Rule>>;
OptBracketedArgs<Rule>: Vec<Rule> = <args: Brackets<Comma<Rule>>?> => args.unwrap_or_default();

//Binary Operations
BinOp: BinOp = {
    "+" => BinOp::Sum,
    "-" => BinOp::Sub,
    "*" => BinOp::Prod,
}

// Constituent parts of terms
//
//

Lit: Lit = {
    <l: @L> <n: Num> <r: @R> => Lit { span: span(l,r), val: n },
}

Variable: String = {
    <s: r"[a-z][a-zA-Z0-9_]*"> => s.to_string()
}

Var: Var = {
    <l: @L> <var: Variable> <r: @R> => Var { span: span(l,r), var }
}

Covar : String = {
    <s: r"'[a-z][a-zA-Z0-9_]*"> => s[1..s.len()].to_string()

}

XtorName : String = {
    <s: r"[A-Z][a-zA-Z0-9_]*"> => s.to_string()
}

// Substitutions
//
//
SubstTerm : SubstitutionBinding = {
    <t:Term> => t.into()
}
SubstCovar : SubstitutionBinding = {
    <cv:Covar> => SubstitutionBinding::CovarBinding{covar:cv,ty:None}
}
SubstBind : SubstitutionBinding = { <t:SubstTerm> => t, <cv:SubstCovar> => cv}

Substitution: Substitution = {
    <binds : Comma<SubstBind>> => binds
}
OptSubst : Substitution = { <args: Parens<Substitution>?> => args.unwrap_or_default() }


Call: Term = {
    <l: @L> <v: Variable><args: Parens<Substitution>> <r: @R> =>
      Fun { span: span(l,r), name: v, args }.into(),
}

Label: Label = {
    <l: @L> "label" <label: Covar> "{" <term: Term> "}" <r: @R> =>
      Label { span: span(l,r), label, term: Rc::new(term) }
}

Goto: Goto = {
    <l: @L> "goto" "(" <term: Term> ";" <target: Covar> ")" <r: @R> =>
      Goto { span: span(l,r), term: Rc::new(term), target },
}

IfZ: IfZ = {
    <l: @L> "ifz" "(" <ifc: Term> "," <thenc: Term> "," <elsec: Term> ")" <r: @R> =>
      IfZ { span: span(l,r), ifc: Rc::new(ifc), thenc: Rc::new(thenc), elsec: Rc::new(elsec) }
}

Let: Let = {
    <l: @L> "let" <variable: Variable> ":" <ty:Ty> "=" <t1: Term> "in" <t2: Term> <r: @R> =>
      Let { span: span(l,r), variable, var_ty:ty, bound_term: Rc::new(t1), in_term: Rc::new(t2)},
}

ConstructorWithArgs: Constructor = {
    <l: @L> <id: XtorName> <args: Parens<Substitution>> <r: @R> =>
      Constructor { span: span(l,r), id, args }
}

ConstructorNoArgs: Constructor = {
    <l: @L> <id: XtorName> <r: @R> =>
      Constructor { span: span(l,r), id, args: vec![] }
}

Destructor: Destructor = {
    <l: @L> <e: Term3> "." <id: XtorName> <args: OptSubst> <r: @R> =>
      Destructor { span: span(l,r), id, destructee: Rc::new(e), args }
}

Clause: Clause<Name> = {
    <l: @L> <xtor: XtorName> <context: Parens<Context>> "=>" <rhs: Term> <r: @R> => Clause { span: span(l,r), xtor, context, rhs },
    <l: @L> <xtor: XtorName> "=>" <rhs: Term> <r: @R> => Clause { span: span(l,r), xtor, context:vec![], rhs}
}

Case: Case = {
    <l: @L> <e: Term3>  "." "case" "{" <cases: Comma<Clause>> "}" <r: @R> =>
      Case { span: span(l,r), destructee: Rc::new(e), cases }
}

Cocase: Cocase = {
    <l: @L> "cocase" "{" <cocases: Comma<Clause>> "}" <r: @R> =>
      Cocase { span: span(l,r), cocases }
}

Num: i64 = {
    <s: r"0|[1-9][0-9]*"> => i64::from_str(s).unwrap()
}

Op: Op = {
    <l: @L> <fst: Term1> <op: BinOp> <snd: Term1> <r: @R> =>
      Op { span: span(l,r), fst: Rc::new(fst), op, snd: Rc::new(snd) }
}

// Contexts
//
//
ContextVar : ContextBinding = { <var: Variable> ":" <ty:Ty> => ContextBinding::TypedVar{var,ty} }
ContextCovar: ContextBinding = { <covar: Covar> ":cnt" <ty:Ty> => ContextBinding::TypedCovar{covar,ty} }
Binding: ContextBinding = { <covar : ContextCovar> => covar, <var:ContextVar> => var }
pub Context : TypingContext = { <bindings : Comma<Binding>> => bindings}

// Types
//
//
Int : Ty = {
    <l: @L> "Int" <r: @R>  => Ty::Int { span: span(l,r) }
}
TyDecl: Ty = {
    <l: @L> <s: r"[A-Z][a-zA-Z0-9_]*"> <r: @R> => Ty::Decl { span: span(l,r), name: s.to_string() }
}

pub Ty : Ty = {
    <i:Int> => i,
    <d:TyDecl> => d
}

// Terms
//
//

Term0: Term = {
  <l: @L> "(" <t: Term> ")" <r: @R> =>
    Paren { span: span(l,r), inner: Rc::new(t) }.into(),
}

Term1: Term = {
    <l: Lit> => l.into(),
    <v: Var> => v.into(),
    <l: Label> => l.into(),
    <g: Goto> => g.into(),
    <c: Cocase> => c.into(),
    <i: IfZ> => i.into(),
    <c: ConstructorNoArgs> => c.into(),
    Term0,
}

Term2: Term = {
    <o: Op> => o.into(),
    Term1
}

Term3: Term = {
    <d: Destructor> => d.into(),
    <c: Case> => c.into(),
    Term2,
}

Term6: Term = {
    <l: Let> => l.into(),
    Term3,
}
pub Term: Term = {
    <c: ConstructorWithArgs> => c.into(),
    <c: Call> => c.into(),
    Term6
}

// Toplevel Declarations and programs
//
//

Ctor: CtorSig = {
    <l: @L> <name: XtorName> <args: OptParenthesizedArgs<Binding>> <r: @R> =>
        CtorSig{
            span: span(l,r),
            name,
            args,
        }
}
Dtor:DtorSig = {
    <l: @L> <name: XtorName> <args: OptParenthesizedArgs<Binding>> ":" <cont_ty: Ty> <r: @R> =>
        DtorSig{
            span: span(l,r),
            name,
            args,
            cont_ty
        }
}

Def: Definition = {
    <l: @L> "def" <name: Variable> <context: OptParenthesizedArgs<Binding>> ":" <ret_ty:Ty> ":=" <body: Term> ";" <r: @R> =>
    Definition { span: span(l,r),
                 name,
                 context,
                 body,
                 ret_ty
               }
}

Data: DataDeclaration = {
    <l: @L> "data" <name: XtorName> "{" <ctors:Comma<Ctor>> "}" <r: @R> =>
        DataDeclaration {
            span: span(l,r),
            name,
            ctors

        }
}

Codata: CodataDeclaration = {
    <l: @L> "codata" <name: XtorName> "{" <dtors: Comma<Dtor>> "}" <r: @R> =>
        CodataDeclaration {
            span: span(l,r),
            name,
            dtors
        }
}

Decl : Declaration = {
    <def: Def> => def.into(),
    <data: Data> => data.into(),
    <codata:Codata> => codata.into()
}

pub Prog: Module = {
    <declarations: Decl*> => Module { declarations }
}
