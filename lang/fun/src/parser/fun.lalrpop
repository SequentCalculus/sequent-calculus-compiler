use crate::syntax::*;
use crate::syntax::terms::*;
use crate::syntax::declarations::*;
use crate::syntax::context::*;
use crate::syntax::substitution::*;
use crate::syntax::types::*;
use std::rc::Rc;
use std::str::FromStr;
use super::util::span;

#[LALR]
grammar;


// Tokens
match {
    // Symbols
    "(", ")", "{", "}", "[", "]", ";", "=>", ",", ":", ":cns", ".",
    "=", "==", "!=", "<", "<=", r"==\s*0", r"0\s*==", r"!=\s*0", r"0\s*!=",
    // BinOps/Negation
    "+", "*", "-", "/", "%",
    // Names
    r"[a-z][a-zA-Z0-9_]*",
    r"[A-Z][a-zA-Z0-9_]*",
    // Literals
    r"0|[1-9][0-9]*",
    // Keywords
    "label", "goto",
    "if", "else",
    "println_i64",
    "let", "case", "cocase",
    "def", "data", "codata",
    // Types
    "i64",
    // Comments and whitespace
    r"\s*" => { }, // Skip whitespace
    r"//(([^ \n\r]| [^\|\n\r])[^\n\r]*)?[\n\r]*" => { }, // Skip `//` comments
}

// Helper rules
Comma<Rule>: Vec<Rule> =
    <rules: (<Rule> ",")*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };

Parens<Rule>: Rule =
    "(" <rule: Rule> ")" => rule;

Braces<Rule>: Rule =
    "{" <rule: Rule> "}" => rule;

Brackets<Rule>: Rule =
    "[" <rule: Rule> "]" => rule;

ParenthesizedList<Rule>: Vec<Rule> = Parens<Comma<Rule>>;
OptParenthesizedList<Rule>: Vec<Rule> = <args: Parens<Comma<Rule>>?> => args.unwrap_or_default();

BracedList<Rule>: Vec<Rule> = Braces<Comma<Rule>>;
OptBracedList<Rule>: Vec<Rule> = <args: Braces<Comma<Rule>>?> => args.unwrap_or_default();

BracketedList<Rule>: Vec<Rule> = Brackets<Comma<Rule>>;
OptBracketedList<Rule>: Vec<Rule> = <args: Brackets<Comma<Rule>>?> => args.unwrap_or_default();

// Binary Operations
BinOp: BinOp = {
    "+" => BinOp::Sum,
    "-" => BinOp::Sub,
    "*" => BinOp::Prod,
    "/" => BinOp::Div,
    "%" => BinOp::Rem,
}

// Contexts
//
//

Name: String = {
    <s: r"[a-z][a-zA-Z0-9_]*"> => s.to_string(),
}

ContextVar: ContextBinding = {
    <var: Name> ":" <ty: Ty> => ContextBinding::TypedVar { var, ty, },
}

ContextCovar: ContextBinding = {
    <covar: Name> ":cns" <ty: Ty> => ContextBinding::TypedCovar { covar, ty, },
}

Binding: ContextBinding = {
    <covar: ContextCovar> => covar, <var:ContextVar> => var,
}

pub OptContext: TypingContext = {
    <l: @L> <bindings: OptParenthesizedList<Binding>> <r: @R> => TypingContext { span: span(l, r), bindings, },
}

// Types
//
//

I64: Ty = {
    <l: @L> "i64" <r: @R> => Ty::I64 { span: span(l, r), },
}

TypeName: String = {
    <s: r"[A-Z][a-zA-Z0-9_]*"> => s.to_string(),
}

OptTypeArgs: TypeArgs = {
    <l: @L> <args: OptBracketedList<Ty>> <r: @R> => TypeArgs { span: span(l, r), args, },
}

TyDecl: Ty = {
    <l: @L> <name: TypeName> <type_args: OptTypeArgs> <r: @R> =>
        Ty::Decl { span: span(l, r), name, type_args },
}

pub Ty: Ty = {
    <i: I64> => i,
    <d: TyDecl> => d,
}

// Constituent parts of terms
//
//

Num: i64 = {
    <s: r"0|[1-9][0-9]*"> => i64::from_str(s).unwrap(),
}

XVar: XVar = {
    <l: @L> <var: Name> <r: @R> => XVar { span: span(l, r), var, ty: None, chi: None, },
}

XtorName: String = {
    <s: r"[A-Z][a-zA-Z0-9_]*"> => s.to_string(),
}

// Substitutions
//
//

Substitution: Substitution = {
    <args: ParenthesizedList<Term>> => args,
}

OptSubst: Substitution = {
    <args: OptParenthesizedList<Term>> => args,
}

// Terms
//
//

Lit: Lit = {
    <l: @L> <n: Num> <r: @R> => Lit { span: span(l, r), val: n, },
    <l: @L> "-" <n: Num> <r: @R> => Lit { span: span(l, r), val: -n, },
}

Call: Term = {
    <l: @L> <v: Name> <args: Substitution> <r: @R> =>
      Fun { span: span(l, r), name: v, args, ret_ty: None, }.into(),
}

Label: Label = {
    <l: @L> "label" <label: Name> <term: Braces<Term>> <r: @R> =>
      Label { span: span(l, r), label, term: Rc::new(term), ty: None, },
}

Goto: Goto = {
    <l: @L> "goto" "(" <term: Term> ";" <target: Name> ")" <r: @R> =>
      Goto { span: span(l, r), term: Rc::new(term), target, ty: None, },
}

IfE: IfC = {
    <l: @L> "if" <fst: Term> "==" <snd: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::Equal, fst: Rc::new(fst), snd: Rc::new(snd), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfNE: IfC = {
    <l: @L> "if" <fst: Term> "!=" <snd: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::NotEqual, fst: Rc::new(fst), snd: Rc::new(snd), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfL: IfC = {
    <l: @L> "if" <fst: Term> "<" <snd: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::Less, fst: Rc::new(fst), snd: Rc::new(snd), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfLE: IfC = {
    <l: @L> "if" <fst: Term> "<=" <snd: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::LessOrEqual, fst: Rc::new(fst), snd: Rc::new(snd), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfZLeft: IfZ = {
    <l: @L> "if" <ifc: Term> r"==\s*0" <thenc: Braces<Term>> "else" <elsec: Braces<Term>>  <r: @R> =>
      IfZ { span: span(l, r), sort: IfZSort::Equal, ifc: Rc::new(ifc), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfZRight: IfZ = {
    <l: @L> "if" r"0\s*==" <ifc: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>>  <r: @R> =>
      IfZ { span: span(l, r), sort: IfZSort::Equal, ifc: Rc::new(ifc), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfNZLeft: IfZ = {
    <l: @L> "if" <ifc: Term> r"!=\s*0" <thenc: Braces<Term>> "else" <elsec: Braces<Term>>  <r: @R> =>
      IfZ { span: span(l, r), sort: IfZSort::NotEqual, ifc: Rc::new(ifc), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfNZRight: IfZ = {
    <l: @L> "if" r"0\s*!=" <ifc: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>>  <r: @R> =>
      IfZ { span: span(l, r), sort: IfZSort::NotEqual, ifc: Rc::new(ifc), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

PrintLnI64: PrintLnI64 = {
    <l: @L> "println_i64" <arg: Parens<Term>> ";" <t: Term> <r: @R> =>
      PrintLnI64 { span: span(l, r), arg: Rc::new(arg), next: Rc::new(t), ty: None, },
}

Let: Let = {
    <l: @L> "let" <variable: Name> ":" <ty: Ty> "=" <t1: Term> ";" <t2: Term> <r: @R> =>
      Let { span: span(l, r), variable, var_ty: ty, bound_term: Rc::new(t1), in_term: Rc::new(t2), ty: None, },
}

Constructor: Constructor = {
    <l: @L> <id: XtorName> <args: OptSubst> <r: @R> =>
        Constructor { span: span(l, r), id, args, ty: None, },
}

Destructor: Destructor = {
    <l: @L> <e: Term2> "." <id: XtorName> <type_args: OptTypeArgs> <args: OptSubst> <r: @R> =>
        Destructor { span: span(l, r), id, destructee: Rc::new(e), type_args, args, ty: None, },
}

Clause: Clause = {
    <l: @L> <xtor: XtorName> <context: OptContext> "=>" <rhs: Term> <r: @R> =>
        Clause { span: span(l, r), is_clause: true, xtor, context, rhs, },
}

Case: Case = {
    <l: @L> <e: Term2>  "." "case" <type_args: OptTypeArgs> <cases: BracedList<Clause>> <r: @R> =>
        Case { span: span(l, r), destructee: Rc::new(e), type_args, cases, ty: None, },
}

Coclause: Clause = {
    <l: @L> <xtor: XtorName> <context: OptContext> "=>" <rhs: Term> <r: @R> =>
        Clause { span: span(l, r), is_clause: false, xtor, context, rhs, },
}

Cocase: Cocase = {
    <l: @L> "cocase" <cocases: BracedList<Coclause>> <r: @R> =>
        Cocase { span: span(l, r), cocases, ty: None, },
}

Op: Op = {
    <l: @L> <fst: Term1> <op: BinOp> <snd: Term1> <r: @R> =>
        Op { span: span(l, r), fst: Rc::new(fst), op, snd: Rc::new(snd), },
}


Term0: Term = {
  <l: @L> <t: Parens<Term>> <r: @R> =>
    Paren { span: span(l, r), inner: Rc::new(t), }.into(),
}

Term1: Term = {
    <l: Lit> => l.into(),
    <v: XVar> => v.into(),
    <l: Label> => l.into(),
    <g: Goto> => g.into(),
    <c: Cocase> => c.into(),
    <i: IfE> => i.into(),
    <i: IfNE> => i.into(),
    <i: IfL> => i.into(),
    <i: IfLE> => i.into(),
    <i: IfZLeft> => i.into(),
    <i: IfZRight> => i.into(),
    <i: IfNZLeft> => i.into(),
    <i: IfNZRight> => i.into(),
    <c: Constructor> => c.into(),
    <c: Call> => c.into(),
    Term0,
}

Term2: Term = {
    <d: Destructor> => d.into(),
    <c: Case> => c.into(),
    Term1,
}

pub Term: Term = {
    <o: Op> => o.into(),
    <l: Let> => l.into(),
    <p: PrintLnI64> => p.into(),
    Term2,
}

// Top-level declarations and programs
//
//

Ctor: CtorSig = {
    <l: @L> <name: XtorName> <lc: @L> <args: OptContext> <r: @R> =>
        CtorSig{
            span: span(l, r),
            name,
            args,
        }
}

Dtor: DtorSig = {
    <l: @L> <name: XtorName> <lc: @L> <args: OptContext> <rc: @R> ":" <cont_ty: Ty> <r: @R> =>
        DtorSig{
            span: span(l, r),
            name,
            args,
            cont_ty,
        }
}

Def: Definition = {
    <l: @L> "def" <name: Name> <lc: @L> <context: OptContext> <rc: @R> ":" <ret_ty: Ty>  <body: Braces<Term>> <r: @R> =>
        Definition {
            span: span(l, r),
            name,
            context,
            body,
            ret_ty,
        }
}

pub OptTypeContext: TypeContext = {
    <l: @L> <bindings: OptBracketedList<TypeName>> <r: @R> => TypeContext { span: span(l, r), bindings, },
}

Data: DataDeclaration = {
    <l: @L> "data" <name: TypeName> <type_params: OptTypeContext> <ctors: BracedList<Ctor>> <r: @R> =>
        DataDeclaration {
            span: span(l, r),
            name,
            type_params,
            ctors,
        }
}

Codata: CodataDeclaration = {
    <l: @L> "codata" <name: TypeName> <type_params: OptTypeContext> <dtors: BracedList<Dtor>> <r: @R> =>
        CodataDeclaration {
            span: span(l, r),
            name,
            type_params,
            dtors,
        }
}

Decl: Declaration = {
    <def: Def> => def.into(),
    <data: Data> => data.into(),
    <codata: Codata> => codata.into()
}

pub Prog: Module = {
    <declarations: Decl*> => Module { declarations }
}
