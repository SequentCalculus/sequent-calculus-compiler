use crate::syntax::*;
use crate::syntax::terms::*;
use crate::syntax::declarations::*;
use crate::syntax::context::*;
use crate::syntax::substitution::*;
use crate::syntax::types::*;
use std::rc::Rc;
use std::str::FromStr;
use super::util::span;

#[LALR]
grammar;


// Tokens
match {
    // Symbols
    "(", ")", "{", "}", "[", "]", ";", ":=", "=>", ",", ":", ":cns", ".",
    "->", "\\", "=", "@",
    // BinOps/Negation
    "+", "*", "-", "/", "%",
    // Names
    r"[a-z][a-zA-Z0-9_]*",
    r"[A-Z][a-zA-Z0-9_]*",
    // Literals
    r"0|[1-9][0-9]*",
    // Keywords
    "label", "goto",
    "ife", "ifl", "ifz",
    "let", "in",
    "case", "of", "cocase",
    "def", "data", "codata",
    // Types
    "i64",
    // Comments and whitespace
    r"\s*" => { }, // Skip whitespace
    r"//(([^ \n\r]| [^\|\n\r])[^\n\r]*)?[\n\r]*" => { }, // Skip `//` comments
}

// Helper rules
Comma<Rule>: Vec<Rule> =
    <rules: (<Rule> ",")*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };

Parens<Rule>: Rule =
    "(" <rule: Rule> ")" => rule;

Braces<Rule>: Rule =
    "{" <rule: Rule> "}" => rule;

Brackets<Rule>: Rule =
    "[" <rule: Rule> "]" => rule;

ParenthesizedArgs<Rule>: Vec<Rule> = Parens<Comma<Rule>>;
OptParenthesizedArgs<Rule>: Vec<Rule> = <args: Parens<Comma<Rule>>?> => args.unwrap_or_default();

BracedArgs<Rule>: Vec<Rule> = Braces<Comma<Rule>>;
OptBracedArgs<Rule>: Vec<Rule> = <args: Braces<Comma<Rule>>?> => args.unwrap_or_default();

BracketedArgs<Rule>: Vec<Rule> = Brackets<Comma<Rule>>;
OptBracketedArgs<Rule>: Vec<Rule> = <args: Brackets<Comma<Rule>>?> => args.unwrap_or_default();

// Binary Operations
BinOp: BinOp = {
    "+" => BinOp::Sum,
    "-" => BinOp::Sub,
    "*" => BinOp::Prod,
    "/" => BinOp::Div,
    "%" => BinOp::Rem,
}

// Constituent parts of terms
//
//

Lit: Lit = {
    <l: @L> <n: Num> <r: @R> => Lit { span: span(l, r), val: n, },
    <l: @L> "-" <n: Num> <r: @R> => Lit { span: span(l, r), val: -n, },
}

Name: String = {
    <s: r"[a-z][a-zA-Z0-9_]*"> => s.to_string(),
}

XVar: XVar = {
    <l: @L> <var: Name> <r: @R> => XVar { span: span(l, r), var, ty: None, chi: None, },
}

XtorName: String = {
    <s: r"[A-Z][a-zA-Z0-9_]*"> => s.to_string(),
}

// Substitutions
//
//

Substitution: Substitution = {
    <binds: Comma<Term>> => binds,
}

OptSubst: Substitution = {
    <args: Parens<Substitution>?> => args.unwrap_or_default(),
}


Call: Term = {
    <l: @L> <v: Name><args: Parens<Substitution>> <r: @R> =>
      Fun { span: span(l, r), name: v, args, ret_ty: None, }.into(),
}

Label: Label = {
    <l: @L> "label" <label: Name> "{" <term: Term> "}" <r: @R> =>
      Label { span: span(l, r), label, term: Rc::new(term), ty: None, },
}

Goto: Goto = {
    <l: @L> "goto" "(" <term: Term> ";" <target: Name> ")" <r: @R> =>
      Goto { span: span(l, r), term: Rc::new(term), target, ty: None, },
}

IfE: IfC = {
    <l: @L> "ife" "(" <fst: Term> "," <snd: Term> "," <thenc: Term> "," <elsec: Term> ")" <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::Equal, fst: Rc::new(fst), snd: Rc::new(snd), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfL: IfC = {
    <l: @L> "ifl" "(" <fst: Term> "," <snd: Term> "," <thenc: Term> "," <elsec: Term> ")" <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::Less, fst: Rc::new(fst), snd: Rc::new(snd), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfZ: IfZ = {
    <l: @L> "ifz" "(" <ifc: Term> "," <thenc: Term> "," <elsec: Term> ")" <r: @R> =>
      IfZ { span: span(l, r), ifc: Rc::new(ifc), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

Let: Let = {
    <l: @L> "let" <variable: Name> ":" <ty: Ty> "=" <t1: Term> "in" <t2: Term> <r: @R> =>
      Let { span: span(l, r), variable, var_ty: ty, bound_term: Rc::new(t1), in_term: Rc::new(t2), ty: None, },
}

ConstructorWithArgs: Constructor = {
    <l: @L> <id: XtorName> <args: Parens<Substitution>> <r: @R> =>
        Constructor { span: span(l, r), id, args, ty: None, },
}

ConstructorNoArgs: Constructor = {
    <l: @L> <id: XtorName> <r: @R> =>
        Constructor { span: span(l, r), id, args:  vec![], ty: None, },
}

Destructor: Destructor = {
    <l: @L> <e: Term2> "." <id: XtorName> <args: OptSubst> <r: @R> =>
        Destructor { span: span(l, r), id, destructee: Rc::new(e), args, ty: None, },
}

Clause: Clause = {
    <l: @L> <xtor: XtorName> <context: Parens<Context>> "=>" <rhs: Term> <r: @R> =>
        Clause { span: span(l, r), is_clause: true, xtor, context, rhs, },
    <l: @L> <xtor: XtorName> <lc: @L> <rc: @R> "=>" <rhs: Term> <r: @R> =>
        Clause { span: span(l, r), is_clause: true, xtor, context: TypingContext { span: span(lc, rc), bindings: vec![], }, rhs, },
}

Case: Case = {
    <l: @L> <e: Term2>  "." "case" "{" <cases: Comma<Clause>> "}" <r: @R> =>
        Case { span: span(l, r), destructee: Rc::new(e), cases, ty: None, },
}

Coclause: Clause = {
    <l: @L> <xtor: XtorName> <context: Parens<Context>> "=>" <rhs: Term> <r: @R> =>
        Clause { span: span(l, r), is_clause: false, xtor, context, rhs, },
    <l: @L> <xtor: XtorName> <lc: @L> <rc: @R> "=>" <rhs: Term> <r: @R> =>
        Clause { span: span(l, r), is_clause: false, xtor, context: TypingContext { span: span(lc, rc), bindings: vec![], }, rhs, },
}

Cocase: Cocase = {
    <l: @L> "cocase" "{" <cocases: Comma<Coclause>> "}" <r: @R> =>
        Cocase { span: span(l, r), cocases, ty: None, },
}

Num: i64 = {
    <s: r"0|[1-9][0-9]*"> => i64::from_str(s).unwrap(),
}

Op: Op = {
    <l: @L> <fst: Term1> <op: BinOp> <snd: Term1> <r: @R> =>
        Op { span: span(l, r), fst: Rc::new(fst), op, snd: Rc::new(snd), },
}

// Contexts
//
//

ContextVar: ContextBinding = {
    <var: Name> ":" <ty: Ty> => ContextBinding::TypedVar { var, ty, },
}

ContextCovar: ContextBinding = {
    <covar: Name> ":cns" <ty: Ty> => ContextBinding::TypedCovar { covar, ty, },
}

Binding: ContextBinding = {
    <covar: ContextCovar> => covar, <var:ContextVar> => var,
}

pub Context: TypingContext = {
    <l: @L> <bindings: Comma<Binding>> <r: @R> => TypingContext { span: span(l, r), bindings, },
}

// Types
//
//

I64: Ty = {
    <l: @L> "i64" <r: @R> => Ty::I64 { span: span(l, r), },
}

TyDecl: Ty = {
    <l: @L> <s: r"[A-Z][a-zA-Z0-9_]*"> <r: @R> =>
        Ty::Decl { span: span(l, r), name: s.to_string(), },
}

pub Ty: Ty = {
    <i: I64> => i,
    <d: TyDecl> => d,
}

// Terms
//
//

Term0: Term = {
  <l: @L> "(" <t: Term> ")" <r: @R> =>
    Paren { span: span(l, r), inner: Rc::new(t), }.into(),
}

Term1: Term = {
    <l: Lit> => l.into(),
    <v: XVar> => v.into(),
    <l: Label> => l.into(),
    <g: Goto> => g.into(),
    <c: Cocase> => c.into(),
    <i: IfE> => i.into(),
    <i: IfL> => i.into(),
    <i: IfZ> => i.into(),
    <c: ConstructorNoArgs> => c.into(),
    <c: ConstructorWithArgs> => c.into(),
    <c: Call> => c.into(),
    Term0,
}

Term2: Term = {
    <d: Destructor> => d.into(),
    <c: Case> => c.into(),
    Term1,
}

pub Term: Term = {
    <o: Op> => o.into(),
    <l: Let> => l.into(),
    Term2,
}

// Top-level declarations and programs
//
//

Ctor: CtorSig = {
    <l: @L> <name: XtorName> <lc: @L> <args: OptParenthesizedArgs<Binding>> <r: @R> =>
        CtorSig{
            span: span(l, r),
            name,
            args: TypingContext { span: span(lc, r), bindings: args, },
        }
}

Dtor: DtorSig = {
    <l: @L> <name: XtorName> <lc: @L> <args: OptParenthesizedArgs<Binding>> <rc: @R> ":" <cont_ty: Ty> <r: @R> =>
        DtorSig{
            span: span(l, r),
            name,
            args: TypingContext { span: span(lc, rc), bindings: args, },
            cont_ty,
        }
}

Def: Definition = {
    <l: @L> "def" <name: Name> <lc: @L> <context: OptParenthesizedArgs<Binding>> <rc: @R> ":" <ret_ty: Ty> ":=" <body: Term> ";" <r: @R> =>
        Definition {
            span: span(l, r),
            name,
            context: TypingContext { span: span(lc, rc), bindings: context, },
            body,
            ret_ty,
        }
}

Data: DataDeclaration = {
    <l: @L> "data" <name: XtorName> "{" <ctors: Comma<Ctor>> "}" <r: @R> =>
        DataDeclaration {
            span: span(l, r),
            name,
            ctors,
        }
}

Codata: CodataDeclaration = {
    <l: @L> "codata" <name: XtorName> "{" <dtors: Comma<Dtor>> "}" <r: @R> =>
        CodataDeclaration {
            span: span(l, r),
            name,
            dtors,
        }
}

Decl: Declaration = {
    <def: Def> => def.into(),
    <data: Data> => data.into(),
    <codata: Codata> => codata.into()
}

pub Prog: Module = {
    <declarations: Decl*> => Module { declarations }
}
