use crate::syntax::*;
use crate::syntax::context::*;
use crate::syntax::declarations::*;
use crate::syntax::names::*;
use crate::syntax::program::*;
use crate::syntax::substitution::*;
use crate::syntax::terms::*;
use crate::syntax::types::*;

use super::util::span;

use std::rc::Rc;
use std::str::FromStr;

#[LALR]
grammar;

//
// Tokens
//

match {
    // Symbols
    "(", ")", "{", "}", "[", "]", ";", "=>", ",", ":", r":\s*cns", ".",
    "=", "==", "!=", "<", "<=", ">", ">=",
    r"==\s*0", r"0\s*==", r"!=\s*0", r"0\s*!=", r"<\s*0", r"0\s*<", r"<=\s*0", r"0\s*<=", r">\s*0", r"0\s*>", r">=\s*0", r"0\s*>=",
    // BinOps/Negation
    "+", "*", "-", "/", "%",
    // Names
    r"[a-z][a-zA-Z0-9_]*",
    r"[A-Z][a-zA-Z0-9_]*",
    // Literals
    r"0|[1-9][0-9]*",
    // Keywords
    "label", "goto", "exit",
    "if", "else",
    "print_i64", "println_i64",
    "let", "case", "new",
    "def", "data", "codata",
    // Types
    "i64",
    // Comments and whitespace
    r"\s*" => { }, // Skip whitespace
    r"//(([^ \n\r]| [^\|\n\r])[^\n\r]*)?[\n\r]*" => { }, // Skip `//` comments
}

//
// Helper rules
//

Comma<Rule>: Vec<Rule> =
    <rules: (<Rule> ",")*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };

Parens<Rule>: Rule =
    "(" <rule: Rule> ")" => rule;

Braces<Rule>: Rule =
    "{" <rule: Rule> "}" => rule;

Brackets<Rule>: Rule =
    "[" <rule: Rule> "]" => rule;

ParenthesizedList<Rule>: Vec<Rule> = Parens<Comma<Rule>>;
OptParenthesizedList<Rule>: Vec<Rule> = <args: Parens<Comma<Rule>>?> => args.unwrap_or_default();

BracedList<Rule>: Vec<Rule> = Braces<Comma<Rule>>;
OptBracedList<Rule>: Vec<Rule> = <args: Braces<Comma<Rule>>?> => args.unwrap_or_default();

BracketedList<Rule>: Vec<Rule> = Brackets<Comma<Rule>>;
OptBracketedList<Rule>: Vec<Rule> = <args: Brackets<Comma<Rule>>?> => args.unwrap_or_default();

//
// Binary Operators
//

BinOp: BinOp = {
    "+" => BinOp::Sum,
    "-" => BinOp::Sub,
    "*" => BinOp::Prod,
    "/" => BinOp::Div,
    "%" => BinOp::Rem,
}

//
// Contexts
//

Name: String = {
    <s: r"[a-z][a-zA-Z0-9_]*"> => s.to_string(),
}

ContextVar: ContextBinding = {
    <var: Name> ":" <ty: Ty> => ContextBinding { var, chi: Chirality::Prd, ty, },
}

ContextCovar: ContextBinding = {
    <var: Name> r":\s*cns" <ty: Ty> => ContextBinding { var, chi: Chirality::Cns, ty, },
}

Binding: ContextBinding = {
    <covar: ContextCovar> => covar, <var: ContextVar> => var,
}

pub OptContext: TypingContext = {
    <l: @L> <bindings: OptParenthesizedList<Binding>> <r: @R> => TypingContext { span: span(l, r), bindings, },
}

pub OptNameContext: NameContext = {
    <l: @L> <bindings: OptParenthesizedList<Name>> <r: @R> => NameContext { span: span(l, r), bindings, },
}

//
// Types
//

I64: Ty = {
    <l: @L> "i64" <r: @R> => Ty::I64 { span: span(l, r), },
}

TypeName: String = {
    <s: r"[A-Z][a-zA-Z0-9_]*"> => s.to_string(),
}

OptTypeArgs: TypeArgs = {
    <l: @L> <args: OptBracketedList<Ty>> <r: @R> => TypeArgs { span: span(l, r), args, },
}

TyDecl: Ty = {
    <l: @L> <name: TypeName> <type_args: OptTypeArgs> <r: @R> =>
        Ty::Decl { span: span(l, r), name, type_args },
}

pub Ty: Ty = {
    <i: I64> => i,
    <d: TyDecl> => d,
}

//
// Constituent parts of terms
//

Num: i64 = {
    <s: r"0|[1-9][0-9]*"> => i64::from_str(s).unwrap(),
}

XVar: XVar = {
    <l: @L> <var: Name> <r: @R> => XVar { span: span(l, r), var, ty: None, chi: None, },
}

CtorName: String = {
    <s: r"[A-Z][a-zA-Z0-9_]*"> => s.to_string(),
}

DtorName: String = {
    <s: r"[a-z][a-zA-Z0-9_]*"> => s.to_string(),
}

//
// Substitutions
//

Substitution: Substitution = {
    <args: ParenthesizedList<Term>> => args.into(),
}

OptSubst: Substitution = {
    <args: OptParenthesizedList<Term>> => args.into(),
}

//
// Terms
//

Lit: Lit = {
    <l: @L> <n: Num> <r: @R> => Lit { span: span(l, r), lit: n, },
    <l: @L> "-" <n: Num> <r: @R> => Lit { span: span(l, r), lit: -n, },
}

Call: Term = {
    <l: @L> <v: Name> <args: Substitution> <r: @R> =>
      Call { span: span(l, r), name: v, args, ret_ty: None, }.into(),
}

Label: Label = {
    <l: @L> "label" <label: Name> <term: Braces<Term>> <r: @R> =>
      Label { span: span(l, r), label, term: Rc::new(term), ty: None, },
}

Goto: Goto = {
    <l: @L> "goto" <target: Name> <term: Parens<Term>> <r: @R> =>
      Goto { span: span(l, r), target, term: Rc::new(term), ty: None, },
}

Exit: Exit = {
    <l: @L> "exit" <arg: Term> <r: @R> =>
      Exit { span: span(l, r), arg: Rc::new(arg), ty: None, },
}

IfE: IfC = {
    <l: @L> "if" <fst: Term> "==" <snd: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::Equal, fst: Rc::new(fst), snd: Some(Rc::new(snd)), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfNE: IfC = {
    <l: @L> "if" <fst: Term> "!=" <snd: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::NotEqual, fst: Rc::new(fst), snd: Some(Rc::new(snd)), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfL: IfC = {
    <l: @L> "if" <fst: Term> "<" <snd: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::Less, fst: Rc::new(fst), snd: Some(Rc::new(snd)), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfLE: IfC = {
    <l: @L> "if" <fst: Term> "<=" <snd: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::LessOrEqual, fst: Rc::new(fst), snd: Some(Rc::new(snd)), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfG: IfC = {
    <l: @L> "if" <fst: Term> ">" <snd: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::Greater, fst: Rc::new(fst), snd: Some(Rc::new(snd)), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfGE: IfC = {
    <l: @L> "if" <fst: Term> ">=" <snd: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::GreaterOrEqual, fst: Rc::new(fst), snd: Some(Rc::new(snd)), thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfZLeft: IfC = {
    <l: @L> "if" <ifc: Term> r"==\s*0" <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::Equal, fst: Rc::new(ifc),snd: None, thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfZRight: IfC = {
    <l: @L> "if" r"0\s*==" <ifc: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::Equal, fst: Rc::new(ifc), snd: None, thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfNZLeft: IfC = {
    <l: @L> "if" <ifc: Term> r"!=\s*0" <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::NotEqual, fst: Rc::new(ifc), snd: None, thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfNZRight: IfC = {
    <l: @L> "if" r"0\s*!=" <ifc: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::NotEqual, fst: Rc::new(ifc), snd: None, thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfLZLeft: IfC = {
    <l: @L> "if" <ifc: Term> r"<\s*0" <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::Less, fst: Rc::new(ifc),snd: None, thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfLZRight: IfC = {
    <l: @L> "if" r"0\s*>" <ifc: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::Less, fst: Rc::new(ifc),snd: None, thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfLEZLeft: IfC = {
    <l: @L> "if" <ifc: Term> r"<=\s*0" <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::LessOrEqual, fst: Rc::new(ifc),snd: None, thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfLEZRight: IfC = {
    <l: @L> "if" r"0\s*>=" <ifc: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::LessOrEqual, fst: Rc::new(ifc),snd: None, thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfGZLeft: IfC = {
    <l: @L> "if" <ifc: Term> r">\s*0" <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::Greater, fst: Rc::new(ifc),snd: None, thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfGZRight: IfC = {
    <l: @L> "if" r"0\s*<" <ifc: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::Greater, fst: Rc::new(ifc),snd: None, thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfGEZLeft: IfC = {
    <l: @L> "if" <ifc: Term> r">=\s*0" <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::GreaterOrEqual, fst: Rc::new(ifc),snd: None, thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

IfGEZRight: IfC = {
    <l: @L> "if" r"0\s*<=" <ifc: Term> <thenc: Braces<Term>> "else" <elsec: Braces<Term>> <r: @R> =>
      IfC { span: span(l, r), sort: IfSort::GreaterOrEqual, fst: Rc::new(ifc),snd: None, thenc: Rc::new(thenc), elsec: Rc::new(elsec), ty: None, },
}

PrintI64: PrintI64 = {
    <l: @L> "print_i64" <arg: Parens<Term>> ";" <t: Term> <r: @R> =>
      PrintI64 { span: span(l, r), newline: false, arg: Rc::new(arg), next: Rc::new(t), ty: None, },
}

PrintLnI64: PrintI64 = {
    <l: @L> "println_i64" <arg: Parens<Term>> ";" <t: Term> <r: @R> =>
      PrintI64 { span: span(l, r), newline: true, arg: Rc::new(arg), next: Rc::new(t), ty: None, },
}

Let: Let = {
    <l: @L> "let" <variable: Name> ":" <ty: Ty> "=" <t1: Term3> ";" <t2: Term> <r: @R> =>
      Let { span: span(l, r), variable, var_ty: ty, bound_term: Rc::new(t1), in_term: Rc::new(t2), ty: None, },
}

Constructor: Constructor = {
    <l: @L> <id: CtorName> <args: OptSubst> <r: @R> =>
        Constructor { span: span(l, r), id, args, ty: None, },
}

Destructor: Destructor = {
    <l: @L> <e: Term2> "." <id: DtorName> <type_args: OptTypeArgs> <args: OptSubst> <r: @R> =>
        Destructor { span: span(l, r), id, scrutinee: Rc::new(e), type_args, args, ty: None, },
}

Clause: Clause = {
    <l: @L> <xtor: CtorName> <context_names: OptNameContext> "=>" <body: Term> <r: @R> =>
        Clause { span: span(l, r), pol: Polarity::Data, xtor, context_names, context: TypingContext::default(), body, },
}

Case: Case = {
    <l: @L> <e: Term2>  "." "case" <type_args: OptTypeArgs> <clauses: BracedList<Clause>> <r: @R> =>
        Case { span: span(l, r), scrutinee: Rc::new(e), type_args, clauses, ty: None, },
}

Coclause: Clause = {
    <l: @L> <xtor: DtorName> <context_names: OptNameContext> "=>" <body: Term> <r: @R> =>
        Clause { span: span(l, r), pol: Polarity::Codata, xtor, context_names, context: TypingContext::default(), body, },
}

New: New = {
    <l: @L> "new" <clauses: BracedList<Coclause>> <r: @R> =>
        New { span: span(l, r), clauses, ty: None, },
}

Op: Op = {
    <l: @L> <fst: Term1> <op: BinOp> <snd: Term1> <r: @R> =>
        Op { span: span(l, r), fst: Rc::new(fst), op, snd: Rc::new(snd), },
}


Term0: Term = {
  <l: @L> <t: Parens<Term>> <r: @R> =>
    Paren { span: span(l, r), inner: Rc::new(t), }.into(),
}

Term1: Term = {
    <l: Lit> => l.into(),
    <v: XVar> => v.into(),
    <c: Call> => c.into(),
    Term0,
}

Term2: Term = {
    <c: New> => c.into(),
    <c: Constructor> => c.into(),
    <d: Destructor> => d.into(),
    <c: Case> => c.into(),
    Term1,
}

pub Term3: Term = {
    <i: IfE> => i.into(),
    <i: IfNE> => i.into(),
    <i: IfL> => i.into(),
    <i: IfLE> => i.into(),
    <i: IfG> => i.into(),
    <i: IfGE> => i.into(),
    <i: IfZLeft> => i.into(),
    <i: IfZRight> => i.into(),
    <i: IfNZLeft> => i.into(),
    <i: IfNZRight> => i.into(),
    <i: IfLZLeft> => i.into(),
    <i: IfLZRight> => i.into(),
    <i: IfLEZLeft> => i.into(),
    <i: IfLEZRight> => i.into(),
    <i: IfGZLeft> => i.into(),
    <i: IfGZRight> => i.into(),
    <i: IfGEZLeft> => i.into(),
    <i: IfGEZRight> => i.into(),
    <l: Label> => l.into(),
    <g: Goto> => g.into(),
    <e: Exit> => e.into(),
    <o: Op> => o.into(),
    <l: Let> => l.into(),
    Term2,
}

pub Term: Term = {
    <p: PrintI64> => p.into(),
    <p: PrintLnI64> => p.into(),
    Term3,
}

//
// Top-level declarations and programs
//

Ctor: CtorSig = {
    <l: @L> <name: CtorName> <lc: @L> <args: OptContext> <r: @R> =>
        CtorSig{
            span: span(l, r),
            name,
            args,
        }
}

Dtor: DtorSig = {
    <l: @L> <name: DtorName> <lc: @L> <args: OptContext> <rc: @R> ":" <cont_ty: Ty> <r: @R> =>
        DtorSig{
            span: span(l, r),
            name,
            args,
            cont_ty,
        }
}

Def: Def = {
    <l: @L> "def" <name: Name> <lc: @L> <context: OptContext> <rc: @R> ":" <ret_ty: Ty>  <body: Braces<Term>> <r: @R> =>
        Def {
            span: span(l, r),
            name,
            context,
            body,
            ret_ty,
        }
}

pub OptTypeContext: TypeContext = {
    <l: @L> <bindings: OptBracketedList<TypeName>> <r: @R> => TypeContext { span: span(l, r), bindings, },
}

Data: Data = {
    <l: @L> "data" <name: TypeName> <type_params: OptTypeContext> <ctors: BracedList<Ctor>> <r: @R> =>
        Data {
            span: span(l, r),
            name,
            type_params,
            ctors,
        }
}

Codata: Codata = {
    <l: @L> "codata" <name: TypeName> <type_params: OptTypeContext> <dtors: BracedList<Dtor>> <r: @R> =>
        Codata {
            span: span(l, r),
            name,
            type_params,
            dtors,
        }
}

Declaration: Declaration = {
    <def: Def> => def.into(),
    <data: Data> => data.into(),
    <codata: Codata> => codata.into()
}

pub Prog: Program = {
    <declarations: Declaration*> => Program { declarations }
}
