use crate::syntax::*;
use crate::program::*;
use std::rc::Rc;
use std::str::FromStr;

#[LALR]
grammar;


// Tokens
match {
    // Symbols
    "(", ")", "{", "}", "[", "]", ";", ":=", "=>", ",", ":", ".",
    "->", "\\", "=",
    // Constructors
    "Nil", "Cons", "Tup",
    // Destructors
    "hd", "tl", "fst", "snd",
    // BinOps
    "+", "*", "-",
    // Names
    r"[a-z][a-zA-Z0-9_]*",
    // Literals
    r"0|[1-9][0-9]*",
    // Keywords
    "label", "goto",
    "ifz", "let", "in",
    "case", "of", "cocase",
    "def",
    // Comments and whitespace
    r"\s*" => { }, // Skip whitespace
    r"//(([^ \n\r]| [^\|\n\r])[^\n\r]*)?[\n\r]*" => { }, // Skip `//` comments
}
// Helper rules

Comma<Rule>: Vec<Rule> =
    <rules: (<Rule> ",")*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };

Parens<Rule>: Rule =
    "(" <rule: Rule> ")" => rule;

Braces<Rule>: Rule =
    "{" <rule: Rule> "}" => rule;

Brackets<Rule>: Rule =
    "[" <rule: Rule> "]" => rule;

ParenthesizedArgs<Rule>: Vec<Rule> = Parens<Comma<Rule>>;
OptParenthesizedArgs<Rule>: Vec<Rule> = <args: Parens<Comma<Rule>>?> => args.unwrap_or_default();

BracedArgs<Rule>: Vec<Rule> = Braces<Comma<Rule>>;
OptBracedArgs<Rule>: Vec<Rule> = <args: Braces<Comma<Rule>>?> => args.unwrap_or_default();

BracketedArgs<Rule>: Vec<Rule> = Brackets<Comma<Rule>>;
OptBracketedArgs<Rule>: Vec<Rule> = <args: Brackets<Comma<Rule>>?> => args.unwrap_or_default();

// Constructors and destructors
//
//

Ctor: Ctor = {
    "Nil" => Ctor::Nil,
    "Cons" => Ctor::Cons,
    "Tup" => Ctor::Tup,
}

Dtor: Dtor = {
    "hd" => Dtor::Hd,
    "tl" => Dtor::Tl,
    "fst" => Dtor::Fst,
    "snd" => Dtor::Snd,
}

BinOp: BinOp = {
    "+" => BinOp::Sum,
    "-" => BinOp::Sub,
    "*" => BinOp::Prod,
}

// Constituent parts of terms
//
//


Var: String = {
    // TODO: Think of regexp for vars :)
    <s: r"[a-z][a-zA-Z0-9_]*"> => s.to_string()
}

Args: (Vec<Term>, Vec<String>) = {
    <args: Comma<Term>> ";" <coargs: Comma<Var>> => (args, coargs)
}
Call: Term = {
    <v: Var><args: Parens<Args>?> => {
        match args {
            None => Term::Var(v).into(),
            Some(args) => Fun { name: v, args: args.0, coargs: args.1 }.into(),
        }
    }
}

Label: Label = {
    "label" <label: Var> "{" <term: Term> "}" => Label { label, term: Rc::new(term) }
}

Goto: Goto = {
    "goto" "(" <term: Term> ";" <target: Var> ")" => Goto { term: Rc::new(term), target },
}

IfZ: IfZ = {
    "ifz" "(" <ifc: Term> "," <thenc: Term> "," <elsec: Term> ")" => IfZ { ifc: Rc::new(ifc), thenc: Rc::new(thenc), elsec: Rc::new(elsec) }
}

Let: Let = {
    "let" <variable: Var> "=" <t1: Term> "in" <t2: Term> => Let { variable, bound_term: Rc::new(t1), in_term: Rc::new(t2)},
}

Lam: Lam = {
    "\\" <variable: Var> "=>" <t: Term> => Lam { variable, body: Rc::new(t)},
}

App: App = {
    <function: Term4> <argument: Term3> => App { function: Rc::new(function), argument: Rc::new(argument) }
}

Constructor: Constructor = {
    <id: Ctor> <args: OptParenthesizedArgs<Term>> => Constructor { id, args }
}

Destructor: Destructor = {
    <e: Term3> "." <d: Dtor> => Destructor { id: d, destructee: Rc::new(e), args: vec![] }
}

CtorClause: Clause<Ctor> = {
    <c: Ctor> <vars: OptParenthesizedArgs<Var>> "=>" <e: Term> => Clause { xtor: c, vars, rhs: e }
}

DtorClause: Clause<Dtor> = {
    <d: Dtor> <vars: OptParenthesizedArgs<Var>> "=>" <e: Term> => Clause { xtor: d, vars, rhs: e }
}

Case: Case = {
    "case" <e: Term> "of" "{" <cases: Comma<CtorClause>> "}" => Case { destructee: Rc::new(e), cases }
}

Cocase: Cocase = {
    "cocase" "{" <cocases: Comma<DtorClause>> "}" => Cocase { cocases }
}

Num: i64 = {
    <s: r"0|[1-9][0-9]*"> => i64::from_str(s).unwrap()
}

Op: Op = {
    <fst: Term1> <op: BinOp> <snd: Term1> => Op { fst: Rc::new(fst), op, snd: Rc::new(snd) }
}

// Terms
//
//

Term1: Term = {
    <n: Num> => Term::Lit(n),
    <c: Call> => c,
    <l: Label> => l.into(),
    <g: Goto> => g.into(),
    <c: Case> => c.into(),
    <c: Cocase> => c.into(),
    <i: IfZ> => i.into(),
    <c: Constructor> => c.into(),
}

Term2: Term = {
    <o: Op> => o.into(),
    Term1
}

Term3: Term = {
    <d: Destructor> => d.into(),
    Term2,
}

Term4: Term = {
    "(" <t: Term> ")" => Paren { inner: Rc::new(t) }.into(),
    <a: App> => a.into(),
    Term3,
}

Term5: Term = {
    <l: Lam> => l.into(),
    Term4,
}

Term6: Term = {
    <l: Let> => l.into(),
    Term5,
}
pub Term: Term = {
    
    Term6
}

// Toplevel Declarations and programs
//
//

Def: Def<()> = {
    "def" <v: Var> "(" <args: Comma<Var>> ";" <cont: Comma<Var>> ")" ":=" <body: Term> ";" =>
    Def { name: v,
          args: args.iter().map(|v| (v.clone(),())).collect(),
          cont: cont.iter().map(|v| (v.clone(),())).collect(),
          body,
          ret_ty: ()
    }
}

pub Prog: Prog<()> = {
    <defs: Def*> => Prog { prog_defs: defs }
}
