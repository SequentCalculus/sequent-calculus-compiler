use crate::syntax::*;
use std::rc::Rc;
use std::str::FromStr;

#[LALR]
grammar;

// Helper rules

Comma<Rule>: Vec<Rule> =
    <rules: (<Rule> ",")*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };

Parens<Rule>: Rule =
    "(" <rule: Rule> ")" => rule;

Braces<Rule>: Rule =
    "{" <rule: Rule> "}" => rule;

Brackets<Rule>: Rule =
    "[" <rule: Rule> "]" => rule;

ParenthesizedArgs<Rule>: Vec<Rule> = Parens<Comma<Rule>>;
OptParenthesizedArgs<Rule>: Vec<Rule> = <args: Parens<Comma<Rule>>?> => args.unwrap_or_default();

BracedArgs<Rule>: Vec<Rule> = Braces<Comma<Rule>>;
OptBracedArgs<Rule>: Vec<Rule> = <args: Braces<Comma<Rule>>?> => args.unwrap_or_default();

BracketedArgs<Rule>: Vec<Rule> = Brackets<Comma<Rule>>;
OptBracketedArgs<Rule>: Vec<Rule> = <args: Brackets<Comma<Rule>>?> => args.unwrap_or_default();

// Parsers

Ctor: Ctor = {
    "Nil" => Ctor::Nil,
    "Cons" => Ctor::Cons,
    "Tup" => Ctor::Tup,
}

Dtor: Dtor = {
    "hd" => Dtor::Hd,
    "tl" => Dtor::Tl,
    "fst" => Dtor::Fst,
    "snd" => Dtor::Snd,
}

Label: Label = {
    "label" <label: Var> "{" <term: Term> "}" => Label { label, term: Rc::new(term) }
}

Goto: Goto = {
    "goto" "(" <term: Term> ";" <target: Var> ")" => Goto { term: Rc::new(term), target },
}

IfZ: IfZ = {
    "ifz" "(" <ifc: Term> "," <thenc: Term> "," <elsec: Term> ")" => IfZ { ifc: Rc::new(ifc), thenc: Rc::new(thenc), elsec: Rc::new(elsec) }
}

Let: Let = {
    "let" <variable: Var> "=" <t1: Term> "in" <t2: Term> => Let { variable, bound_term: Rc::new(t1), in_term: Rc::new(t2)},
}

Lam: Lam = {
    "\\" <variable: Var> "=>" <t: Term> => Lam { variable, body: Rc::new(t)},
}

App: App = {
    <function: Term1> <argument: Term> => App { function: Rc::new(function), argument: Rc::new(argument) }
}

Constructor: Constructor = {
    <id: Ctor> <args: OptParenthesizedArgs<Term1>> => Constructor { id, args }
}

Destructor: Destructor = {
    <e: Term1> "." <d: Dtor> => Destructor { id: d, destructee: Rc::new(e), args: vec![] }
}

CtorClause: Clause<Ctor> = {
    <c: Ctor> <vars: OptParenthesizedArgs<Var>> "=>" <e: Term> => Clause { xtor: c, vars, rhs: e }
}

DtorClause: Clause<Dtor> = {
    <d: Dtor> <vars: OptParenthesizedArgs<Var>> "=>" <e: Term> => Clause { xtor: d, vars, rhs: e }
}

Case: Case = {
    "case" <e: Term> "of" "{" <cases: Comma<CtorClause>> "}" => Case { destructee: Rc::new(e), cases }
}

Cocase: Cocase = {
    "cocase" "{" <cocases: Comma<DtorClause>> "}" => Cocase { cocases }
}

pub Term1: Term = {
    <n: Num> => Term::Lit(n),
    <v: Var> => Term::Var(v),
    <l: Label> => l.into(),
    <g: Goto> => g.into(),
    <c: Case> => c.into(),
    <c: Cocase> => c.into(),
    <i: IfZ> => i.into(),
}

pub Term: Term = {
    <n: Num> => Term::Lit(n),
    <v: Var> => Term::Var(v),
    "(" <t: Term> ")" => t,
    <l: Let> => l.into(),
    <l: Label> => l.into(),
    <g: Goto> => g.into(),
    <l: Lam> => l.into(),
    <a: App> => a.into(),
    <c: Constructor> => c.into(),
    <d: Destructor> => d.into(),
    <c: Case> => c.into(),
    <c: Cocase> => c.into(),
    <i: IfZ> => i.into(),
}

Num: i64 = {
    <s: r"[0-9]+"> => i64::from_str(s).unwrap()
}

Var: String = {
    // TODO: Think of regexp for vars :)
    <s: r"[x-z]"> => s.to_string()
}
