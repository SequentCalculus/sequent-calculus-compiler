//! This module contains the parser for programs in the surface language Fun.
use lalrpop_util::lalrpop_mod;
use result::ParseError;

use crate::syntax::{program::Program, terms::Term};

pub mod result;
pub mod util;

lalrpop_mod!(
    #[allow(clippy::all)]
    #[allow(unused_imports)]
    #[allow(dead_code)]
    /// This module contains the parser generated by `lalrpop`.
    pub fun, "/parser/fun.rs"
);

/// This function parses a term from a string.
pub fn parse_term(s: &str) -> Result<Term, ParseError> {
    let parser = fun::TermParser::new();
    parser.parse(s).map_err(From::from)
}

/// This function parses a module from a string.
pub fn parse_module(s: &str) -> Result<Program, ParseError> {
    let parser = fun::ProgParser::new();
    parser.parse(s).map_err(From::from)
}

/// This macro parses a string and returns the parsed term.
///
/// # Panics
///
/// A panic is caused if the string cannot be parsed.
#[macro_export]
macro_rules! parse_term {
    ($str:literal) => {
        fun::parser::fun::TermParser::new()
            .parse($str)
            .unwrap_or_else(|_| panic!("Could not parse input: {}", $str))
    };
}

#[cfg(test)]
mod parser_tests {
    use std::rc::Rc;

    use super::*;
    use crate::{
        syntax::{
            context::TypingContext,
            names::Ident,
            program::Program,
            terms::{Lit, Paren, Term, XVar},
            types::Ty,
            util::dummy_span,
        },
        test_common::{codata_stream, data_list, def_mult},
    };

    #[test]
    fn parse_parens() {
        let parser = fun::TermParser::new();
        let expected = Paren {
            span: dummy_span(),
            inner: Rc::new(Term::Lit(Lit::mk(22))),
        }
        .into();
        assert_eq!(parser.parse("(22)"), Ok(expected));
    }

    #[test]
    fn parse_lit() {
        let parser = fun::TermParser::new();
        let expected = Term::Lit(Lit::mk(22));
        assert_eq!(parser.parse("22"), Ok(expected));
    }

    #[test]
    fn parse_var() {
        let parser = fun::TermParser::new();
        let expected = XVar::mk(Ident {
            name: "x".to_string(),
            id: 0,
        })
        .into();
        assert_eq!(parser.parse("x"), Ok(expected));
    }

    #[test]
    fn parse_int() {
        let parser = fun::TyParser::new();
        let expected = Ty::mk_i64();
        assert_eq!(parser.parse("i64"), Ok(expected));
    }

    #[test]
    fn parse_ctx() {
        let mut ctx = TypingContext::default();
        ctx.add_var("x", 0, Ty::mk_i64());
        ctx.add_covar("a", 0, Ty::mk_i64());
        let parser = fun::OptContextParser::new();
        assert_eq!(parser.parse("(x : i64, a:cns i64)"), Ok(ctx))
    }

    #[test]
    fn parse_prog() {
        let parser = fun::ProgParser::new();
        let expected = Program {
            declarations: vec![
                data_list().into(),
                codata_stream().into(),
                def_mult().into(),
            ],
        };
        let result = parser.parse(
            "data List[A] { Nil, Cons(x:A,xs:List[A]) }
            codata Stream[A] { head : A , tail : Stream[A] }
            def mult(l:List[i64]):i64 { l.case[i64] {Nil => 1, Cons(x, xs) => x*mult(xs)} }",
        );
        assert_eq!(result, Ok(expected))
    }
}
