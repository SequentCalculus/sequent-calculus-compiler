    ; asmsyntax=nasm
section .note.GNU-stack noalloc noexec nowrite progbits
section .text
extern print_i64
extern println_i64
global asm_main

asm_main:
    ; setup
    ; save registers
    push rbx
    push rbp
    push r12
    push r13
    push r14
    push r15
    ; reserve space for register spills
    sub rsp, 2048
    ; initialize heap pointer
    mov rbx, rdi
    ; initialize free pointer
    mov rbp, rbx
    add rbp, 64
    ; move parameters into place
    mov rdx, rsi
    ; actual code

main_:
    ; new a1: List[List[Vec4]] = ()\{ ... \};
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    lea rdi, [rel List_List_Vec4_55252]
    ; jump test_fish_nofib_
    jmp test_fish_nofib_

List_List_Vec4_55252:
    jmp near List_List_Vec4_55252_Nil
    jmp near List_List_Vec4_55252_Cons

List_List_Vec4_55252_Nil:
    ; let res: List[List[Vec4]] = Nil();
    ; #mark no allocation
    mov rax, 0
    ; #load tag
    mov rdx, 0
    ; jump lift_main_0_
    jmp lift_main_0_

List_List_Vec4_55252_Cons:
    ; let res: List[List[Vec4]] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    mov [rbx + 40], rdx
    mov [rbx + 32], rax
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rax, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55264
    ; ####initialize refcount of just acquired block
    mov qword [rax + 0], 0
    jmp lab55265

lab55264:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55262
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55255
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55253
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55254

lab55253:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55254:

lab55255:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55258
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55256
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55257

lab55256:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55257:

lab55258:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55261
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55259
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55260

lab55259:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55260:

lab55261:
    jmp lab55263

lab55262:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55263:

lab55265:
    ; #load tag
    mov rdx, 5
    ; jump lift_main_0_
    jmp lift_main_0_

lift_main_0_:
    ; new a0: _Cont = ()\{ ... \};
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    lea rdi, [rel _Cont_55266]
    ; jump length_
    jmp length_

_Cont_55266:

_Cont_55266_Ret:
    ; println_i64 x1;
    ; #save caller-save registers
    mov r12, rdx
    sub rsp, 8
    ; #move argument into place
    mov rdi, rdx
    call println_i64
    ; #restore caller-save registers
    mov rdx, r12
    add rsp, 8
    ; substitute ;
    ; lit x0 <- 0;
    mov rdx, 0
    ; return x0
    mov rax, rdx
    jmp cleanup

vec_add_:
    ; substitute (a0 !-> a0)(v2 !-> v2)(v1 !-> v1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch v1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Vec_55267:

Vec_55267_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab55268
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    jmp lab55269

lab55268:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]

lab55269:
    ; substitute (a0 !-> a0)(y1 !-> y1)(x1 !-> x1)(v2 !-> v2);
    ; #move variables
    mov r10, rsi
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch v2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Vec_55270:

Vec_55270_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab55271
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]
    jmp lab55272

lab55271:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]

lab55272:
    ; x0 <- x1 + x2;
    mov r15, r9
    add r15, r11
    ; substitute (a0 !-> a0)(y1 !-> y1)(x0 !-> x0)(y2 !-> y2);
    ; #move variables
    mov r11, r13
    mov r9, r15
    ; x3 <- y1 + y2;
    mov r13, rdi
    add r13, r11
    ; substitute (x0 !-> x0)(x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov r8, rax
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rdi, r13
    ; invoke a0 Vec
    jmp r9

vec_sub_:
    ; substitute (a0 !-> a0)(v2 !-> v2)(v1 !-> v1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch v1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Vec_55273:

Vec_55273_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab55274
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    jmp lab55275

lab55274:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]

lab55275:
    ; substitute (a0 !-> a0)(y1 !-> y1)(x1 !-> x1)(v2 !-> v2);
    ; #move variables
    mov r10, rsi
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch v2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Vec_55276:

Vec_55276_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab55277
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]
    jmp lab55278

lab55277:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]

lab55278:
    ; x0 <- x1 - x2;
    mov r15, r9
    sub r15, r11
    ; substitute (a0 !-> a0)(y1 !-> y1)(x0 !-> x0)(y2 !-> y2);
    ; #move variables
    mov r11, r13
    mov r9, r15
    ; x3 <- y1 - y2;
    mov r13, rdi
    sub r13, r11
    ; substitute (x0 !-> x0)(x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov r8, rax
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rdi, r13
    ; invoke a0 Vec
    jmp r9

scale_vec2_:
    ; substitute (a0 !-> a0)(a !-> a)(b !-> b)(v !-> v);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; switch v \{ ... \};
    ; #if there is only one clause, we can just fall through

Vec_55279:

Vec_55279_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab55280
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]
    jmp lab55281

lab55280:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]

lab55281:
    ; x0 <- x * a;
    mov r15, r11
    imul r15, rdi
    ; substitute (a0 !-> a0)(a !-> a)(b !-> b)(x0 !-> x0)(y !-> y);
    ; #move variables
    mov r11, r15
    ; x1 <- x0 / b;
    mov rcx, rdx
    mov r15, rax
    mov rax, r11
    cqo
    idiv r9
    mov rdx, rax
    mov rax, r15
    mov r15, rdx
    mov rdx, rcx
    ; substitute (a0 !-> a0)(a !-> a)(b !-> b)(x1 !-> x1)(y !-> y);
    ; #move variables
    mov r11, r15
    ; x2 <- y * a;
    mov r15, r13
    imul r15, rdi
    ; substitute (a0 !-> a0)(x2 !-> x2)(b !-> b)(x1 !-> x1);
    ; #move variables
    mov rdi, r15
    ; x3 <- x2 / b;
    mov rcx, rdx
    mov r13, rax
    mov rax, rdi
    cqo
    idiv r9
    mov rdx, rax
    mov rax, r13
    mov r13, rdx
    mov rdx, rcx
    ; substitute (x1 !-> x1)(x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov r8, rax
    mov r9, rdx
    mov rdx, r11
    mov rdi, r13
    ; invoke a0 Vec
    jmp r9

p_tile_:
    ; lit x1 <- 0;
    mov rdi, 0
    ; lit x2 <- 3;
    mov r9, 3
    ; lit x3 <- 3;
    mov r11, 3
    ; lit x4 <- 4;
    mov r13, 4
    ; let x0: Vec4 = Vec4(x1, x2, x3, x4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55293
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab55294

lab55293:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55291
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55284
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55282
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55283

lab55282:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55283:

lab55284:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55287
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55285
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55286

lab55285:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55286:

lab55287:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55290
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55288
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55289

lab55288:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55289:

lab55290:
    jmp lab55292

lab55291:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55292:

lab55294:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55306
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab55307

lab55306:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55304
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55297
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55295
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55296

lab55295:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55296:

lab55297:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55300
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55298
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55299

lab55298:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55299:

lab55300:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55303
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55301
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55302

lab55301:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55302:

lab55303:
    jmp lab55305

lab55304:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55305:

lab55307:
    ; #load tag
    mov rdi, 0
    ; lit x7 <- 3;
    mov r9, 3
    ; lit x8 <- 4;
    mov r11, 4
    ; lit x9 <- 0;
    mov r13, 0
    ; lit x10 <- 8;
    mov r15, 8
    ; let x6: Vec4 = Vec4(x7, x8, x9, x10);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    mov [rbx + 24], r11
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55319
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab55320

lab55319:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55317
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55310
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55308
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55309

lab55308:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55309:

lab55310:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55313
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55311
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55312

lab55311:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55312:

lab55313:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55316
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55314
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55315

lab55314:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55315:

lab55316:
    jmp lab55318

lab55317:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55318:

lab55320:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55332
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab55333

lab55332:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55330
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55323
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55321
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55322

lab55321:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55322:

lab55323:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55326
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55324
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55325

lab55324:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55325:

lab55326:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55329
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55327
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55328

lab55327:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55328:

lab55329:
    jmp lab55331

lab55330:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55331:

lab55333:
    ; #load tag
    mov r9, 0
    ; lit x13 <- 0;
    mov r11, 0
    ; lit x14 <- 8;
    mov r13, 8
    ; lit x15 <- 0;
    mov r15, 0
    ; lit x16 <- 3;
    mov qword [rsp + 2024], 3
    ; let x12: Vec4 = Vec4(x13, x14, x15, x16);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov [rbx + 40], r15
    mov qword [rbx + 32], 0
    mov [rbx + 24], r13
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55345
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab55346

lab55345:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55343
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55336
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55334
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55335

lab55334:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55335:

lab55336:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55339
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55337
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55338

lab55337:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55338:

lab55339:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55342
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55340
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55341

lab55340:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55341:

lab55342:
    jmp lab55344

lab55343:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55344:

lab55346:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55358
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab55359

lab55358:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55356
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55349
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55347
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55348

lab55347:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55348:

lab55349:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55352
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55350
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55351

lab55350:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55351:

lab55352:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55355
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55353
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55354

lab55353:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55354:

lab55355:
    jmp lab55357

lab55356:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55357:

lab55359:
    ; #load tag
    mov r11, 0
    ; lit x19 <- 6;
    mov r13, 6
    ; lit x20 <- 0;
    mov r15, 0
    ; lit x21 <- 4;
    mov qword [rsp + 2024], 4
    ; lit x22 <- 4;
    mov qword [rsp + 2008], 4
    ; let x18: Vec4 = Vec4(x19, x20, x21, x22);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov [rbx + 24], r15
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55371
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab55372

lab55371:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55369
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55362
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55360
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55361

lab55360:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55361:

lab55362:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55365
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55363
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55364

lab55363:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55364:

lab55365:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55368
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55366
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55367

lab55366:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55367:

lab55368:
    jmp lab55370

lab55369:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55370:

lab55372:
    ; ##store link to previous block
    mov [rbx + 48], r14
    ; ##store values
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55384
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab55385

lab55384:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55382
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55375
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55373
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55374

lab55373:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55374:

lab55375:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55378
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55376
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55377

lab55376:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55377:

lab55378:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55381
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55379
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55380

lab55379:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55380:

lab55381:
    jmp lab55383

lab55382:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55383:

lab55385:
    ; #load tag
    mov r13, 0
    ; lit x25 <- 4;
    mov r15, 4
    ; lit x26 <- 5;
    mov qword [rsp + 2024], 5
    ; lit x27 <- 4;
    mov qword [rsp + 2008], 4
    ; lit x28 <- 10;
    mov qword [rsp + 1992], 10
    ; let x24: Vec4 = Vec4(x25, x26, x27, x28);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55397
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55398

lab55397:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55395
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55388
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55386
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55387

lab55386:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55387:

lab55388:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55391
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55389
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55390

lab55389:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55390:

lab55391:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55394
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55392
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55393

lab55392:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55393:

lab55394:
    jmp lab55396

lab55395:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55396:

lab55398:
    ; ##store link to previous block
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    ; ##store values
    mov [rbx + 40], r15
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55410
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab55411

lab55410:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55408
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55401
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55399
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55400

lab55399:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55400:

lab55401:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55404
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55402
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55403

lab55402:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55403:

lab55404:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55407
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55405
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55406

lab55405:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55406:

lab55407:
    jmp lab55409

lab55408:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55409:

lab55411:
    ; #load tag
    mov r15, 0
    ; lit x31 <- 4;
    mov qword [rsp + 2024], 4
    ; lit x32 <- 10;
    mov qword [rsp + 2008], 10
    ; lit x33 <- 7;
    mov qword [rsp + 1992], 7
    ; lit x34 <- 6;
    mov qword [rsp + 1976], 6
    ; let x30: Vec4 = Vec4(x31, x32, x33, x34);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 2008]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55423
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55424

lab55423:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55421
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55414
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55412
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55413

lab55412:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55413:

lab55414:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55417
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55415
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55416

lab55415:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55416:

lab55417:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55420
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55418
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55419

lab55418:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55419:

lab55420:
    jmp lab55422

lab55421:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55422:

lab55424:
    ; ##store link to previous block
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55436
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55437

lab55436:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55434
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55427
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55425
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55426

lab55425:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55426:

lab55427:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55430
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55428
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55429

lab55428:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55429:

lab55430:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55433
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55431
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55432

lab55431:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55432:

lab55433:
    jmp lab55435

lab55434:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55435:

lab55437:
    ; #load tag
    mov qword [rsp + 2024], 0
    ; lit x37 <- 7;
    mov qword [rsp + 2008], 7
    ; lit x38 <- 6;
    mov qword [rsp + 1992], 6
    ; lit x39 <- 4;
    mov qword [rsp + 1976], 4
    ; lit x40 <- 5;
    mov qword [rsp + 1960], 5
    ; let x36: Vec4 = Vec4(x37, x38, x39, x40);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55449
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55450

lab55449:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55447
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55440
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55438
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55439

lab55438:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55439:

lab55440:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55443
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55441
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55442

lab55441:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55442:

lab55443:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55446
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55444
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55445

lab55444:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55445:

lab55446:
    jmp lab55448

lab55447:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55448:

lab55450:
    ; ##store link to previous block
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55462
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55463

lab55462:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55460
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55453
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55451
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55452

lab55451:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55452:

lab55453:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55456
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55454
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55455

lab55454:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55455:

lab55456:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55459
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55457
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55458

lab55457:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55458:

lab55459:
    jmp lab55461

lab55460:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55461:

lab55463:
    ; #load tag
    mov qword [rsp + 2008], 0
    ; lit x43 <- 11;
    mov qword [rsp + 1992], 11
    ; lit x44 <- 0;
    mov qword [rsp + 1976], 0
    ; lit x45 <- 10;
    mov qword [rsp + 1960], 10
    ; lit x46 <- 4;
    mov qword [rsp + 1944], 4
    ; let x42: Vec4 = Vec4(x43, x44, x45, x46);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1976]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55475
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55476

lab55475:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55473
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55466
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55464
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55465

lab55464:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55465:

lab55466:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55469
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55467
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55468

lab55467:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55468:

lab55469:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55472
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55470
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55471

lab55470:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55471:

lab55472:
    jmp lab55474

lab55473:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55474:

lab55476:
    ; ##store link to previous block
    mov rcx, [rsp + 1984]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55488
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55489

lab55488:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55486
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55479
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55477
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55478

lab55477:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55478:

lab55479:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55482
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55480
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55481

lab55480:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55481:

lab55482:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55485
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55483
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55484

lab55483:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55484:

lab55485:
    jmp lab55487

lab55486:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55487:

lab55489:
    ; #load tag
    mov qword [rsp + 1992], 0
    ; lit x49 <- 10;
    mov qword [rsp + 1976], 10
    ; lit x50 <- 4;
    mov qword [rsp + 1960], 4
    ; lit x51 <- 9;
    mov qword [rsp + 1944], 9
    ; lit x52 <- 6;
    mov qword [rsp + 1928], 6
    ; let x48: Vec4 = Vec4(x49, x50, x51, x52);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1960]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55501
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55502

lab55501:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55499
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55492
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55490
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55491

lab55490:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55491:

lab55492:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55495
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55493
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55494

lab55493:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55494:

lab55495:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55498
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55496
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55497

lab55496:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55497:

lab55498:
    jmp lab55500

lab55499:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55500:

lab55502:
    ; ##store link to previous block
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55514
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55515

lab55514:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55512
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55505
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55503
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55504

lab55503:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55504:

lab55505:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55508
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55506
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55507

lab55506:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55507:

lab55508:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55511
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55509
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55510

lab55509:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55510:

lab55511:
    jmp lab55513

lab55512:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55513:

lab55515:
    ; #load tag
    mov qword [rsp + 1976], 0
    ; lit x55 <- 9;
    mov qword [rsp + 1960], 9
    ; lit x56 <- 6;
    mov qword [rsp + 1944], 6
    ; lit x57 <- 8;
    mov qword [rsp + 1928], 8
    ; lit x58 <- 8;
    mov qword [rsp + 1912], 8
    ; let x54: Vec4 = Vec4(x55, x56, x57, x58);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1912]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1928]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1944]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1952], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55527
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55528

lab55527:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55525
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55518
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55516
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55517

lab55516:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55517:

lab55518:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55521
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55519
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55520

lab55519:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55520:

lab55521:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55524
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55522
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55523

lab55522:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55523:

lab55524:
    jmp lab55526

lab55525:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55526:

lab55528:
    ; ##store link to previous block
    mov rcx, [rsp + 1952]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55540
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55541

lab55540:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55538
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55531
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55529
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55530

lab55529:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55530:

lab55531:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55534
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55532
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55533

lab55532:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55533:

lab55534:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55537
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55535
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55536

lab55535:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55536:

lab55537:
    jmp lab55539

lab55538:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55539:

lab55541:
    ; #load tag
    mov qword [rsp + 1960], 0
    ; lit x61 <- 8;
    mov qword [rsp + 1944], 8
    ; lit x62 <- 8;
    mov qword [rsp + 1928], 8
    ; lit x63 <- 4;
    mov qword [rsp + 1912], 4
    ; lit x64 <- 13;
    mov qword [rsp + 1896], 13
    ; let x60: Vec4 = Vec4(x61, x62, x63, x64);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1928]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55553
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55554

lab55553:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55551
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55544
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55542
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55543

lab55542:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55543:

lab55544:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55547
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55545
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55546

lab55545:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55546:

lab55547:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55550
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55548
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55549

lab55548:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55549:

lab55550:
    jmp lab55552

lab55551:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55552:

lab55554:
    ; ##store link to previous block
    mov rcx, [rsp + 1936]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1952], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55566
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55567

lab55566:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55564
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55557
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55555
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55556

lab55555:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55556:

lab55557:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55560
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55558
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55559

lab55558:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55559:

lab55560:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55563
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55561
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55562

lab55561:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55562:

lab55563:
    jmp lab55565

lab55564:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55565:

lab55567:
    ; #load tag
    mov qword [rsp + 1944], 0
    ; lit x67 <- 4;
    mov qword [rsp + 1928], 4
    ; lit x68 <- 13;
    mov qword [rsp + 1912], 13
    ; lit x69 <- 0;
    mov qword [rsp + 1896], 0
    ; lit x70 <- 16;
    mov qword [rsp + 1880], 16
    ; let x66: Vec4 = Vec4(x67, x68, x69, x70);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1880]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1896]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1912]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1920], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55579
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55580

lab55579:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55577
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55570
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55568
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55569

lab55568:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55569:

lab55570:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55573
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55571
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55572

lab55571:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55572:

lab55573:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55576
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55574
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55575

lab55574:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55575:

lab55576:
    jmp lab55578

lab55577:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55578:

lab55580:
    ; ##store link to previous block
    mov rcx, [rsp + 1920]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55592
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55593

lab55592:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55590
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55583
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55581
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55582

lab55581:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55582:

lab55583:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55586
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55584
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55585

lab55584:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55585:

lab55586:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55589
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55587
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55588

lab55587:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55588:

lab55589:
    jmp lab55591

lab55590:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55591:

lab55593:
    ; #load tag
    mov qword [rsp + 1928], 0
    ; lit x73 <- 0;
    mov qword [rsp + 1912], 0
    ; lit x74 <- 16;
    mov qword [rsp + 1896], 16
    ; lit x75 <- 6;
    mov qword [rsp + 1880], 6
    ; lit x76 <- 15;
    mov qword [rsp + 1864], 15
    ; let x72: Vec4 = Vec4(x73, x74, x75, x76);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1864]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1880]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1896]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1904], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55605
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55606

lab55605:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55603
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55596
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55594
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55595

lab55594:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55595:

lab55596:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55599
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55597
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55598

lab55597:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55598:

lab55599:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55602
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55600
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55601

lab55600:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55601:

lab55602:
    jmp lab55604

lab55603:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55604:

lab55606:
    ; ##store link to previous block
    mov rcx, [rsp + 1904]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1920], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55618
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55619

lab55618:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55616
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55609
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55607
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55608

lab55607:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55608:

lab55609:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55612
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55610
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55611

lab55610:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55611:

lab55612:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55615
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55613
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55614

lab55613:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55614:

lab55615:
    jmp lab55617

lab55616:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55617:

lab55619:
    ; #load tag
    mov qword [rsp + 1912], 0
    ; lit x79 <- 6;
    mov qword [rsp + 1896], 6
    ; lit x80 <- 15;
    mov qword [rsp + 1880], 15
    ; lit x81 <- 8;
    mov qword [rsp + 1864], 8
    ; lit x82 <- 16;
    mov qword [rsp + 1848], 16
    ; let x78: Vec4 = Vec4(x79, x80, x81, x82);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1848]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1864]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1880]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1888], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55631
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55632

lab55631:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55629
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55622
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55620
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55621

lab55620:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55621:

lab55622:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55625
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55623
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55624

lab55623:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55624:

lab55625:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55628
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55626
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55627

lab55626:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55627:

lab55628:
    jmp lab55630

lab55629:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55630:

lab55632:
    ; ##store link to previous block
    mov rcx, [rsp + 1888]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1904], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55644
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55645

lab55644:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55642
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55635
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55633
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55634

lab55633:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55634:

lab55635:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55638
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55636
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55637

lab55636:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55637:

lab55638:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55641
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55639
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55640

lab55639:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55640:

lab55641:
    jmp lab55643

lab55642:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55643:

lab55645:
    ; #load tag
    mov qword [rsp + 1896], 0
    ; lit x85 <- 8;
    mov qword [rsp + 1880], 8
    ; lit x86 <- 16;
    mov qword [rsp + 1864], 16
    ; lit x87 <- 12;
    mov qword [rsp + 1848], 12
    ; lit x88 <- 12;
    mov qword [rsp + 1832], 12
    ; let x84: Vec4 = Vec4(x85, x86, x87, x88);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1832]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1848]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1864]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1872], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55657
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55658

lab55657:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55655
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55648
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55646
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55647

lab55646:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55647:

lab55648:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55651
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55649
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55650

lab55649:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55650:

lab55651:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55654
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55652
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55653

lab55652:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55653:

lab55654:
    jmp lab55656

lab55655:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55656:

lab55658:
    ; ##store link to previous block
    mov rcx, [rsp + 1872]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1880]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1888], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55670
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55671

lab55670:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55668
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55661
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55659
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55660

lab55659:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55660:

lab55661:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55664
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55662
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55663

lab55662:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55663:

lab55664:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55667
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55665
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55666

lab55665:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55666:

lab55667:
    jmp lab55669

lab55668:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55669:

lab55671:
    ; #load tag
    mov qword [rsp + 1880], 0
    ; lit x91 <- 12;
    mov qword [rsp + 1864], 12
    ; lit x92 <- 12;
    mov qword [rsp + 1848], 12
    ; lit x93 <- 16;
    mov qword [rsp + 1832], 16
    ; lit x94 <- 12;
    mov qword [rsp + 1816], 12
    ; let x90: Vec4 = Vec4(x91, x92, x93, x94);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1816]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1832]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1848]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1856], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55683
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55684

lab55683:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55681
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55674
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55672
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55673

lab55672:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55673:

lab55674:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55677
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55675
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55676

lab55675:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55676:

lab55677:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55680
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55678
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55679

lab55678:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55679:

lab55680:
    jmp lab55682

lab55681:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55682:

lab55684:
    ; ##store link to previous block
    mov rcx, [rsp + 1856]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1864]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1872], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55696
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55697

lab55696:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55694
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55687
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55685
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55686

lab55685:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55686:

lab55687:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55690
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55688
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55689

lab55688:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55689:

lab55690:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55693
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55691
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55692

lab55691:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55692:

lab55693:
    jmp lab55695

lab55694:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55695:

lab55697:
    ; #load tag
    mov qword [rsp + 1864], 0
    ; lit x97 <- 10;
    mov qword [rsp + 1848], 10
    ; lit x98 <- 16;
    mov qword [rsp + 1832], 16
    ; lit x99 <- 12;
    mov qword [rsp + 1816], 12
    ; lit x100 <- 14;
    mov qword [rsp + 1800], 14
    ; let x96: Vec4 = Vec4(x97, x98, x99, x100);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1800]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1816]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1832]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1840], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55709
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55710

lab55709:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55707
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55700
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55698
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55699

lab55698:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55699:

lab55700:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55703
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55701
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55702

lab55701:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55702:

lab55703:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55706
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55704
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55705

lab55704:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55705:

lab55706:
    jmp lab55708

lab55707:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55708:

lab55710:
    ; ##store link to previous block
    mov rcx, [rsp + 1840]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1848]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1856], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55722
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55723

lab55722:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55720
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55713
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55711
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55712

lab55711:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55712:

lab55713:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55716
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55714
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55715

lab55714:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55715:

lab55716:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55719
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55717
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55718

lab55717:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55718:

lab55719:
    jmp lab55721

lab55720:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55721:

lab55723:
    ; #load tag
    mov qword [rsp + 1848], 0
    ; lit x103 <- 12;
    mov qword [rsp + 1832], 12
    ; lit x104 <- 14;
    mov qword [rsp + 1816], 14
    ; lit x105 <- 16;
    mov qword [rsp + 1800], 16
    ; lit x106 <- 13;
    mov qword [rsp + 1784], 13
    ; let x102: Vec4 = Vec4(x103, x104, x105, x106);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1784]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1800]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1816]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1824], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55735
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55736

lab55735:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55733
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55726
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55724
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55725

lab55724:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55725:

lab55726:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55729
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55727
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55728

lab55727:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55728:

lab55729:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55732
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55730
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55731

lab55730:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55731:

lab55732:
    jmp lab55734

lab55733:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55734:

lab55736:
    ; ##store link to previous block
    mov rcx, [rsp + 1824]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1832]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1840], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55748
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55749

lab55748:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55746
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55739
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55737
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55738

lab55737:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55738:

lab55739:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55742
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55740
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55741

lab55740:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55741:

lab55742:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55745
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55743
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55744

lab55743:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55744:

lab55745:
    jmp lab55747

lab55746:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55747:

lab55749:
    ; #load tag
    mov qword [rsp + 1832], 0
    ; lit x109 <- 12;
    mov qword [rsp + 1816], 12
    ; lit x110 <- 16;
    mov qword [rsp + 1800], 16
    ; lit x111 <- 13;
    mov qword [rsp + 1784], 13
    ; lit x112 <- 15;
    mov qword [rsp + 1768], 15
    ; let x108: Vec4 = Vec4(x109, x110, x111, x112);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1768]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1784]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1800]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1808], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55761
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55762

lab55761:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55759
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55752
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55750
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55751

lab55750:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55751:

lab55752:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55755
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55753
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55754

lab55753:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55754:

lab55755:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55758
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55756
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55757

lab55756:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55757:

lab55758:
    jmp lab55760

lab55759:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55760:

lab55762:
    ; ##store link to previous block
    mov rcx, [rsp + 1808]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1816]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1824], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55774
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55775

lab55774:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55772
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55765
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55763
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55764

lab55763:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55764:

lab55765:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55768
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55766
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55767

lab55766:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55767:

lab55768:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55771
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55769
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55770

lab55769:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55770:

lab55771:
    jmp lab55773

lab55772:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55773:

lab55775:
    ; #load tag
    mov qword [rsp + 1816], 0
    ; lit x115 <- 13;
    mov qword [rsp + 1800], 13
    ; lit x116 <- 15;
    mov qword [rsp + 1784], 15
    ; lit x117 <- 16;
    mov qword [rsp + 1768], 16
    ; lit x118 <- 14;
    mov qword [rsp + 1752], 14
    ; let x114: Vec4 = Vec4(x115, x116, x117, x118);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1752]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1768]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1784]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1792], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55787
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55788

lab55787:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55785
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55778
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55776
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55777

lab55776:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55777:

lab55778:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55781
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55779
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55780

lab55779:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55780:

lab55781:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55784
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55782
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55783

lab55782:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55783:

lab55784:
    jmp lab55786

lab55785:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55786:

lab55788:
    ; ##store link to previous block
    mov rcx, [rsp + 1792]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1800]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1808], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55800
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55801

lab55800:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55798
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55791
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55789
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55790

lab55789:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55790:

lab55791:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55794
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55792
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55793

lab55792:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55793:

lab55794:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55797
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55795
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55796

lab55795:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55796:

lab55797:
    jmp lab55799

lab55798:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55799:

lab55801:
    ; #load tag
    mov qword [rsp + 1800], 0
    ; lit x121 <- 14;
    mov qword [rsp + 1784], 14
    ; lit x122 <- 16;
    mov qword [rsp + 1768], 16
    ; lit x123 <- 16;
    mov qword [rsp + 1752], 16
    ; lit x124 <- 15;
    mov qword [rsp + 1736], 15
    ; let x120: Vec4 = Vec4(x121, x122, x123, x124);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1736]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1752]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1768]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1776], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55813
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55814

lab55813:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55811
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55804
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55802
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55803

lab55802:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55803:

lab55804:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55807
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55805
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55806

lab55805:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55806:

lab55807:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55810
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55808
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55809

lab55808:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55809:

lab55810:
    jmp lab55812

lab55811:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55812:

lab55814:
    ; ##store link to previous block
    mov rcx, [rsp + 1776]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1784]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1792], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55826
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55827

lab55826:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55824
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55817
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55815
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55816

lab55815:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55816:

lab55817:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55820
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55818
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55819

lab55818:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55819:

lab55820:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55823
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55821
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55822

lab55821:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55822:

lab55823:
    jmp lab55825

lab55824:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55825:

lab55827:
    ; #load tag
    mov qword [rsp + 1784], 0
    ; lit x127 <- 8;
    mov qword [rsp + 1768], 8
    ; lit x128 <- 12;
    mov qword [rsp + 1752], 12
    ; lit x129 <- 16;
    mov qword [rsp + 1736], 16
    ; lit x130 <- 10;
    mov qword [rsp + 1720], 10
    ; let x126: Vec4 = Vec4(x127, x128, x129, x130);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1720]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1736]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1752]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1760], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55839
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55840

lab55839:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55837
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55830
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55828
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55829

lab55828:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55829:

lab55830:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55833
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55831
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55832

lab55831:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55832:

lab55833:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55836
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55834
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55835

lab55834:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55835:

lab55836:
    jmp lab55838

lab55837:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55838:

lab55840:
    ; ##store link to previous block
    mov rcx, [rsp + 1760]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1768]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1776], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55852
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55853

lab55852:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55850
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55843
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55841
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55842

lab55841:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55842:

lab55843:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55846
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55844
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55845

lab55844:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55845:

lab55846:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55849
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55847
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55848

lab55847:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55848:

lab55849:
    jmp lab55851

lab55850:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55851:

lab55853:
    ; #load tag
    mov qword [rsp + 1768], 0
    ; lit x133 <- 8;
    mov qword [rsp + 1752], 8
    ; lit x134 <- 8;
    mov qword [rsp + 1736], 8
    ; lit x135 <- 12;
    mov qword [rsp + 1720], 12
    ; lit x136 <- 9;
    mov qword [rsp + 1704], 9
    ; let x132: Vec4 = Vec4(x133, x134, x135, x136);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1704]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1720]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1736]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1744], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55865
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55866

lab55865:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55863
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55856
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55854
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55855

lab55854:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55855:

lab55856:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55859
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55857
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55858

lab55857:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55858:

lab55859:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55862
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55860
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55861

lab55860:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55861:

lab55862:
    jmp lab55864

lab55863:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55864:

lab55866:
    ; ##store link to previous block
    mov rcx, [rsp + 1744]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1752]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1760], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55878
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55879

lab55878:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55876
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55869
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55867
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55868

lab55867:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55868:

lab55869:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55872
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55870
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55871

lab55870:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55871:

lab55872:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55875
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55873
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55874

lab55873:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55874:

lab55875:
    jmp lab55877

lab55876:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55877:

lab55879:
    ; #load tag
    mov qword [rsp + 1752], 0
    ; lit x139 <- 12;
    mov qword [rsp + 1736], 12
    ; lit x140 <- 9;
    mov qword [rsp + 1720], 9
    ; lit x141 <- 16;
    mov qword [rsp + 1704], 16
    ; lit x142 <- 8;
    mov qword [rsp + 1688], 8
    ; let x138: Vec4 = Vec4(x139, x140, x141, x142);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1688]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1704]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1720]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1728], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55891
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55892

lab55891:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55889
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55882
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55880
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55881

lab55880:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55881:

lab55882:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55885
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55883
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55884

lab55883:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55884:

lab55885:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55888
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55886
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55887

lab55886:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55887:

lab55888:
    jmp lab55890

lab55889:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55890:

lab55892:
    ; ##store link to previous block
    mov rcx, [rsp + 1728]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1736]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1744], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55904
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55905

lab55904:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55902
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55895
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55893
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55894

lab55893:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55894:

lab55895:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55898
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55896
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55897

lab55896:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55897:

lab55898:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55901
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55899
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55900

lab55899:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55900:

lab55901:
    jmp lab55903

lab55902:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55903:

lab55905:
    ; #load tag
    mov qword [rsp + 1736], 0
    ; lit x145 <- 9;
    mov qword [rsp + 1720], 9
    ; lit x146 <- 6;
    mov qword [rsp + 1704], 6
    ; lit x147 <- 12;
    mov qword [rsp + 1688], 12
    ; lit x148 <- 7;
    mov qword [rsp + 1672], 7
    ; let x144: Vec4 = Vec4(x145, x146, x147, x148);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1672]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1688]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1704]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1712], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55917
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55918

lab55917:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55915
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55908
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55906
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55907

lab55906:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55907:

lab55908:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55911
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55909
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55910

lab55909:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55910:

lab55911:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55914
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55912
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55913

lab55912:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55913:

lab55914:
    jmp lab55916

lab55915:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55916:

lab55918:
    ; ##store link to previous block
    mov rcx, [rsp + 1712]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1720]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1728], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55930
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55931

lab55930:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55928
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55921
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55919
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55920

lab55919:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55920:

lab55921:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55924
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55922
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55923

lab55922:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55923:

lab55924:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55927
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55925
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55926

lab55925:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55926:

lab55927:
    jmp lab55929

lab55928:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55929:

lab55931:
    ; #load tag
    mov qword [rsp + 1720], 0
    ; lit x151 <- 12;
    mov qword [rsp + 1704], 12
    ; lit x152 <- 7;
    mov qword [rsp + 1688], 7
    ; lit x153 <- 16;
    mov qword [rsp + 1672], 16
    ; lit x154 <- 6;
    mov qword [rsp + 1656], 6
    ; let x150: Vec4 = Vec4(x151, x152, x153, x154);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1656]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1672]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1688]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1696], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55943
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55944

lab55943:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55941
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55934
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55932
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55933

lab55932:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55933:

lab55934:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55937
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55935
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55936

lab55935:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55936:

lab55937:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55940
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55938
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55939

lab55938:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55939:

lab55940:
    jmp lab55942

lab55941:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55942:

lab55944:
    ; ##store link to previous block
    mov rcx, [rsp + 1696]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1704]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1712], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55956
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55957

lab55956:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55954
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55947
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55945
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55946

lab55945:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55946:

lab55947:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55950
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55948
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55949

lab55948:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55949:

lab55950:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55953
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55951
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55952

lab55951:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55952:

lab55953:
    jmp lab55955

lab55954:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55955:

lab55957:
    ; #load tag
    mov qword [rsp + 1704], 0
    ; lit x157 <- 10;
    mov qword [rsp + 1688], 10
    ; lit x158 <- 4;
    mov qword [rsp + 1672], 4
    ; lit x159 <- 13;
    mov qword [rsp + 1656], 13
    ; lit x160 <- 5;
    mov qword [rsp + 1640], 5
    ; let x156: Vec4 = Vec4(x157, x158, x159, x160);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1640]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1656]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1672]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1680], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55969
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55970

lab55969:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55967
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55960
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55958
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55959

lab55958:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55959:

lab55960:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55963
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55961
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55962

lab55961:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55962:

lab55963:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55966
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55964
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55965

lab55964:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55965:

lab55966:
    jmp lab55968

lab55967:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55968:

lab55970:
    ; ##store link to previous block
    mov rcx, [rsp + 1680]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1688]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1696], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55982
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55983

lab55982:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55980
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55973
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55971
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55972

lab55971:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55972:

lab55973:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55976
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55974
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55975

lab55974:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55975:

lab55976:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55979
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55977
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55978

lab55977:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55978:

lab55979:
    jmp lab55981

lab55980:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55981:

lab55983:
    ; #load tag
    mov qword [rsp + 1688], 0
    ; lit x163 <- 13;
    mov qword [rsp + 1672], 13
    ; lit x164 <- 5;
    mov qword [rsp + 1656], 5
    ; lit x165 <- 16;
    mov qword [rsp + 1640], 16
    ; lit x166 <- 4;
    mov qword [rsp + 1624], 4
    ; let x162: Vec4 = Vec4(x163, x164, x165, x166);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1624]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1640]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1656]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1664], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab55995
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab55996

lab55995:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab55993
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55986
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55984
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55985

lab55984:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55985:

lab55986:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab55989
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55987
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55988

lab55987:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55988:

lab55989:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab55992
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55990
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55991

lab55990:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55991:

lab55992:
    jmp lab55994

lab55993:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab55994:

lab55996:
    ; ##store link to previous block
    mov rcx, [rsp + 1664]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1672]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1680], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56008
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56009

lab56008:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56006
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab55999
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab55997
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab55998

lab55997:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab55998:

lab55999:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56002
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56000
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56001

lab56000:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56001:

lab56002:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56005
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56003
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56004

lab56003:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56004:

lab56005:
    jmp lab56007

lab56006:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56007:

lab56009:
    ; #load tag
    mov qword [rsp + 1672], 0
    ; lit x169 <- 11;
    mov qword [rsp + 1656], 11
    ; lit x170 <- 0;
    mov qword [rsp + 1640], 0
    ; lit x171 <- 14;
    mov qword [rsp + 1624], 14
    ; lit x172 <- 2;
    mov qword [rsp + 1608], 2
    ; let x168: Vec4 = Vec4(x169, x170, x171, x172);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1608]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1624]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1640]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1648], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56021
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56022

lab56021:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56019
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56012
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56010
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56011

lab56010:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56011:

lab56012:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56015
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56013
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56014

lab56013:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56014:

lab56015:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56018
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56016
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56017

lab56016:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56017:

lab56018:
    jmp lab56020

lab56019:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56020:

lab56022:
    ; ##store link to previous block
    mov rcx, [rsp + 1648]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1656]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1664], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56034
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56035

lab56034:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56032
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56025
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56023
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56024

lab56023:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56024:

lab56025:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56028
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56026
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56027

lab56026:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56027:

lab56028:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56031
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56029
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56030

lab56029:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56030:

lab56031:
    jmp lab56033

lab56032:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56033:

lab56035:
    ; #load tag
    mov qword [rsp + 1656], 0
    ; lit x175 <- 14;
    mov qword [rsp + 1640], 14
    ; lit x176 <- 2;
    mov qword [rsp + 1624], 2
    ; lit x177 <- 16;
    mov qword [rsp + 1608], 16
    ; lit x178 <- 2;
    mov qword [rsp + 1592], 2
    ; let x174: Vec4 = Vec4(x175, x176, x177, x178);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1592]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1608]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1624]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1632], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56047
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56048

lab56047:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56045
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56038
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56036
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56037

lab56036:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56037:

lab56038:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56041
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56039
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56040

lab56039:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56040:

lab56041:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56044
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56042
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56043

lab56042:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56043:

lab56044:
    jmp lab56046

lab56045:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56046:

lab56048:
    ; ##store link to previous block
    mov rcx, [rsp + 1632]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1640]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1648], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56060
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56061

lab56060:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56058
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56051
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56049
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56050

lab56049:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56050:

lab56051:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56054
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56052
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56053

lab56052:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56053:

lab56054:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56057
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56055
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56056

lab56055:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56056:

lab56057:
    jmp lab56059

lab56058:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56059:

lab56061:
    ; #load tag
    mov qword [rsp + 1640], 0
    ; let x179: List[Vec4] = Nil();
    ; #mark no allocation
    mov qword [rsp + 1632], 0
    ; #load tag
    mov qword [rsp + 1624], 0
    ; let x173: List[Vec4] = Cons(x174, x179);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1624]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1632]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1640]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1648]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1648], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56073
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56074

lab56073:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56071
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56064
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56062
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56063

lab56062:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56063:

lab56064:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56067
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56065
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56066

lab56065:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56066:

lab56067:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56070
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56068
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56069

lab56068:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56069:

lab56070:
    jmp lab56072

lab56071:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56072:

lab56074:
    ; #load tag
    mov qword [rsp + 1640], 5
    ; let x167: List[Vec4] = Cons(x168, x173);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1640]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1648]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1656]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1664]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1664], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56086
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56087

lab56086:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56084
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56077
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56075
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56076

lab56075:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56076:

lab56077:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56080
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56078
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56079

lab56078:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56079:

lab56080:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56083
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56081
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56082

lab56081:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56082:

lab56083:
    jmp lab56085

lab56084:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56085:

lab56087:
    ; #load tag
    mov qword [rsp + 1656], 5
    ; let x161: List[Vec4] = Cons(x162, x167);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1656]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1664]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1672]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1680]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1680], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56099
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56100

lab56099:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56097
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56090
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56088
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56089

lab56088:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56089:

lab56090:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56093
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56091
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56092

lab56091:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56092:

lab56093:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56096
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56094
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56095

lab56094:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56095:

lab56096:
    jmp lab56098

lab56097:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56098:

lab56100:
    ; #load tag
    mov qword [rsp + 1672], 5
    ; let x155: List[Vec4] = Cons(x156, x161);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1672]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1680]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1688]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1696]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1696], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56112
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56113

lab56112:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56110
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56103
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56101
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56102

lab56101:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56102:

lab56103:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56106
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56104
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56105

lab56104:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56105:

lab56106:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56109
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56107
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56108

lab56107:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56108:

lab56109:
    jmp lab56111

lab56110:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56111:

lab56113:
    ; #load tag
    mov qword [rsp + 1688], 5
    ; let x149: List[Vec4] = Cons(x150, x155);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1688]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1696]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1704]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1712]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1712], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56125
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56126

lab56125:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56123
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56116
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56114
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56115

lab56114:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56115:

lab56116:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56119
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56117
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56118

lab56117:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56118:

lab56119:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56122
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56120
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56121

lab56120:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56121:

lab56122:
    jmp lab56124

lab56123:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56124:

lab56126:
    ; #load tag
    mov qword [rsp + 1704], 5
    ; let x143: List[Vec4] = Cons(x144, x149);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1704]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1712]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1720]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1728]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1728], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56138
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56139

lab56138:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56136
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56129
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56127
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56128

lab56127:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56128:

lab56129:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56132
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56130
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56131

lab56130:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56131:

lab56132:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56135
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56133
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56134

lab56133:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56134:

lab56135:
    jmp lab56137

lab56136:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56137:

lab56139:
    ; #load tag
    mov qword [rsp + 1720], 5
    ; let x137: List[Vec4] = Cons(x138, x143);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1720]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1728]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1736]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1744]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1744], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56151
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56152

lab56151:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56149
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56142
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56140
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56141

lab56140:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56141:

lab56142:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56145
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56143
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56144

lab56143:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56144:

lab56145:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56148
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56146
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56147

lab56146:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56147:

lab56148:
    jmp lab56150

lab56149:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56150:

lab56152:
    ; #load tag
    mov qword [rsp + 1736], 5
    ; let x131: List[Vec4] = Cons(x132, x137);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1736]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1744]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1752]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1760]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1760], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56164
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56165

lab56164:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56162
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56155
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56153
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56154

lab56153:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56154:

lab56155:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56158
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56156
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56157

lab56156:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56157:

lab56158:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56161
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56159
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56160

lab56159:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56160:

lab56161:
    jmp lab56163

lab56162:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56163:

lab56165:
    ; #load tag
    mov qword [rsp + 1752], 5
    ; let x125: List[Vec4] = Cons(x126, x131);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1752]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1760]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1768]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1776]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1776], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56177
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56178

lab56177:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56175
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56168
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56166
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56167

lab56166:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56167:

lab56168:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56171
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56169
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56170

lab56169:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56170:

lab56171:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56174
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56172
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56173

lab56172:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56173:

lab56174:
    jmp lab56176

lab56175:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56176:

lab56178:
    ; #load tag
    mov qword [rsp + 1768], 5
    ; let x119: List[Vec4] = Cons(x120, x125);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1768]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1776]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1784]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1792]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1792], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56190
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56191

lab56190:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56188
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56181
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56179
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56180

lab56179:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56180:

lab56181:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56184
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56182
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56183

lab56182:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56183:

lab56184:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56187
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56185
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56186

lab56185:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56186:

lab56187:
    jmp lab56189

lab56188:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56189:

lab56191:
    ; #load tag
    mov qword [rsp + 1784], 5
    ; let x113: List[Vec4] = Cons(x114, x119);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1784]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1792]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1800]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1808]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1808], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56203
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56204

lab56203:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56201
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56194
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56192
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56193

lab56192:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56193:

lab56194:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56197
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56195
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56196

lab56195:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56196:

lab56197:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56200
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56198
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56199

lab56198:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56199:

lab56200:
    jmp lab56202

lab56201:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56202:

lab56204:
    ; #load tag
    mov qword [rsp + 1800], 5
    ; let x107: List[Vec4] = Cons(x108, x113);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1800]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1808]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1816]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1824]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1824], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56216
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56217

lab56216:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56214
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56207
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56205
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56206

lab56205:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56206:

lab56207:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56210
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56208
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56209

lab56208:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56209:

lab56210:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56213
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56211
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56212

lab56211:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56212:

lab56213:
    jmp lab56215

lab56214:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56215:

lab56217:
    ; #load tag
    mov qword [rsp + 1816], 5
    ; let x101: List[Vec4] = Cons(x102, x107);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1816]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1824]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1832]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1840]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1840], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56229
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56230

lab56229:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56227
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56220
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56218
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56219

lab56218:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56219:

lab56220:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56223
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56221
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56222

lab56221:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56222:

lab56223:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56226
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56224
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56225

lab56224:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56225:

lab56226:
    jmp lab56228

lab56227:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56228:

lab56230:
    ; #load tag
    mov qword [rsp + 1832], 5
    ; let x95: List[Vec4] = Cons(x96, x101);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1832]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1840]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1848]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1856]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1856], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56242
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56243

lab56242:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56240
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56233
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56231
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56232

lab56231:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56232:

lab56233:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56236
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56234
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56235

lab56234:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56235:

lab56236:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56239
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56237
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56238

lab56237:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56238:

lab56239:
    jmp lab56241

lab56240:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56241:

lab56243:
    ; #load tag
    mov qword [rsp + 1848], 5
    ; let x89: List[Vec4] = Cons(x90, x95);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1848]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1856]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1864]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1872]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1872], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56255
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56256

lab56255:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56253
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56246
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56244
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56245

lab56244:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56245:

lab56246:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56249
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56247
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56248

lab56247:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56248:

lab56249:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56252
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56250
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56251

lab56250:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56251:

lab56252:
    jmp lab56254

lab56253:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56254:

lab56256:
    ; #load tag
    mov qword [rsp + 1864], 5
    ; let x83: List[Vec4] = Cons(x84, x89);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1864]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1872]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1880]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1888]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1888], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56268
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56269

lab56268:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56266
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56259
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56257
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56258

lab56257:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56258:

lab56259:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56262
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56260
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56261

lab56260:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56261:

lab56262:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56265
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56263
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56264

lab56263:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56264:

lab56265:
    jmp lab56267

lab56266:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56267:

lab56269:
    ; #load tag
    mov qword [rsp + 1880], 5
    ; let x77: List[Vec4] = Cons(x78, x83);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1880]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1888]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1896]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1904]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1904], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56281
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56282

lab56281:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56279
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56272
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56270
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56271

lab56270:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56271:

lab56272:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56275
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56273
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56274

lab56273:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56274:

lab56275:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56278
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56276
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56277

lab56276:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56277:

lab56278:
    jmp lab56280

lab56279:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56280:

lab56282:
    ; #load tag
    mov qword [rsp + 1896], 5
    ; let x71: List[Vec4] = Cons(x72, x77);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1904]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1920]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1920], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56294
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56295

lab56294:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56292
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56285
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56283
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56284

lab56283:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56284:

lab56285:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56288
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56286
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56287

lab56286:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56287:

lab56288:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56291
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56289
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56290

lab56289:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56290:

lab56291:
    jmp lab56293

lab56292:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56293:

lab56295:
    ; #load tag
    mov qword [rsp + 1912], 5
    ; let x65: List[Vec4] = Cons(x66, x71);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1912]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1920]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1928]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1936]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56307
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56308

lab56307:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56305
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56298
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56296
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56297

lab56296:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56297:

lab56298:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56301
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56299
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56300

lab56299:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56300:

lab56301:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56304
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56302
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56303

lab56302:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56303:

lab56304:
    jmp lab56306

lab56305:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56306:

lab56308:
    ; #load tag
    mov qword [rsp + 1928], 5
    ; let x59: List[Vec4] = Cons(x60, x65);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1936]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1952]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1952], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56320
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56321

lab56320:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56318
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56311
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56309
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56310

lab56309:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56310:

lab56311:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56314
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56312
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56313

lab56312:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56313:

lab56314:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56317
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56315
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56316

lab56315:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56316:

lab56317:
    jmp lab56319

lab56318:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56319:

lab56321:
    ; #load tag
    mov qword [rsp + 1944], 5
    ; let x53: List[Vec4] = Cons(x54, x59);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1952]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56333
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56334

lab56333:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56331
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56324
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56322
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56323

lab56322:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56323:

lab56324:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56327
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56325
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56326

lab56325:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56326:

lab56327:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56330
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56328
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56329

lab56328:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56329:

lab56330:
    jmp lab56332

lab56331:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56332:

lab56334:
    ; #load tag
    mov qword [rsp + 1960], 5
    ; let x47: List[Vec4] = Cons(x48, x53);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56346
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56347

lab56346:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56344
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56337
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56335
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56336

lab56335:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56336:

lab56337:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56340
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56338
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56339

lab56338:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56339:

lab56340:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56343
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56341
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56342

lab56341:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56342:

lab56343:
    jmp lab56345

lab56344:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56345:

lab56347:
    ; #load tag
    mov qword [rsp + 1976], 5
    ; let x41: List[Vec4] = Cons(x42, x47);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56359
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56360

lab56359:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56357
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56350
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56348
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56349

lab56348:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56349:

lab56350:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56353
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56351
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56352

lab56351:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56352:

lab56353:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56356
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56354
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56355

lab56354:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56355:

lab56356:
    jmp lab56358

lab56357:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56358:

lab56360:
    ; #load tag
    mov qword [rsp + 1992], 5
    ; let x35: List[Vec4] = Cons(x36, x41);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56372
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56373

lab56372:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56370
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56363
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56361
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56362

lab56361:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56362:

lab56363:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56366
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56364
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56365

lab56364:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56365:

lab56366:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56369
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56367
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56368

lab56367:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56368:

lab56369:
    jmp lab56371

lab56370:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56371:

lab56373:
    ; #load tag
    mov qword [rsp + 2008], 5
    ; let x29: List[Vec4] = Cons(x30, x35);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56385
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56386

lab56385:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56383
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56376
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56374
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56375

lab56374:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56375:

lab56376:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56379
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56377
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56378

lab56377:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56378:

lab56379:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56382
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56380
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56381

lab56380:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56381:

lab56382:
    jmp lab56384

lab56383:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56384:

lab56386:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; let x23: List[Vec4] = Cons(x24, x29);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56398
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab56399

lab56398:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56396
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56389
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56387
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56388

lab56387:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56388:

lab56389:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56392
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56390
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56391

lab56390:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56391:

lab56392:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56395
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56393
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56394

lab56393:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56394:

lab56395:
    jmp lab56397

lab56396:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56397:

lab56399:
    ; #load tag
    mov r15, 5
    ; let x17: List[Vec4] = Cons(x18, x23);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56411
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab56412

lab56411:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56409
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56402
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56400
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56401

lab56400:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56401:

lab56402:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56405
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56403
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56404

lab56403:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56404:

lab56405:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56408
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56406
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56407

lab56406:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56407:

lab56408:
    jmp lab56410

lab56409:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56410:

lab56412:
    ; #load tag
    mov r13, 5
    ; let x11: List[Vec4] = Cons(x12, x17);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56424
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab56425

lab56424:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56422
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56415
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56413
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56414

lab56413:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56414:

lab56415:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56418
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56416
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56417

lab56416:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56417:

lab56418:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56421
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56419
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56420

lab56419:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56420:

lab56421:
    jmp lab56423

lab56422:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56423:

lab56425:
    ; #load tag
    mov r11, 5
    ; let x5: List[Vec4] = Cons(x6, x11);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56437
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab56438

lab56437:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56435
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56428
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56426
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56427

lab56426:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56427:

lab56428:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56431
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56429
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56430

lab56429:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56430:

lab56431:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56434
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56432
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56433

lab56432:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56433:

lab56434:
    jmp lab56436

lab56435:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56436:

lab56438:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x5 !-> x5)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

q_tile_:
    ; lit x1 <- 0;
    mov rdi, 0
    ; lit x2 <- 8;
    mov r9, 8
    ; lit x3 <- 4;
    mov r11, 4
    ; lit x4 <- 7;
    mov r13, 7
    ; let x0: Vec4 = Vec4(x1, x2, x3, x4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56450
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab56451

lab56450:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56448
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56441
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56439
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56440

lab56439:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56440:

lab56441:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56444
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56442
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56443

lab56442:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56443:

lab56444:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56447
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56445
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56446

lab56445:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56446:

lab56447:
    jmp lab56449

lab56448:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56449:

lab56451:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56463
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab56464

lab56463:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56461
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56454
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56452
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56453

lab56452:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56453:

lab56454:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56457
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56455
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56456

lab56455:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56456:

lab56457:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56460
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56458
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56459

lab56458:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56459:

lab56460:
    jmp lab56462

lab56461:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56462:

lab56464:
    ; #load tag
    mov rdi, 0
    ; lit x7 <- 4;
    mov r9, 4
    ; lit x8 <- 7;
    mov r11, 7
    ; lit x9 <- 6;
    mov r13, 6
    ; lit x10 <- 7;
    mov r15, 7
    ; let x6: Vec4 = Vec4(x7, x8, x9, x10);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    mov [rbx + 24], r11
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56476
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab56477

lab56476:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56474
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56467
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56465
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56466

lab56465:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56466:

lab56467:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56470
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56468
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56469

lab56468:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56469:

lab56470:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56473
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56471
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56472

lab56471:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56472:

lab56473:
    jmp lab56475

lab56474:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56475:

lab56477:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56489
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab56490

lab56489:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56487
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56480
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56478
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56479

lab56478:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56479:

lab56480:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56483
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56481
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56482

lab56481:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56482:

lab56483:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56486
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56484
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56485

lab56484:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56485:

lab56486:
    jmp lab56488

lab56487:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56488:

lab56490:
    ; #load tag
    mov r9, 0
    ; lit x13 <- 6;
    mov r11, 6
    ; lit x14 <- 7;
    mov r13, 7
    ; lit x15 <- 8;
    mov r15, 8
    ; lit x16 <- 8;
    mov qword [rsp + 2024], 8
    ; let x12: Vec4 = Vec4(x13, x14, x15, x16);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov [rbx + 40], r15
    mov qword [rbx + 32], 0
    mov [rbx + 24], r13
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56502
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab56503

lab56502:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56500
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56493
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56491
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56492

lab56491:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56492:

lab56493:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56496
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56494
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56495

lab56494:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56495:

lab56496:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56499
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56497
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56498

lab56497:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56498:

lab56499:
    jmp lab56501

lab56500:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56501:

lab56503:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56515
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab56516

lab56515:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56513
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56506
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56504
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56505

lab56504:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56505:

lab56506:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56509
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56507
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56508

lab56507:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56508:

lab56509:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56512
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56510
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56511

lab56510:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56511:

lab56512:
    jmp lab56514

lab56513:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56514:

lab56516:
    ; #load tag
    mov r11, 0
    ; lit x19 <- 8;
    mov r13, 8
    ; lit x20 <- 8;
    mov r15, 8
    ; lit x21 <- 12;
    mov qword [rsp + 2024], 12
    ; lit x22 <- 10;
    mov qword [rsp + 2008], 10
    ; let x18: Vec4 = Vec4(x19, x20, x21, x22);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov [rbx + 24], r15
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56528
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab56529

lab56528:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56526
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56519
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56517
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56518

lab56517:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56518:

lab56519:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56522
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56520
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56521

lab56520:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56521:

lab56522:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56525
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56523
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56524

lab56523:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56524:

lab56525:
    jmp lab56527

lab56526:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56527:

lab56529:
    ; ##store link to previous block
    mov [rbx + 48], r14
    ; ##store values
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56541
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab56542

lab56541:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56539
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56532
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56530
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56531

lab56530:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56531:

lab56532:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56535
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56533
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56534

lab56533:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56534:

lab56535:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56538
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56536
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56537

lab56536:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56537:

lab56538:
    jmp lab56540

lab56539:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56540:

lab56542:
    ; #load tag
    mov r13, 0
    ; lit x25 <- 12;
    mov r15, 12
    ; lit x26 <- 10;
    mov qword [rsp + 2024], 10
    ; lit x27 <- 16;
    mov qword [rsp + 2008], 16
    ; lit x28 <- 16;
    mov qword [rsp + 1992], 16
    ; let x24: Vec4 = Vec4(x25, x26, x27, x28);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56554
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56555

lab56554:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56552
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56545
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56543
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56544

lab56543:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56544:

lab56545:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56548
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56546
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56547

lab56546:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56547:

lab56548:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56551
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56549
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56550

lab56549:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56550:

lab56551:
    jmp lab56553

lab56552:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56553:

lab56555:
    ; ##store link to previous block
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    ; ##store values
    mov [rbx + 40], r15
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56567
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab56568

lab56567:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56565
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56558
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56556
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56557

lab56556:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56557:

lab56558:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56561
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56559
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56560

lab56559:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56560:

lab56561:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56564
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56562
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56563

lab56562:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56563:

lab56564:
    jmp lab56566

lab56565:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56566:

lab56568:
    ; #load tag
    mov r15, 0
    ; lit x31 <- 0;
    mov qword [rsp + 2024], 0
    ; lit x32 <- 12;
    mov qword [rsp + 2008], 12
    ; lit x33 <- 3;
    mov qword [rsp + 1992], 3
    ; lit x34 <- 13;
    mov qword [rsp + 1976], 13
    ; let x30: Vec4 = Vec4(x31, x32, x33, x34);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 2008]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56580
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56581

lab56580:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56578
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56571
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56569
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56570

lab56569:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56570:

lab56571:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56574
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56572
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56573

lab56572:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56573:

lab56574:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56577
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56575
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56576

lab56575:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56576:

lab56577:
    jmp lab56579

lab56578:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56579:

lab56581:
    ; ##store link to previous block
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56593
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56594

lab56593:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56591
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56584
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56582
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56583

lab56582:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56583:

lab56584:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56587
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56585
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56586

lab56585:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56586:

lab56587:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56590
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56588
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56589

lab56588:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56589:

lab56590:
    jmp lab56592

lab56591:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56592:

lab56594:
    ; #load tag
    mov qword [rsp + 2024], 0
    ; lit x37 <- 3;
    mov qword [rsp + 2008], 3
    ; lit x38 <- 13;
    mov qword [rsp + 1992], 13
    ; lit x39 <- 5;
    mov qword [rsp + 1976], 5
    ; lit x40 <- 14;
    mov qword [rsp + 1960], 14
    ; let x36: Vec4 = Vec4(x37, x38, x39, x40);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56606
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56607

lab56606:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56604
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56597
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56595
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56596

lab56595:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56596:

lab56597:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56600
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56598
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56599

lab56598:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56599:

lab56600:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56603
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56601
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56602

lab56601:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56602:

lab56603:
    jmp lab56605

lab56604:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56605:

lab56607:
    ; ##store link to previous block
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56619
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56620

lab56619:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56617
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56610
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56608
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56609

lab56608:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56609:

lab56610:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56613
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56611
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56612

lab56611:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56612:

lab56613:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56616
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56614
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56615

lab56614:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56615:

lab56616:
    jmp lab56618

lab56617:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56618:

lab56620:
    ; #load tag
    mov qword [rsp + 2008], 0
    ; lit x43 <- 5;
    mov qword [rsp + 1992], 5
    ; lit x44 <- 14;
    mov qword [rsp + 1976], 14
    ; lit x45 <- 7;
    mov qword [rsp + 1960], 7
    ; lit x46 <- 15;
    mov qword [rsp + 1944], 15
    ; let x42: Vec4 = Vec4(x43, x44, x45, x46);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1976]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56632
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56633

lab56632:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56630
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56623
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56621
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56622

lab56621:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56622:

lab56623:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56626
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56624
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56625

lab56624:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56625:

lab56626:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56629
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56627
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56628

lab56627:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56628:

lab56629:
    jmp lab56631

lab56630:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56631:

lab56633:
    ; ##store link to previous block
    mov rcx, [rsp + 1984]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56645
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56646

lab56645:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56643
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56636
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56634
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56635

lab56634:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56635:

lab56636:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56639
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56637
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56638

lab56637:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56638:

lab56639:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56642
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56640
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56641

lab56640:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56641:

lab56642:
    jmp lab56644

lab56643:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56644:

lab56646:
    ; #load tag
    mov qword [rsp + 1992], 0
    ; lit x49 <- 7;
    mov qword [rsp + 1976], 7
    ; lit x50 <- 15;
    mov qword [rsp + 1960], 15
    ; lit x51 <- 8;
    mov qword [rsp + 1944], 8
    ; lit x52 <- 16;
    mov qword [rsp + 1928], 16
    ; let x48: Vec4 = Vec4(x49, x50, x51, x52);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1960]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56658
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56659

lab56658:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56656
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56649
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56647
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56648

lab56647:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56648:

lab56649:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56652
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56650
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56651

lab56650:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56651:

lab56652:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56655
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56653
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56654

lab56653:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56654:

lab56655:
    jmp lab56657

lab56656:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56657:

lab56659:
    ; ##store link to previous block
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56671
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56672

lab56671:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56669
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56662
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56660
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56661

lab56660:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56661:

lab56662:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56665
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56663
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56664

lab56663:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56664:

lab56665:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56668
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56666
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56667

lab56666:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56667:

lab56668:
    jmp lab56670

lab56669:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56670:

lab56672:
    ; #load tag
    mov qword [rsp + 1976], 0
    ; lit x55 <- 2;
    mov qword [rsp + 1960], 2
    ; lit x56 <- 16;
    mov qword [rsp + 1944], 16
    ; lit x57 <- 3;
    mov qword [rsp + 1928], 3
    ; lit x58 <- 13;
    mov qword [rsp + 1912], 13
    ; let x54: Vec4 = Vec4(x55, x56, x57, x58);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1912]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1928]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1944]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1952], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56684
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56685

lab56684:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56682
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56675
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56673
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56674

lab56673:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56674:

lab56675:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56678
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56676
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56677

lab56676:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56677:

lab56678:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56681
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56679
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56680

lab56679:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56680:

lab56681:
    jmp lab56683

lab56682:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56683:

lab56685:
    ; ##store link to previous block
    mov rcx, [rsp + 1952]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56697
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56698

lab56697:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56695
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56688
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56686
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56687

lab56686:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56687:

lab56688:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56691
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56689
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56690

lab56689:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56690:

lab56691:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56694
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56692
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56693

lab56692:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56693:

lab56694:
    jmp lab56696

lab56695:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56696:

lab56698:
    ; #load tag
    mov qword [rsp + 1960], 0
    ; lit x61 <- 4;
    mov qword [rsp + 1944], 4
    ; lit x62 <- 16;
    mov qword [rsp + 1928], 16
    ; lit x63 <- 5;
    mov qword [rsp + 1912], 5
    ; lit x64 <- 14;
    mov qword [rsp + 1896], 14
    ; let x60: Vec4 = Vec4(x61, x62, x63, x64);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1928]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56710
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56711

lab56710:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56708
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56701
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56699
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56700

lab56699:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56700:

lab56701:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56704
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56702
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56703

lab56702:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56703:

lab56704:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56707
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56705
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56706

lab56705:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56706:

lab56707:
    jmp lab56709

lab56708:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56709:

lab56711:
    ; ##store link to previous block
    mov rcx, [rsp + 1936]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1952], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56723
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56724

lab56723:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56721
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56714
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56712
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56713

lab56712:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56713:

lab56714:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56717
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56715
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56716

lab56715:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56716:

lab56717:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56720
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56718
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56719

lab56718:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56719:

lab56720:
    jmp lab56722

lab56721:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56722:

lab56724:
    ; #load tag
    mov qword [rsp + 1944], 0
    ; lit x67 <- 6;
    mov qword [rsp + 1928], 6
    ; lit x68 <- 16;
    mov qword [rsp + 1912], 16
    ; lit x69 <- 7;
    mov qword [rsp + 1896], 7
    ; lit x70 <- 15;
    mov qword [rsp + 1880], 15
    ; let x66: Vec4 = Vec4(x67, x68, x69, x70);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1880]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1896]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1912]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1920], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56736
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56737

lab56736:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56734
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56727
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56725
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56726

lab56725:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56726:

lab56727:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56730
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56728
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56729

lab56728:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56729:

lab56730:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56733
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56731
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56732

lab56731:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56732:

lab56733:
    jmp lab56735

lab56734:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56735:

lab56737:
    ; ##store link to previous block
    mov rcx, [rsp + 1920]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56749
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56750

lab56749:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56747
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56740
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56738
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56739

lab56738:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56739:

lab56740:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56743
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56741
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56742

lab56741:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56742:

lab56743:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56746
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56744
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56745

lab56744:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56745:

lab56746:
    jmp lab56748

lab56747:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56748:

lab56750:
    ; #load tag
    mov qword [rsp + 1928], 0
    ; lit x73 <- 0;
    mov qword [rsp + 1912], 0
    ; lit x74 <- 10;
    mov qword [rsp + 1896], 10
    ; lit x75 <- 7;
    mov qword [rsp + 1880], 7
    ; lit x76 <- 11;
    mov qword [rsp + 1864], 11
    ; let x72: Vec4 = Vec4(x73, x74, x75, x76);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1864]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1880]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1896]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1904], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56762
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56763

lab56762:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56760
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56753
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56751
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56752

lab56751:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56752:

lab56753:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56756
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56754
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56755

lab56754:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56755:

lab56756:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56759
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56757
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56758

lab56757:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56758:

lab56759:
    jmp lab56761

lab56760:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56761:

lab56763:
    ; ##store link to previous block
    mov rcx, [rsp + 1904]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1920], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56775
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56776

lab56775:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56773
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56766
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56764
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56765

lab56764:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56765:

lab56766:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56769
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56767
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56768

lab56767:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56768:

lab56769:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56772
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56770
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56771

lab56770:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56771:

lab56772:
    jmp lab56774

lab56773:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56774:

lab56776:
    ; #load tag
    mov qword [rsp + 1912], 0
    ; lit x79 <- 9;
    mov qword [rsp + 1896], 9
    ; lit x80 <- 13;
    mov qword [rsp + 1880], 13
    ; lit x81 <- 8;
    mov qword [rsp + 1864], 8
    ; lit x82 <- 15;
    mov qword [rsp + 1848], 15
    ; let x78: Vec4 = Vec4(x79, x80, x81, x82);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1848]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1864]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1880]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1888], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56788
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56789

lab56788:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56786
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56779
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56777
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56778

lab56777:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56778:

lab56779:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56782
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56780
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56781

lab56780:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56781:

lab56782:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56785
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56783
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56784

lab56783:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56784:

lab56785:
    jmp lab56787

lab56786:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56787:

lab56789:
    ; ##store link to previous block
    mov rcx, [rsp + 1888]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1904], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56801
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56802

lab56801:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56799
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56792
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56790
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56791

lab56790:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56791:

lab56792:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56795
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56793
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56794

lab56793:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56794:

lab56795:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56798
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56796
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56797

lab56796:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56797:

lab56798:
    jmp lab56800

lab56799:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56800:

lab56802:
    ; #load tag
    mov qword [rsp + 1896], 0
    ; lit x85 <- 8;
    mov qword [rsp + 1880], 8
    ; lit x86 <- 15;
    mov qword [rsp + 1864], 15
    ; lit x87 <- 11;
    mov qword [rsp + 1848], 11
    ; lit x88 <- 15;
    mov qword [rsp + 1832], 15
    ; let x84: Vec4 = Vec4(x85, x86, x87, x88);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1832]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1848]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1864]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1872], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56814
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56815

lab56814:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56812
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56805
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56803
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56804

lab56803:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56804:

lab56805:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56808
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56806
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56807

lab56806:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56807:

lab56808:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56811
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56809
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56810

lab56809:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56810:

lab56811:
    jmp lab56813

lab56812:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56813:

lab56815:
    ; ##store link to previous block
    mov rcx, [rsp + 1872]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1880]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1888], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56827
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56828

lab56827:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56825
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56818
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56816
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56817

lab56816:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56817:

lab56818:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56821
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56819
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56820

lab56819:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56820:

lab56821:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56824
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56822
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56823

lab56822:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56823:

lab56824:
    jmp lab56826

lab56825:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56826:

lab56828:
    ; #load tag
    mov qword [rsp + 1880], 0
    ; lit x91 <- 11;
    mov qword [rsp + 1864], 11
    ; lit x92 <- 15;
    mov qword [rsp + 1848], 15
    ; lit x93 <- 9;
    mov qword [rsp + 1832], 9
    ; lit x94 <- 13;
    mov qword [rsp + 1816], 13
    ; let x90: Vec4 = Vec4(x91, x92, x93, x94);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1816]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1832]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1848]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1856], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56840
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56841

lab56840:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56838
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56831
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56829
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56830

lab56829:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56830:

lab56831:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56834
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56832
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56833

lab56832:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56833:

lab56834:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56837
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56835
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56836

lab56835:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56836:

lab56837:
    jmp lab56839

lab56838:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56839:

lab56841:
    ; ##store link to previous block
    mov rcx, [rsp + 1856]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1864]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1872], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56853
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56854

lab56853:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56851
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56844
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56842
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56843

lab56842:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56843:

lab56844:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56847
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56845
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56846

lab56845:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56846:

lab56847:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56850
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56848
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56849

lab56848:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56849:

lab56850:
    jmp lab56852

lab56851:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56852:

lab56854:
    ; #load tag
    mov qword [rsp + 1864], 0
    ; lit x97 <- 10;
    mov qword [rsp + 1848], 10
    ; lit x98 <- 10;
    mov qword [rsp + 1832], 10
    ; lit x99 <- 8;
    mov qword [rsp + 1816], 8
    ; lit x100 <- 12;
    mov qword [rsp + 1800], 12
    ; let x96: Vec4 = Vec4(x97, x98, x99, x100);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1800]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1816]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1832]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1840], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56866
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56867

lab56866:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56864
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56857
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56855
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56856

lab56855:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56856:

lab56857:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56860
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56858
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56859

lab56858:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56859:

lab56860:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56863
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56861
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56862

lab56861:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56862:

lab56863:
    jmp lab56865

lab56864:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56865:

lab56867:
    ; ##store link to previous block
    mov rcx, [rsp + 1840]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1848]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1856], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56879
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56880

lab56879:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56877
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56870
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56868
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56869

lab56868:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56869:

lab56870:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56873
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56871
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56872

lab56871:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56872:

lab56873:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56876
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56874
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56875

lab56874:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56875:

lab56876:
    jmp lab56878

lab56877:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56878:

lab56880:
    ; #load tag
    mov qword [rsp + 1848], 0
    ; lit x103 <- 8;
    mov qword [rsp + 1832], 8
    ; lit x104 <- 12;
    mov qword [rsp + 1816], 12
    ; lit x105 <- 12;
    mov qword [rsp + 1800], 12
    ; lit x106 <- 12;
    mov qword [rsp + 1784], 12
    ; let x102: Vec4 = Vec4(x103, x104, x105, x106);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1784]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1800]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1816]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1824], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56892
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56893

lab56892:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56890
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56883
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56881
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56882

lab56881:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56882:

lab56883:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56886
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56884
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56885

lab56884:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56885:

lab56886:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56889
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56887
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56888

lab56887:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56888:

lab56889:
    jmp lab56891

lab56890:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56891:

lab56893:
    ; ##store link to previous block
    mov rcx, [rsp + 1824]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1832]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1840], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56905
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56906

lab56905:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56903
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56896
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56894
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56895

lab56894:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56895:

lab56896:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56899
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56897
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56898

lab56897:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56898:

lab56899:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56902
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56900
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56901

lab56900:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56901:

lab56902:
    jmp lab56904

lab56903:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56904:

lab56906:
    ; #load tag
    mov qword [rsp + 1832], 0
    ; lit x109 <- 12;
    mov qword [rsp + 1816], 12
    ; lit x110 <- 12;
    mov qword [rsp + 1800], 12
    ; lit x111 <- 10;
    mov qword [rsp + 1784], 10
    ; lit x112 <- 10;
    mov qword [rsp + 1768], 10
    ; let x108: Vec4 = Vec4(x109, x110, x111, x112);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1768]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1784]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1800]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1808], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56918
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56919

lab56918:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56916
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56909
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56907
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56908

lab56907:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56908:

lab56909:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56912
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56910
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56911

lab56910:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56911:

lab56912:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56915
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56913
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56914

lab56913:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56914:

lab56915:
    jmp lab56917

lab56916:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56917:

lab56919:
    ; ##store link to previous block
    mov rcx, [rsp + 1808]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1816]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1824], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56931
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56932

lab56931:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56929
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56922
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56920
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56921

lab56920:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56921:

lab56922:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56925
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56923
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56924

lab56923:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56924:

lab56925:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56928
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56926
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56927

lab56926:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56927:

lab56928:
    jmp lab56930

lab56929:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56930:

lab56932:
    ; #load tag
    mov qword [rsp + 1816], 0
    ; lit x115 <- 2;
    mov qword [rsp + 1800], 2
    ; lit x116 <- 0;
    mov qword [rsp + 1784], 0
    ; lit x117 <- 4;
    mov qword [rsp + 1768], 4
    ; lit x118 <- 5;
    mov qword [rsp + 1752], 5
    ; let x114: Vec4 = Vec4(x115, x116, x117, x118);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1752]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1768]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1784]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1792], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56944
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56945

lab56944:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56942
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56935
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56933
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56934

lab56933:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56934:

lab56935:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56938
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56936
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56937

lab56936:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56937:

lab56938:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56941
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56939
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56940

lab56939:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56940:

lab56941:
    jmp lab56943

lab56942:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56943:

lab56945:
    ; ##store link to previous block
    mov rcx, [rsp + 1792]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1800]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1808], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56957
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56958

lab56957:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56955
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56948
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56946
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56947

lab56946:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56947:

lab56948:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56951
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56949
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56950

lab56949:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56950:

lab56951:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56954
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56952
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56953

lab56952:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56953:

lab56954:
    jmp lab56956

lab56955:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56956:

lab56958:
    ; #load tag
    mov qword [rsp + 1800], 0
    ; lit x121 <- 4;
    mov qword [rsp + 1784], 4
    ; lit x122 <- 5;
    mov qword [rsp + 1768], 5
    ; lit x123 <- 4;
    mov qword [rsp + 1752], 4
    ; lit x124 <- 7;
    mov qword [rsp + 1736], 7
    ; let x120: Vec4 = Vec4(x121, x122, x123, x124);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1736]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1752]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1768]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1776], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56970
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56971

lab56970:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56968
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56961
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56959
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56960

lab56959:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56960:

lab56961:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56964
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56962
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56963

lab56962:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56963:

lab56964:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56967
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56965
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56966

lab56965:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56966:

lab56967:
    jmp lab56969

lab56968:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56969:

lab56971:
    ; ##store link to previous block
    mov rcx, [rsp + 1776]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1784]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1792], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56983
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56984

lab56983:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56981
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56974
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56972
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56973

lab56972:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56973:

lab56974:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56977
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56975
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56976

lab56975:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56976:

lab56977:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56980
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56978
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56979

lab56978:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56979:

lab56980:
    jmp lab56982

lab56981:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56982:

lab56984:
    ; #load tag
    mov qword [rsp + 1784], 0
    ; lit x127 <- 4;
    mov qword [rsp + 1768], 4
    ; lit x128 <- 0;
    mov qword [rsp + 1752], 0
    ; lit x129 <- 6;
    mov qword [rsp + 1736], 6
    ; lit x130 <- 5;
    mov qword [rsp + 1720], 5
    ; let x126: Vec4 = Vec4(x127, x128, x129, x130);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1720]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1736]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1752]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1760], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab56996
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab56997

lab56996:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab56994
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab56987
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56985
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56986

lab56985:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56986:

lab56987:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab56990
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56988
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56989

lab56988:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56989:

lab56990:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab56993
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56991
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56992

lab56991:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56992:

lab56993:
    jmp lab56995

lab56994:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab56995:

lab56997:
    ; ##store link to previous block
    mov rcx, [rsp + 1760]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1768]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1776], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57009
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57010

lab57009:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57007
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57000
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab56998
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab56999

lab56998:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab56999:

lab57000:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57003
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57001
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57002

lab57001:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57002:

lab57003:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57006
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57004
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57005

lab57004:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57005:

lab57006:
    jmp lab57008

lab57007:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57008:

lab57010:
    ; #load tag
    mov qword [rsp + 1768], 0
    ; lit x133 <- 6;
    mov qword [rsp + 1752], 6
    ; lit x134 <- 5;
    mov qword [rsp + 1736], 5
    ; lit x135 <- 6;
    mov qword [rsp + 1720], 6
    ; lit x136 <- 7;
    mov qword [rsp + 1704], 7
    ; let x132: Vec4 = Vec4(x133, x134, x135, x136);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1704]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1720]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1736]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1744], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57022
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57023

lab57022:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57020
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57013
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57011
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57012

lab57011:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57012:

lab57013:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57016
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57014
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57015

lab57014:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57015:

lab57016:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57019
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57017
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57018

lab57017:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57018:

lab57019:
    jmp lab57021

lab57020:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57021:

lab57023:
    ; ##store link to previous block
    mov rcx, [rsp + 1744]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1752]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1760], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57035
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57036

lab57035:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57033
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57026
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57024
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57025

lab57024:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57025:

lab57026:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57029
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57027
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57028

lab57027:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57028:

lab57029:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57032
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57030
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57031

lab57030:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57031:

lab57032:
    jmp lab57034

lab57033:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57034:

lab57036:
    ; #load tag
    mov qword [rsp + 1752], 0
    ; lit x139 <- 6;
    mov qword [rsp + 1736], 6
    ; lit x140 <- 0;
    mov qword [rsp + 1720], 0
    ; lit x141 <- 8;
    mov qword [rsp + 1704], 8
    ; lit x142 <- 5;
    mov qword [rsp + 1688], 5
    ; let x138: Vec4 = Vec4(x139, x140, x141, x142);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1688]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1704]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1720]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1728], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57048
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57049

lab57048:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57046
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57039
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57037
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57038

lab57037:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57038:

lab57039:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57042
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57040
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57041

lab57040:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57041:

lab57042:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57045
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57043
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57044

lab57043:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57044:

lab57045:
    jmp lab57047

lab57046:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57047:

lab57049:
    ; ##store link to previous block
    mov rcx, [rsp + 1728]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1736]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1744], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57061
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57062

lab57061:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57059
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57052
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57050
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57051

lab57050:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57051:

lab57052:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57055
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57053
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57054

lab57053:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57054:

lab57055:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57058
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57056
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57057

lab57056:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57057:

lab57058:
    jmp lab57060

lab57059:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57060:

lab57062:
    ; #load tag
    mov qword [rsp + 1736], 0
    ; lit x145 <- 8;
    mov qword [rsp + 1720], 8
    ; lit x146 <- 5;
    mov qword [rsp + 1704], 5
    ; lit x147 <- 8;
    mov qword [rsp + 1688], 8
    ; lit x148 <- 8;
    mov qword [rsp + 1672], 8
    ; let x144: Vec4 = Vec4(x145, x146, x147, x148);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1672]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1688]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1704]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1712], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57074
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57075

lab57074:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57072
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57065
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57063
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57064

lab57063:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57064:

lab57065:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57068
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57066
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57067

lab57066:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57067:

lab57068:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57071
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57069
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57070

lab57069:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57070:

lab57071:
    jmp lab57073

lab57072:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57073:

lab57075:
    ; ##store link to previous block
    mov rcx, [rsp + 1712]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1720]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1728], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57087
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57088

lab57087:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57085
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57078
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57076
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57077

lab57076:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57077:

lab57078:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57081
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57079
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57080

lab57079:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57080:

lab57081:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57084
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57082
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57083

lab57082:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57083:

lab57084:
    jmp lab57086

lab57085:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57086:

lab57088:
    ; #load tag
    mov qword [rsp + 1720], 0
    ; lit x151 <- 10;
    mov qword [rsp + 1704], 10
    ; lit x152 <- 0;
    mov qword [rsp + 1688], 0
    ; lit x153 <- 14;
    mov qword [rsp + 1672], 14
    ; lit x154 <- 11;
    mov qword [rsp + 1656], 11
    ; let x150: Vec4 = Vec4(x151, x152, x153, x154);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1656]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1672]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1688]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1696], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57100
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57101

lab57100:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57098
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57091
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57089
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57090

lab57089:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57090:

lab57091:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57094
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57092
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57093

lab57092:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57093:

lab57094:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57097
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57095
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57096

lab57095:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57096:

lab57097:
    jmp lab57099

lab57098:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57099:

lab57101:
    ; ##store link to previous block
    mov rcx, [rsp + 1696]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1704]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1712], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57113
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57114

lab57113:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57111
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57104
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57102
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57103

lab57102:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57103:

lab57104:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57107
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57105
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57106

lab57105:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57106:

lab57107:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57110
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57108
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57109

lab57108:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57109:

lab57110:
    jmp lab57112

lab57111:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57112:

lab57114:
    ; #load tag
    mov qword [rsp + 1704], 0
    ; lit x157 <- 12;
    mov qword [rsp + 1688], 12
    ; lit x158 <- 0;
    mov qword [rsp + 1672], 0
    ; lit x159 <- 13;
    mov qword [rsp + 1656], 13
    ; lit x160 <- 4;
    mov qword [rsp + 1640], 4
    ; let x156: Vec4 = Vec4(x157, x158, x159, x160);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1640]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1656]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1672]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1680], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57126
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57127

lab57126:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57124
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57117
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57115
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57116

lab57115:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57116:

lab57117:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57120
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57118
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57119

lab57118:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57119:

lab57120:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57123
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57121
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57122

lab57121:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57122:

lab57123:
    jmp lab57125

lab57124:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57125:

lab57127:
    ; ##store link to previous block
    mov rcx, [rsp + 1680]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1688]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1696], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57139
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57140

lab57139:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57137
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57130
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57128
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57129

lab57128:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57129:

lab57130:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57133
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57131
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57132

lab57131:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57132:

lab57133:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57136
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57134
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57135

lab57134:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57135:

lab57136:
    jmp lab57138

lab57137:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57138:

lab57140:
    ; #load tag
    mov qword [rsp + 1688], 0
    ; lit x163 <- 13;
    mov qword [rsp + 1672], 13
    ; lit x164 <- 4;
    mov qword [rsp + 1656], 4
    ; lit x165 <- 16;
    mov qword [rsp + 1640], 16
    ; lit x166 <- 8;
    mov qword [rsp + 1624], 8
    ; let x162: Vec4 = Vec4(x163, x164, x165, x166);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1624]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1640]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1656]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1664], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57152
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57153

lab57152:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57150
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57143
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57141
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57142

lab57141:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57142:

lab57143:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57146
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57144
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57145

lab57144:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57145:

lab57146:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57149
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57147
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57148

lab57147:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57148:

lab57149:
    jmp lab57151

lab57150:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57151:

lab57153:
    ; ##store link to previous block
    mov rcx, [rsp + 1664]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1672]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1680], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57165
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57166

lab57165:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57163
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57156
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57154
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57155

lab57154:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57155:

lab57156:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57159
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57157
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57158

lab57157:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57158:

lab57159:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57162
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57160
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57161

lab57160:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57161:

lab57162:
    jmp lab57164

lab57163:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57164:

lab57166:
    ; #load tag
    mov qword [rsp + 1672], 0
    ; lit x169 <- 16;
    mov qword [rsp + 1656], 16
    ; lit x170 <- 8;
    mov qword [rsp + 1640], 8
    ; lit x171 <- 15;
    mov qword [rsp + 1624], 15
    ; lit x172 <- 10;
    mov qword [rsp + 1608], 10
    ; let x168: Vec4 = Vec4(x169, x170, x171, x172);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1608]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1624]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1640]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1648], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57178
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57179

lab57178:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57176
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57169
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57167
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57168

lab57167:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57168:

lab57169:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57172
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57170
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57171

lab57170:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57171:

lab57172:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57175
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57173
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57174

lab57173:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57174:

lab57175:
    jmp lab57177

lab57176:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57177:

lab57179:
    ; ##store link to previous block
    mov rcx, [rsp + 1648]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1656]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1664], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57191
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57192

lab57191:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57189
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57182
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57180
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57181

lab57180:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57181:

lab57182:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57185
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57183
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57184

lab57183:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57184:

lab57185:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57188
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57186
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57187

lab57186:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57187:

lab57188:
    jmp lab57190

lab57189:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57190:

lab57192:
    ; #load tag
    mov qword [rsp + 1656], 0
    ; lit x175 <- 15;
    mov qword [rsp + 1640], 15
    ; lit x176 <- 10;
    mov qword [rsp + 1624], 10
    ; lit x177 <- 16;
    mov qword [rsp + 1608], 16
    ; lit x178 <- 16;
    mov qword [rsp + 1592], 16
    ; let x174: Vec4 = Vec4(x175, x176, x177, x178);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1592]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1608]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1624]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1632], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57204
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57205

lab57204:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57202
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57195
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57193
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57194

lab57193:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57194:

lab57195:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57198
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57196
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57197

lab57196:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57197:

lab57198:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57201
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57199
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57200

lab57199:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57200:

lab57201:
    jmp lab57203

lab57202:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57203:

lab57205:
    ; ##store link to previous block
    mov rcx, [rsp + 1632]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1640]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1648], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57217
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57218

lab57217:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57215
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57208
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57206
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57207

lab57206:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57207:

lab57208:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57211
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57209
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57210

lab57209:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57210:

lab57211:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57214
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57212
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57213

lab57212:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57213:

lab57214:
    jmp lab57216

lab57215:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57216:

lab57218:
    ; #load tag
    mov qword [rsp + 1640], 0
    ; lit x181 <- 13;
    mov qword [rsp + 1624], 13
    ; lit x182 <- 0;
    mov qword [rsp + 1608], 0
    ; lit x183 <- 16;
    mov qword [rsp + 1592], 16
    ; lit x184 <- 6;
    mov qword [rsp + 1576], 6
    ; let x180: Vec4 = Vec4(x181, x182, x183, x184);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1576]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1592]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1608]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1616], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57230
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57231

lab57230:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57228
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57221
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57219
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57220

lab57219:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57220:

lab57221:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57224
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57222
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57223

lab57222:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57223:

lab57224:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57227
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57225
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57226

lab57225:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57226:

lab57227:
    jmp lab57229

lab57228:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57229:

lab57231:
    ; ##store link to previous block
    mov rcx, [rsp + 1616]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1624]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1632], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57243
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57244

lab57243:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57241
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57234
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57232
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57233

lab57232:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57233:

lab57234:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57237
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57235
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57236

lab57235:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57236:

lab57237:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57240
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57238
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57239

lab57238:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57239:

lab57240:
    jmp lab57242

lab57241:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57242:

lab57244:
    ; #load tag
    mov qword [rsp + 1624], 0
    ; lit x187 <- 14;
    mov qword [rsp + 1608], 14
    ; lit x188 <- 0;
    mov qword [rsp + 1592], 0
    ; lit x189 <- 16;
    mov qword [rsp + 1576], 16
    ; lit x190 <- 4;
    mov qword [rsp + 1560], 4
    ; let x186: Vec4 = Vec4(x187, x188, x189, x190);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1560]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1576]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1592]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1600], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57256
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57257

lab57256:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57254
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57247
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57245
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57246

lab57245:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57246:

lab57247:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57250
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57248
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57249

lab57248:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57249:

lab57250:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57253
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57251
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57252

lab57251:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57252:

lab57253:
    jmp lab57255

lab57254:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57255:

lab57257:
    ; ##store link to previous block
    mov rcx, [rsp + 1600]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1608]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1616], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57269
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57270

lab57269:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57267
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57260
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57258
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57259

lab57258:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57259:

lab57260:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57263
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57261
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57262

lab57261:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57262:

lab57263:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57266
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57264
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57265

lab57264:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57265:

lab57266:
    jmp lab57268

lab57267:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57268:

lab57270:
    ; #load tag
    mov qword [rsp + 1608], 0
    ; lit x193 <- 15;
    mov qword [rsp + 1592], 15
    ; lit x194 <- 0;
    mov qword [rsp + 1576], 0
    ; lit x195 <- 16;
    mov qword [rsp + 1560], 16
    ; lit x196 <- 2;
    mov qword [rsp + 1544], 2
    ; let x192: Vec4 = Vec4(x193, x194, x195, x196);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1544]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1560]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1576]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1584], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57282
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57283

lab57282:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57280
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57273
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57271
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57272

lab57271:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57272:

lab57273:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57276
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57274
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57275

lab57274:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57275:

lab57276:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57279
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57277
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57278

lab57277:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57278:

lab57279:
    jmp lab57281

lab57280:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57281:

lab57283:
    ; ##store link to previous block
    mov rcx, [rsp + 1584]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1592]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1600], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57295
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57296

lab57295:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57293
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57286
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57284
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57285

lab57284:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57285:

lab57286:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57289
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57287
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57288

lab57287:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57288:

lab57289:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57292
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57290
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57291

lab57290:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57291:

lab57292:
    jmp lab57294

lab57293:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57294:

lab57296:
    ; #load tag
    mov qword [rsp + 1592], 0
    ; lit x199 <- 0;
    mov qword [rsp + 1576], 0
    ; lit x200 <- 0;
    mov qword [rsp + 1560], 0
    ; lit x201 <- 8;
    mov qword [rsp + 1544], 8
    ; lit x202 <- 0;
    mov qword [rsp + 1528], 0
    ; let x198: Vec4 = Vec4(x199, x200, x201, x202);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1528]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1544]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1560]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1568], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57308
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57309

lab57308:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57306
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57299
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57297
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57298

lab57297:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57298:

lab57299:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57302
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57300
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57301

lab57300:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57301:

lab57302:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57305
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57303
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57304

lab57303:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57304:

lab57305:
    jmp lab57307

lab57306:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57307:

lab57309:
    ; ##store link to previous block
    mov rcx, [rsp + 1568]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1576]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1584], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57321
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57322

lab57321:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57319
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57312
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57310
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57311

lab57310:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57311:

lab57312:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57315
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57313
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57314

lab57313:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57314:

lab57315:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57318
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57316
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57317

lab57316:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57317:

lab57318:
    jmp lab57320

lab57319:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57320:

lab57322:
    ; #load tag
    mov qword [rsp + 1576], 0
    ; lit x205 <- 12;
    mov qword [rsp + 1560], 12
    ; lit x206 <- 0;
    mov qword [rsp + 1544], 0
    ; lit x207 <- 16;
    mov qword [rsp + 1528], 16
    ; lit x208 <- 0;
    mov qword [rsp + 1512], 0
    ; let x204: Vec4 = Vec4(x205, x206, x207, x208);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1512]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1528]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1544]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1552], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57334
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57335

lab57334:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57332
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57325
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57323
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57324

lab57323:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57324:

lab57325:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57328
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57326
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57327

lab57326:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57327:

lab57328:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57331
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57329
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57330

lab57329:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57330:

lab57331:
    jmp lab57333

lab57332:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57333:

lab57335:
    ; ##store link to previous block
    mov rcx, [rsp + 1552]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1560]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1568], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57347
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57348

lab57347:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57345
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57338
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57336
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57337

lab57336:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57337:

lab57338:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57341
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57339
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57340

lab57339:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57340:

lab57341:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57344
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57342
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57343

lab57342:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57343:

lab57344:
    jmp lab57346

lab57345:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57346:

lab57348:
    ; #load tag
    mov qword [rsp + 1560], 0
    ; lit x211 <- 0;
    mov qword [rsp + 1544], 0
    ; lit x212 <- 0;
    mov qword [rsp + 1528], 0
    ; lit x213 <- 0;
    mov qword [rsp + 1512], 0
    ; lit x214 <- 8;
    mov qword [rsp + 1496], 8
    ; let x210: Vec4 = Vec4(x211, x212, x213, x214);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1496]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1512]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1528]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1536], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57360
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57361

lab57360:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57358
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57351
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57349
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57350

lab57349:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57350:

lab57351:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57354
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57352
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57353

lab57352:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57353:

lab57354:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57357
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57355
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57356

lab57355:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57356:

lab57357:
    jmp lab57359

lab57358:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57359:

lab57361:
    ; ##store link to previous block
    mov rcx, [rsp + 1536]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1544]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1552], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57373
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57374

lab57373:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57371
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57364
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57362
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57363

lab57362:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57363:

lab57364:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57367
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57365
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57366

lab57365:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57366:

lab57367:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57370
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57368
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57369

lab57368:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57369:

lab57370:
    jmp lab57372

lab57371:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57372:

lab57374:
    ; #load tag
    mov qword [rsp + 1544], 0
    ; lit x217 <- 0;
    mov qword [rsp + 1528], 0
    ; lit x218 <- 12;
    mov qword [rsp + 1512], 12
    ; lit x219 <- 0;
    mov qword [rsp + 1496], 0
    ; lit x220 <- 16;
    mov qword [rsp + 1480], 16
    ; let x216: Vec4 = Vec4(x217, x218, x219, x220);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1480]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1496]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1512]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1520], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57386
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57387

lab57386:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57384
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57377
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57375
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57376

lab57375:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57376:

lab57377:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57380
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57378
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57379

lab57378:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57379:

lab57380:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57383
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57381
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57382

lab57381:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57382:

lab57383:
    jmp lab57385

lab57384:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57385:

lab57387:
    ; ##store link to previous block
    mov rcx, [rsp + 1520]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1528]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1536], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57399
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57400

lab57399:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57397
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57390
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57388
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57389

lab57388:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57389:

lab57390:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57393
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57391
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57392

lab57391:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57392:

lab57393:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57396
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57394
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57395

lab57394:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57395:

lab57396:
    jmp lab57398

lab57397:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57398:

lab57400:
    ; #load tag
    mov qword [rsp + 1528], 0
    ; let x221: List[Vec4] = Nil();
    ; #mark no allocation
    mov qword [rsp + 1520], 0
    ; #load tag
    mov qword [rsp + 1512], 0
    ; let x215: List[Vec4] = Cons(x216, x221);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1512]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1520]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1528]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1536]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1536], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57412
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57413

lab57412:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57410
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57403
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57401
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57402

lab57401:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57402:

lab57403:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57406
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57404
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57405

lab57404:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57405:

lab57406:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57409
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57407
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57408

lab57407:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57408:

lab57409:
    jmp lab57411

lab57410:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57411:

lab57413:
    ; #load tag
    mov qword [rsp + 1528], 5
    ; let x209: List[Vec4] = Cons(x210, x215);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1528]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1536]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1544]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1552]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1552], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57425
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57426

lab57425:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57423
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57416
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57414
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57415

lab57414:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57415:

lab57416:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57419
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57417
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57418

lab57417:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57418:

lab57419:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57422
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57420
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57421

lab57420:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57421:

lab57422:
    jmp lab57424

lab57423:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57424:

lab57426:
    ; #load tag
    mov qword [rsp + 1544], 5
    ; let x203: List[Vec4] = Cons(x204, x209);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1544]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1552]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1560]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1568]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1568], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57438
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57439

lab57438:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57436
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57429
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57427
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57428

lab57427:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57428:

lab57429:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57432
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57430
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57431

lab57430:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57431:

lab57432:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57435
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57433
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57434

lab57433:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57434:

lab57435:
    jmp lab57437

lab57436:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57437:

lab57439:
    ; #load tag
    mov qword [rsp + 1560], 5
    ; let x197: List[Vec4] = Cons(x198, x203);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1560]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1568]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1576]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1584]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1584], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57451
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57452

lab57451:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57449
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57442
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57440
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57441

lab57440:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57441:

lab57442:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57445
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57443
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57444

lab57443:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57444:

lab57445:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57448
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57446
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57447

lab57446:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57447:

lab57448:
    jmp lab57450

lab57449:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57450:

lab57452:
    ; #load tag
    mov qword [rsp + 1576], 5
    ; let x191: List[Vec4] = Cons(x192, x197);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1576]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1584]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1592]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1600]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1600], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57464
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57465

lab57464:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57462
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57455
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57453
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57454

lab57453:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57454:

lab57455:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57458
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57456
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57457

lab57456:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57457:

lab57458:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57461
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57459
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57460

lab57459:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57460:

lab57461:
    jmp lab57463

lab57462:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57463:

lab57465:
    ; #load tag
    mov qword [rsp + 1592], 5
    ; let x185: List[Vec4] = Cons(x186, x191);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1592]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1600]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1608]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1616]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1616], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57477
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57478

lab57477:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57475
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57468
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57466
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57467

lab57466:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57467:

lab57468:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57471
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57469
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57470

lab57469:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57470:

lab57471:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57474
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57472
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57473

lab57472:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57473:

lab57474:
    jmp lab57476

lab57475:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57476:

lab57478:
    ; #load tag
    mov qword [rsp + 1608], 5
    ; let x179: List[Vec4] = Cons(x180, x185);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1608]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1616]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1624]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1632]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1632], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57490
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57491

lab57490:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57488
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57481
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57479
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57480

lab57479:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57480:

lab57481:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57484
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57482
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57483

lab57482:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57483:

lab57484:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57487
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57485
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57486

lab57485:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57486:

lab57487:
    jmp lab57489

lab57488:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57489:

lab57491:
    ; #load tag
    mov qword [rsp + 1624], 5
    ; let x173: List[Vec4] = Cons(x174, x179);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1624]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1632]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1640]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1648]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1648], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57503
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57504

lab57503:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57501
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57494
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57492
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57493

lab57492:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57493:

lab57494:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57497
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57495
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57496

lab57495:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57496:

lab57497:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57500
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57498
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57499

lab57498:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57499:

lab57500:
    jmp lab57502

lab57501:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57502:

lab57504:
    ; #load tag
    mov qword [rsp + 1640], 5
    ; let x167: List[Vec4] = Cons(x168, x173);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1640]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1648]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1656]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1664]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1664], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57516
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57517

lab57516:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57514
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57507
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57505
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57506

lab57505:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57506:

lab57507:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57510
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57508
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57509

lab57508:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57509:

lab57510:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57513
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57511
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57512

lab57511:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57512:

lab57513:
    jmp lab57515

lab57514:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57515:

lab57517:
    ; #load tag
    mov qword [rsp + 1656], 5
    ; let x161: List[Vec4] = Cons(x162, x167);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1656]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1664]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1672]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1680]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1680], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57529
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57530

lab57529:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57527
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57520
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57518
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57519

lab57518:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57519:

lab57520:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57523
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57521
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57522

lab57521:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57522:

lab57523:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57526
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57524
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57525

lab57524:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57525:

lab57526:
    jmp lab57528

lab57527:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57528:

lab57530:
    ; #load tag
    mov qword [rsp + 1672], 5
    ; let x155: List[Vec4] = Cons(x156, x161);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1672]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1680]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1688]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1696]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1696], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57542
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57543

lab57542:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57540
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57533
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57531
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57532

lab57531:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57532:

lab57533:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57536
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57534
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57535

lab57534:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57535:

lab57536:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57539
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57537
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57538

lab57537:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57538:

lab57539:
    jmp lab57541

lab57540:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57541:

lab57543:
    ; #load tag
    mov qword [rsp + 1688], 5
    ; let x149: List[Vec4] = Cons(x150, x155);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1688]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1696]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1704]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1712]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1712], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57555
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57556

lab57555:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57553
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57546
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57544
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57545

lab57544:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57545:

lab57546:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57549
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57547
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57548

lab57547:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57548:

lab57549:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57552
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57550
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57551

lab57550:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57551:

lab57552:
    jmp lab57554

lab57553:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57554:

lab57556:
    ; #load tag
    mov qword [rsp + 1704], 5
    ; let x143: List[Vec4] = Cons(x144, x149);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1704]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1712]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1720]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1728]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1728], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57568
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57569

lab57568:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57566
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57559
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57557
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57558

lab57557:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57558:

lab57559:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57562
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57560
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57561

lab57560:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57561:

lab57562:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57565
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57563
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57564

lab57563:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57564:

lab57565:
    jmp lab57567

lab57566:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57567:

lab57569:
    ; #load tag
    mov qword [rsp + 1720], 5
    ; let x137: List[Vec4] = Cons(x138, x143);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1720]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1728]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1736]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1744]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1744], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57581
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57582

lab57581:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57579
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57572
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57570
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57571

lab57570:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57571:

lab57572:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57575
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57573
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57574

lab57573:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57574:

lab57575:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57578
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57576
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57577

lab57576:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57577:

lab57578:
    jmp lab57580

lab57579:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57580:

lab57582:
    ; #load tag
    mov qword [rsp + 1736], 5
    ; let x131: List[Vec4] = Cons(x132, x137);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1736]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1744]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1752]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1760]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1760], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57594
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57595

lab57594:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57592
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57585
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57583
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57584

lab57583:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57584:

lab57585:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57588
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57586
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57587

lab57586:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57587:

lab57588:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57591
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57589
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57590

lab57589:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57590:

lab57591:
    jmp lab57593

lab57592:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57593:

lab57595:
    ; #load tag
    mov qword [rsp + 1752], 5
    ; let x125: List[Vec4] = Cons(x126, x131);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1752]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1760]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1768]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1776]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1776], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57607
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57608

lab57607:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57605
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57598
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57596
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57597

lab57596:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57597:

lab57598:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57601
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57599
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57600

lab57599:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57600:

lab57601:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57604
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57602
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57603

lab57602:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57603:

lab57604:
    jmp lab57606

lab57605:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57606:

lab57608:
    ; #load tag
    mov qword [rsp + 1768], 5
    ; let x119: List[Vec4] = Cons(x120, x125);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1768]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1776]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1784]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1792]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1792], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57620
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57621

lab57620:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57618
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57611
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57609
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57610

lab57609:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57610:

lab57611:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57614
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57612
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57613

lab57612:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57613:

lab57614:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57617
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57615
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57616

lab57615:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57616:

lab57617:
    jmp lab57619

lab57618:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57619:

lab57621:
    ; #load tag
    mov qword [rsp + 1784], 5
    ; let x113: List[Vec4] = Cons(x114, x119);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1784]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1792]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1800]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1808]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1808], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57633
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57634

lab57633:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57631
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57624
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57622
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57623

lab57622:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57623:

lab57624:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57627
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57625
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57626

lab57625:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57626:

lab57627:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57630
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57628
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57629

lab57628:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57629:

lab57630:
    jmp lab57632

lab57631:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57632:

lab57634:
    ; #load tag
    mov qword [rsp + 1800], 5
    ; let x107: List[Vec4] = Cons(x108, x113);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1800]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1808]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1816]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1824]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1824], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57646
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57647

lab57646:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57644
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57637
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57635
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57636

lab57635:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57636:

lab57637:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57640
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57638
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57639

lab57638:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57639:

lab57640:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57643
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57641
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57642

lab57641:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57642:

lab57643:
    jmp lab57645

lab57644:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57645:

lab57647:
    ; #load tag
    mov qword [rsp + 1816], 5
    ; let x101: List[Vec4] = Cons(x102, x107);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1816]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1824]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1832]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1840]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1840], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57659
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57660

lab57659:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57657
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57650
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57648
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57649

lab57648:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57649:

lab57650:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57653
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57651
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57652

lab57651:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57652:

lab57653:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57656
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57654
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57655

lab57654:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57655:

lab57656:
    jmp lab57658

lab57657:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57658:

lab57660:
    ; #load tag
    mov qword [rsp + 1832], 5
    ; let x95: List[Vec4] = Cons(x96, x101);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1832]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1840]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1848]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1856]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1856], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57672
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57673

lab57672:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57670
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57663
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57661
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57662

lab57661:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57662:

lab57663:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57666
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57664
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57665

lab57664:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57665:

lab57666:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57669
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57667
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57668

lab57667:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57668:

lab57669:
    jmp lab57671

lab57670:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57671:

lab57673:
    ; #load tag
    mov qword [rsp + 1848], 5
    ; let x89: List[Vec4] = Cons(x90, x95);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1848]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1856]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1864]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1872]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1872], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57685
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57686

lab57685:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57683
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57676
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57674
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57675

lab57674:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57675:

lab57676:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57679
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57677
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57678

lab57677:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57678:

lab57679:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57682
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57680
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57681

lab57680:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57681:

lab57682:
    jmp lab57684

lab57683:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57684:

lab57686:
    ; #load tag
    mov qword [rsp + 1864], 5
    ; let x83: List[Vec4] = Cons(x84, x89);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1864]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1872]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1880]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1888]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1888], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57698
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57699

lab57698:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57696
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57689
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57687
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57688

lab57687:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57688:

lab57689:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57692
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57690
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57691

lab57690:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57691:

lab57692:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57695
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57693
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57694

lab57693:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57694:

lab57695:
    jmp lab57697

lab57696:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57697:

lab57699:
    ; #load tag
    mov qword [rsp + 1880], 5
    ; let x77: List[Vec4] = Cons(x78, x83);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1880]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1888]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1896]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1904]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1904], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57711
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57712

lab57711:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57709
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57702
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57700
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57701

lab57700:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57701:

lab57702:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57705
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57703
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57704

lab57703:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57704:

lab57705:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57708
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57706
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57707

lab57706:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57707:

lab57708:
    jmp lab57710

lab57709:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57710:

lab57712:
    ; #load tag
    mov qword [rsp + 1896], 5
    ; let x71: List[Vec4] = Cons(x72, x77);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1904]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1920]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1920], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57724
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57725

lab57724:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57722
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57715
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57713
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57714

lab57713:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57714:

lab57715:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57718
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57716
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57717

lab57716:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57717:

lab57718:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57721
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57719
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57720

lab57719:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57720:

lab57721:
    jmp lab57723

lab57722:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57723:

lab57725:
    ; #load tag
    mov qword [rsp + 1912], 5
    ; let x65: List[Vec4] = Cons(x66, x71);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1912]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1920]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1928]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1936]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57737
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57738

lab57737:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57735
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57728
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57726
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57727

lab57726:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57727:

lab57728:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57731
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57729
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57730

lab57729:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57730:

lab57731:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57734
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57732
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57733

lab57732:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57733:

lab57734:
    jmp lab57736

lab57735:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57736:

lab57738:
    ; #load tag
    mov qword [rsp + 1928], 5
    ; let x59: List[Vec4] = Cons(x60, x65);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1936]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1952]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1952], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57750
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57751

lab57750:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57748
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57741
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57739
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57740

lab57739:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57740:

lab57741:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57744
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57742
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57743

lab57742:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57743:

lab57744:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57747
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57745
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57746

lab57745:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57746:

lab57747:
    jmp lab57749

lab57748:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57749:

lab57751:
    ; #load tag
    mov qword [rsp + 1944], 5
    ; let x53: List[Vec4] = Cons(x54, x59);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1952]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57763
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57764

lab57763:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57761
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57754
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57752
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57753

lab57752:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57753:

lab57754:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57757
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57755
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57756

lab57755:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57756:

lab57757:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57760
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57758
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57759

lab57758:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57759:

lab57760:
    jmp lab57762

lab57761:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57762:

lab57764:
    ; #load tag
    mov qword [rsp + 1960], 5
    ; let x47: List[Vec4] = Cons(x48, x53);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57776
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57777

lab57776:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57774
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57767
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57765
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57766

lab57765:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57766:

lab57767:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57770
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57768
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57769

lab57768:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57769:

lab57770:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57773
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57771
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57772

lab57771:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57772:

lab57773:
    jmp lab57775

lab57774:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57775:

lab57777:
    ; #load tag
    mov qword [rsp + 1976], 5
    ; let x41: List[Vec4] = Cons(x42, x47);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57789
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57790

lab57789:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57787
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57780
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57778
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57779

lab57778:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57779:

lab57780:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57783
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57781
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57782

lab57781:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57782:

lab57783:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57786
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57784
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57785

lab57784:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57785:

lab57786:
    jmp lab57788

lab57787:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57788:

lab57790:
    ; #load tag
    mov qword [rsp + 1992], 5
    ; let x35: List[Vec4] = Cons(x36, x41);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57802
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57803

lab57802:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57800
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57793
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57791
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57792

lab57791:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57792:

lab57793:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57796
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57794
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57795

lab57794:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57795:

lab57796:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57799
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57797
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57798

lab57797:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57798:

lab57799:
    jmp lab57801

lab57800:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57801:

lab57803:
    ; #load tag
    mov qword [rsp + 2008], 5
    ; let x29: List[Vec4] = Cons(x30, x35);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57815
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57816

lab57815:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57813
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57806
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57804
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57805

lab57804:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57805:

lab57806:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57809
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57807
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57808

lab57807:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57808:

lab57809:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57812
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57810
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57811

lab57810:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57811:

lab57812:
    jmp lab57814

lab57813:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57814:

lab57816:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; let x23: List[Vec4] = Cons(x24, x29);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57828
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab57829

lab57828:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57826
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57819
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57817
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57818

lab57817:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57818:

lab57819:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57822
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57820
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57821

lab57820:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57821:

lab57822:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57825
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57823
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57824

lab57823:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57824:

lab57825:
    jmp lab57827

lab57826:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57827:

lab57829:
    ; #load tag
    mov r15, 5
    ; let x17: List[Vec4] = Cons(x18, x23);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57841
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab57842

lab57841:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57839
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57832
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57830
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57831

lab57830:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57831:

lab57832:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57835
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57833
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57834

lab57833:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57834:

lab57835:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57838
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57836
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57837

lab57836:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57837:

lab57838:
    jmp lab57840

lab57839:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57840:

lab57842:
    ; #load tag
    mov r13, 5
    ; let x11: List[Vec4] = Cons(x12, x17);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57854
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab57855

lab57854:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57852
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57845
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57843
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57844

lab57843:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57844:

lab57845:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57848
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57846
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57847

lab57846:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57847:

lab57848:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57851
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57849
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57850

lab57849:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57850:

lab57851:
    jmp lab57853

lab57852:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57853:

lab57855:
    ; #load tag
    mov r11, 5
    ; let x5: List[Vec4] = Cons(x6, x11);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57867
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab57868

lab57867:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57865
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57858
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57856
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57857

lab57856:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57857:

lab57858:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57861
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57859
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57860

lab57859:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57860:

lab57861:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57864
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57862
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57863

lab57862:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57863:

lab57864:
    jmp lab57866

lab57865:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57866:

lab57868:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x5 !-> x5)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

r_tile_:
    ; lit x1 <- 0;
    mov rdi, 0
    ; lit x2 <- 0;
    mov r9, 0
    ; lit x3 <- 8;
    mov r11, 8
    ; lit x4 <- 8;
    mov r13, 8
    ; let x0: Vec4 = Vec4(x1, x2, x3, x4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57880
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab57881

lab57880:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57878
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57871
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57869
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57870

lab57869:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57870:

lab57871:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57874
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57872
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57873

lab57872:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57873:

lab57874:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57877
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57875
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57876

lab57875:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57876:

lab57877:
    jmp lab57879

lab57878:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57879:

lab57881:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57893
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab57894

lab57893:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57891
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57884
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57882
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57883

lab57882:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57883:

lab57884:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57887
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57885
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57886

lab57885:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57886:

lab57887:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57890
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57888
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57889

lab57888:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57889:

lab57890:
    jmp lab57892

lab57891:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57892:

lab57894:
    ; #load tag
    mov rdi, 0
    ; lit x7 <- 12;
    mov r9, 12
    ; lit x8 <- 12;
    mov r11, 12
    ; lit x9 <- 16;
    mov r13, 16
    ; lit x10 <- 16;
    mov r15, 16
    ; let x6: Vec4 = Vec4(x7, x8, x9, x10);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    mov [rbx + 24], r11
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57906
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab57907

lab57906:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57904
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57897
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57895
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57896

lab57895:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57896:

lab57897:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57900
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57898
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57899

lab57898:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57899:

lab57900:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57903
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57901
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57902

lab57901:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57902:

lab57903:
    jmp lab57905

lab57904:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57905:

lab57907:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57919
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab57920

lab57919:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57917
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57910
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57908
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57909

lab57908:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57909:

lab57910:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57913
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57911
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57912

lab57911:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57912:

lab57913:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57916
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57914
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57915

lab57914:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57915:

lab57916:
    jmp lab57918

lab57917:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57918:

lab57920:
    ; #load tag
    mov r9, 0
    ; lit x13 <- 0;
    mov r11, 0
    ; lit x14 <- 4;
    mov r13, 4
    ; lit x15 <- 5;
    mov r15, 5
    ; lit x16 <- 10;
    mov qword [rsp + 2024], 10
    ; let x12: Vec4 = Vec4(x13, x14, x15, x16);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov [rbx + 40], r15
    mov qword [rbx + 32], 0
    mov [rbx + 24], r13
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57932
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab57933

lab57932:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57930
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57923
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57921
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57922

lab57921:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57922:

lab57923:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57926
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57924
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57925

lab57924:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57925:

lab57926:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57929
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57927
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57928

lab57927:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57928:

lab57929:
    jmp lab57931

lab57930:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57931:

lab57933:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57945
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab57946

lab57945:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57943
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57936
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57934
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57935

lab57934:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57935:

lab57936:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57939
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57937
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57938

lab57937:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57938:

lab57939:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57942
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57940
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57941

lab57940:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57941:

lab57942:
    jmp lab57944

lab57943:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57944:

lab57946:
    ; #load tag
    mov r11, 0
    ; lit x19 <- 0;
    mov r13, 0
    ; lit x20 <- 8;
    mov r15, 8
    ; lit x21 <- 2;
    mov qword [rsp + 2024], 2
    ; lit x22 <- 12;
    mov qword [rsp + 2008], 12
    ; let x18: Vec4 = Vec4(x19, x20, x21, x22);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov [rbx + 24], r15
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57958
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab57959

lab57958:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57956
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57949
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57947
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57948

lab57947:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57948:

lab57949:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57952
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57950
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57951

lab57950:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57951:

lab57952:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57955
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57953
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57954

lab57953:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57954:

lab57955:
    jmp lab57957

lab57956:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57957:

lab57959:
    ; ##store link to previous block
    mov [rbx + 48], r14
    ; ##store values
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57971
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab57972

lab57971:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57969
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57962
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57960
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57961

lab57960:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57961:

lab57962:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57965
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57963
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57964

lab57963:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57964:

lab57965:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57968
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57966
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57967

lab57966:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57967:

lab57968:
    jmp lab57970

lab57969:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57970:

lab57972:
    ; #load tag
    mov r13, 0
    ; lit x25 <- 0;
    mov r15, 0
    ; lit x26 <- 12;
    mov qword [rsp + 2024], 12
    ; lit x27 <- 1;
    mov qword [rsp + 2008], 1
    ; lit x28 <- 14;
    mov qword [rsp + 1992], 14
    ; let x24: Vec4 = Vec4(x25, x26, x27, x28);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57984
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab57985

lab57984:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57982
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57975
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57973
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57974

lab57973:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57974:

lab57975:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57978
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57976
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57977

lab57976:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57977:

lab57978:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57981
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57979
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57980

lab57979:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57980:

lab57981:
    jmp lab57983

lab57982:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57983:

lab57985:
    ; ##store link to previous block
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    ; ##store values
    mov [rbx + 40], r15
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab57997
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab57998

lab57997:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab57995
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab57988
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57986
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57987

lab57986:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57987:

lab57988:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab57991
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57989
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57990

lab57989:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57990:

lab57991:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab57994
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57992
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab57993

lab57992:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab57993:

lab57994:
    jmp lab57996

lab57995:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab57996:

lab57998:
    ; #load tag
    mov r15, 0
    ; lit x31 <- 16;
    mov qword [rsp + 2024], 16
    ; lit x32 <- 6;
    mov qword [rsp + 2008], 6
    ; lit x33 <- 11;
    mov qword [rsp + 1992], 11
    ; lit x34 <- 10;
    mov qword [rsp + 1976], 10
    ; let x30: Vec4 = Vec4(x31, x32, x33, x34);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 2008]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58010
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58011

lab58010:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58008
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58001
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab57999
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58000

lab57999:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58000:

lab58001:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58004
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58002
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58003

lab58002:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58003:

lab58004:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58007
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58005
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58006

lab58005:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58006:

lab58007:
    jmp lab58009

lab58008:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58009:

lab58011:
    ; ##store link to previous block
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58023
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58024

lab58023:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58021
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58014
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58012
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58013

lab58012:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58013:

lab58014:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58017
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58015
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58016

lab58015:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58016:

lab58017:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58020
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58018
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58019

lab58018:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58019:

lab58020:
    jmp lab58022

lab58021:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58022:

lab58024:
    ; #load tag
    mov qword [rsp + 2024], 0
    ; lit x37 <- 11;
    mov qword [rsp + 2008], 11
    ; lit x38 <- 10;
    mov qword [rsp + 1992], 10
    ; lit x39 <- 6;
    mov qword [rsp + 1976], 6
    ; lit x40 <- 16;
    mov qword [rsp + 1960], 16
    ; let x36: Vec4 = Vec4(x37, x38, x39, x40);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58036
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58037

lab58036:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58034
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58027
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58025
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58026

lab58025:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58026:

lab58027:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58030
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58028
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58029

lab58028:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58029:

lab58030:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58033
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58031
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58032

lab58031:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58032:

lab58033:
    jmp lab58035

lab58034:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58035:

lab58037:
    ; ##store link to previous block
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58049
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58050

lab58049:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58047
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58040
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58038
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58039

lab58038:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58039:

lab58040:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58043
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58041
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58042

lab58041:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58042:

lab58043:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58046
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58044
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58045

lab58044:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58045:

lab58046:
    jmp lab58048

lab58047:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58048:

lab58050:
    ; #load tag
    mov qword [rsp + 2008], 0
    ; lit x43 <- 16;
    mov qword [rsp + 1992], 16
    ; lit x44 <- 4;
    mov qword [rsp + 1976], 4
    ; lit x45 <- 14;
    mov qword [rsp + 1960], 14
    ; lit x46 <- 6;
    mov qword [rsp + 1944], 6
    ; let x42: Vec4 = Vec4(x43, x44, x45, x46);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1976]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58062
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58063

lab58062:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58060
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58053
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58051
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58052

lab58051:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58052:

lab58053:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58056
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58054
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58055

lab58054:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58055:

lab58056:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58059
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58057
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58058

lab58057:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58058:

lab58059:
    jmp lab58061

lab58060:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58061:

lab58063:
    ; ##store link to previous block
    mov rcx, [rsp + 1984]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58075
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58076

lab58075:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58073
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58066
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58064
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58065

lab58064:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58065:

lab58066:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58069
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58067
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58068

lab58067:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58068:

lab58069:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58072
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58070
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58071

lab58070:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58071:

lab58072:
    jmp lab58074

lab58073:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58074:

lab58076:
    ; #load tag
    mov qword [rsp + 1992], 0
    ; lit x49 <- 14;
    mov qword [rsp + 1976], 14
    ; lit x50 <- 6;
    mov qword [rsp + 1960], 6
    ; lit x51 <- 8;
    mov qword [rsp + 1944], 8
    ; lit x52 <- 8;
    mov qword [rsp + 1928], 8
    ; let x48: Vec4 = Vec4(x49, x50, x51, x52);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1960]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58088
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58089

lab58088:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58086
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58079
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58077
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58078

lab58077:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58078:

lab58079:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58082
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58080
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58081

lab58080:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58081:

lab58082:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58085
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58083
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58084

lab58083:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58084:

lab58085:
    jmp lab58087

lab58086:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58087:

lab58089:
    ; ##store link to previous block
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58101
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58102

lab58101:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58099
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58092
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58090
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58091

lab58090:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58091:

lab58092:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58095
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58093
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58094

lab58093:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58094:

lab58095:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58098
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58096
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58097

lab58096:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58097:

lab58098:
    jmp lab58100

lab58099:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58100:

lab58102:
    ; #load tag
    mov qword [rsp + 1976], 0
    ; lit x55 <- 8;
    mov qword [rsp + 1960], 8
    ; lit x56 <- 8;
    mov qword [rsp + 1944], 8
    ; lit x57 <- 5;
    mov qword [rsp + 1928], 5
    ; lit x58 <- 10;
    mov qword [rsp + 1912], 10
    ; let x54: Vec4 = Vec4(x55, x56, x57, x58);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1912]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1928]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1944]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1952], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58114
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58115

lab58114:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58112
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58105
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58103
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58104

lab58103:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58104:

lab58105:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58108
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58106
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58107

lab58106:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58107:

lab58108:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58111
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58109
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58110

lab58109:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58110:

lab58111:
    jmp lab58113

lab58112:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58113:

lab58115:
    ; ##store link to previous block
    mov rcx, [rsp + 1952]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58127
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58128

lab58127:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58125
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58118
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58116
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58117

lab58116:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58117:

lab58118:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58121
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58119
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58120

lab58119:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58120:

lab58121:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58124
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58122
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58123

lab58122:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58123:

lab58124:
    jmp lab58126

lab58125:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58126:

lab58128:
    ; #load tag
    mov qword [rsp + 1960], 0
    ; lit x61 <- 5;
    mov qword [rsp + 1944], 5
    ; lit x62 <- 10;
    mov qword [rsp + 1928], 10
    ; lit x63 <- 2;
    mov qword [rsp + 1912], 2
    ; lit x64 <- 12;
    mov qword [rsp + 1896], 12
    ; let x60: Vec4 = Vec4(x61, x62, x63, x64);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1928]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58140
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58141

lab58140:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58138
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58131
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58129
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58130

lab58129:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58130:

lab58131:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58134
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58132
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58133

lab58132:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58133:

lab58134:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58137
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58135
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58136

lab58135:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58136:

lab58137:
    jmp lab58139

lab58138:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58139:

lab58141:
    ; ##store link to previous block
    mov rcx, [rsp + 1936]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1952], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58153
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58154

lab58153:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58151
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58144
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58142
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58143

lab58142:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58143:

lab58144:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58147
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58145
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58146

lab58145:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58146:

lab58147:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58150
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58148
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58149

lab58148:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58149:

lab58150:
    jmp lab58152

lab58151:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58152:

lab58154:
    ; #load tag
    mov qword [rsp + 1944], 0
    ; lit x67 <- 2;
    mov qword [rsp + 1928], 2
    ; lit x68 <- 12;
    mov qword [rsp + 1912], 12
    ; lit x69 <- 0;
    mov qword [rsp + 1896], 0
    ; lit x70 <- 16;
    mov qword [rsp + 1880], 16
    ; let x66: Vec4 = Vec4(x67, x68, x69, x70);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1880]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1896]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1912]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1920], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58166
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58167

lab58166:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58164
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58157
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58155
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58156

lab58155:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58156:

lab58157:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58160
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58158
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58159

lab58158:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58159:

lab58160:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58163
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58161
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58162

lab58161:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58162:

lab58163:
    jmp lab58165

lab58164:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58165:

lab58167:
    ; ##store link to previous block
    mov rcx, [rsp + 1920]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58179
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58180

lab58179:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58177
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58170
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58168
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58169

lab58168:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58169:

lab58170:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58173
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58171
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58172

lab58171:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58172:

lab58173:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58176
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58174
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58175

lab58174:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58175:

lab58176:
    jmp lab58178

lab58177:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58178:

lab58180:
    ; #load tag
    mov qword [rsp + 1928], 0
    ; lit x73 <- 16;
    mov qword [rsp + 1912], 16
    ; lit x74 <- 8;
    mov qword [rsp + 1896], 8
    ; lit x75 <- 12;
    mov qword [rsp + 1880], 12
    ; lit x76 <- 12;
    mov qword [rsp + 1864], 12
    ; let x72: Vec4 = Vec4(x73, x74, x75, x76);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1864]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1880]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1896]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1904], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58192
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58193

lab58192:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58190
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58183
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58181
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58182

lab58181:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58182:

lab58183:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58186
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58184
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58185

lab58184:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58185:

lab58186:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58189
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58187
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58188

lab58187:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58188:

lab58189:
    jmp lab58191

lab58190:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58191:

lab58193:
    ; ##store link to previous block
    mov rcx, [rsp + 1904]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1920], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58205
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58206

lab58205:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58203
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58196
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58194
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58195

lab58194:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58195:

lab58196:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58199
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58197
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58198

lab58197:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58198:

lab58199:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58202
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58200
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58201

lab58200:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58201:

lab58202:
    jmp lab58204

lab58203:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58204:

lab58206:
    ; #load tag
    mov qword [rsp + 1912], 0
    ; lit x79 <- 12;
    mov qword [rsp + 1896], 12
    ; lit x80 <- 12;
    mov qword [rsp + 1880], 12
    ; lit x81 <- 11;
    mov qword [rsp + 1864], 11
    ; lit x82 <- 16;
    mov qword [rsp + 1848], 16
    ; let x78: Vec4 = Vec4(x79, x80, x81, x82);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1848]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1864]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1880]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1888], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58218
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58219

lab58218:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58216
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58209
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58207
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58208

lab58207:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58208:

lab58209:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58212
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58210
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58211

lab58210:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58211:

lab58212:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58215
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58213
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58214

lab58213:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58214:

lab58215:
    jmp lab58217

lab58216:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58217:

lab58219:
    ; ##store link to previous block
    mov rcx, [rsp + 1888]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1904], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58231
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58232

lab58231:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58229
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58222
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58220
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58221

lab58220:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58221:

lab58222:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58225
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58223
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58224

lab58223:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58224:

lab58225:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58228
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58226
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58227

lab58226:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58227:

lab58228:
    jmp lab58230

lab58229:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58230:

lab58232:
    ; #load tag
    mov qword [rsp + 1896], 0
    ; lit x85 <- 1;
    mov qword [rsp + 1880], 1
    ; lit x86 <- 1;
    mov qword [rsp + 1864], 1
    ; lit x87 <- 4;
    mov qword [rsp + 1848], 4
    ; lit x88 <- 0;
    mov qword [rsp + 1832], 0
    ; let x84: Vec4 = Vec4(x85, x86, x87, x88);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1832]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1848]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1864]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1872], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58244
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58245

lab58244:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58242
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58235
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58233
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58234

lab58233:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58234:

lab58235:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58238
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58236
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58237

lab58236:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58237:

lab58238:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58241
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58239
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58240

lab58239:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58240:

lab58241:
    jmp lab58243

lab58242:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58243:

lab58245:
    ; ##store link to previous block
    mov rcx, [rsp + 1872]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1880]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1888], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58257
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58258

lab58257:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58255
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58248
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58246
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58247

lab58246:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58247:

lab58248:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58251
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58249
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58250

lab58249:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58250:

lab58251:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58254
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58252
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58253

lab58252:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58253:

lab58254:
    jmp lab58256

lab58255:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58256:

lab58258:
    ; #load tag
    mov qword [rsp + 1880], 0
    ; lit x91 <- 2;
    mov qword [rsp + 1864], 2
    ; lit x92 <- 2;
    mov qword [rsp + 1848], 2
    ; lit x93 <- 8;
    mov qword [rsp + 1832], 8
    ; lit x94 <- 0;
    mov qword [rsp + 1816], 0
    ; let x90: Vec4 = Vec4(x91, x92, x93, x94);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1816]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1832]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1848]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1856], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58270
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58271

lab58270:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58268
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58261
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58259
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58260

lab58259:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58260:

lab58261:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58264
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58262
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58263

lab58262:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58263:

lab58264:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58267
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58265
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58266

lab58265:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58266:

lab58267:
    jmp lab58269

lab58268:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58269:

lab58271:
    ; ##store link to previous block
    mov rcx, [rsp + 1856]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1864]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1872], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58283
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58284

lab58283:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58281
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58274
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58272
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58273

lab58272:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58273:

lab58274:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58277
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58275
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58276

lab58275:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58276:

lab58277:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58280
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58278
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58279

lab58278:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58279:

lab58280:
    jmp lab58282

lab58281:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58282:

lab58284:
    ; #load tag
    mov qword [rsp + 1864], 0
    ; lit x97 <- 3;
    mov qword [rsp + 1848], 3
    ; lit x98 <- 3;
    mov qword [rsp + 1832], 3
    ; lit x99 <- 8;
    mov qword [rsp + 1816], 8
    ; lit x100 <- 2;
    mov qword [rsp + 1800], 2
    ; let x96: Vec4 = Vec4(x97, x98, x99, x100);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1800]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1816]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1832]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1840], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58296
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58297

lab58296:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58294
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58287
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58285
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58286

lab58285:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58286:

lab58287:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58290
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58288
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58289

lab58288:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58289:

lab58290:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58293
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58291
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58292

lab58291:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58292:

lab58293:
    jmp lab58295

lab58294:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58295:

lab58297:
    ; ##store link to previous block
    mov rcx, [rsp + 1840]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1848]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1856], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58309
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58310

lab58309:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58307
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58300
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58298
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58299

lab58298:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58299:

lab58300:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58303
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58301
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58302

lab58301:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58302:

lab58303:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58306
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58304
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58305

lab58304:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58305:

lab58306:
    jmp lab58308

lab58307:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58308:

lab58310:
    ; #load tag
    mov qword [rsp + 1848], 0
    ; lit x103 <- 8;
    mov qword [rsp + 1832], 8
    ; lit x104 <- 2;
    mov qword [rsp + 1816], 2
    ; lit x105 <- 12;
    mov qword [rsp + 1800], 12
    ; lit x106 <- 0;
    mov qword [rsp + 1784], 0
    ; let x102: Vec4 = Vec4(x103, x104, x105, x106);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1784]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1800]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1816]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1824], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58322
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58323

lab58322:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58320
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58313
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58311
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58312

lab58311:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58312:

lab58313:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58316
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58314
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58315

lab58314:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58315:

lab58316:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58319
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58317
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58318

lab58317:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58318:

lab58319:
    jmp lab58321

lab58320:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58321:

lab58323:
    ; ##store link to previous block
    mov rcx, [rsp + 1824]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1832]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1840], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58335
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58336

lab58335:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58333
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58326
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58324
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58325

lab58324:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58325:

lab58326:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58329
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58327
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58328

lab58327:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58328:

lab58329:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58332
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58330
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58331

lab58330:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58331:

lab58332:
    jmp lab58334

lab58333:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58334:

lab58336:
    ; #load tag
    mov qword [rsp + 1832], 0
    ; lit x109 <- 5;
    mov qword [rsp + 1816], 5
    ; lit x110 <- 5;
    mov qword [rsp + 1800], 5
    ; lit x111 <- 12;
    mov qword [rsp + 1784], 12
    ; lit x112 <- 3;
    mov qword [rsp + 1768], 3
    ; let x108: Vec4 = Vec4(x109, x110, x111, x112);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1768]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1784]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1800]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1808], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58348
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58349

lab58348:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58346
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58339
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58337
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58338

lab58337:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58338:

lab58339:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58342
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58340
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58341

lab58340:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58341:

lab58342:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58345
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58343
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58344

lab58343:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58344:

lab58345:
    jmp lab58347

lab58346:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58347:

lab58349:
    ; ##store link to previous block
    mov rcx, [rsp + 1808]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1816]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1824], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58361
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58362

lab58361:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58359
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58352
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58350
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58351

lab58350:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58351:

lab58352:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58355
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58353
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58354

lab58353:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58354:

lab58355:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58358
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58356
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58357

lab58356:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58357:

lab58358:
    jmp lab58360

lab58359:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58360:

lab58362:
    ; #load tag
    mov qword [rsp + 1816], 0
    ; lit x115 <- 12;
    mov qword [rsp + 1800], 12
    ; lit x116 <- 3;
    mov qword [rsp + 1784], 3
    ; lit x117 <- 16;
    mov qword [rsp + 1768], 16
    ; lit x118 <- 0;
    mov qword [rsp + 1752], 0
    ; let x114: Vec4 = Vec4(x115, x116, x117, x118);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1752]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1768]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1784]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1792], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58374
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58375

lab58374:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58372
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58365
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58363
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58364

lab58363:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58364:

lab58365:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58368
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58366
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58367

lab58366:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58367:

lab58368:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58371
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58369
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58370

lab58369:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58370:

lab58371:
    jmp lab58373

lab58372:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58373:

lab58375:
    ; ##store link to previous block
    mov rcx, [rsp + 1792]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1800]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1808], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58387
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58388

lab58387:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58385
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58378
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58376
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58377

lab58376:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58377:

lab58378:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58381
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58379
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58380

lab58379:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58380:

lab58381:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58384
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58382
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58383

lab58382:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58383:

lab58384:
    jmp lab58386

lab58385:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58386:

lab58388:
    ; #load tag
    mov qword [rsp + 1800], 0
    ; lit x121 <- 11;
    mov qword [rsp + 1784], 11
    ; lit x122 <- 16;
    mov qword [rsp + 1768], 16
    ; lit x123 <- 12;
    mov qword [rsp + 1752], 12
    ; lit x124 <- 12;
    mov qword [rsp + 1736], 12
    ; let x120: Vec4 = Vec4(x121, x122, x123, x124);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1736]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1752]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1768]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1776], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58400
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58401

lab58400:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58398
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58391
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58389
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58390

lab58389:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58390:

lab58391:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58394
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58392
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58393

lab58392:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58393:

lab58394:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58397
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58395
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58396

lab58395:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58396:

lab58397:
    jmp lab58399

lab58398:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58399:

lab58401:
    ; ##store link to previous block
    mov rcx, [rsp + 1776]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1784]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1792], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58413
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58414

lab58413:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58411
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58404
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58402
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58403

lab58402:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58403:

lab58404:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58407
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58405
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58406

lab58405:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58406:

lab58407:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58410
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58408
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58409

lab58408:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58409:

lab58410:
    jmp lab58412

lab58411:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58412:

lab58414:
    ; #load tag
    mov qword [rsp + 1784], 0
    ; lit x127 <- 12;
    mov qword [rsp + 1768], 12
    ; lit x128 <- 12;
    mov qword [rsp + 1752], 12
    ; lit x129 <- 16;
    mov qword [rsp + 1736], 16
    ; lit x130 <- 8;
    mov qword [rsp + 1720], 8
    ; let x126: Vec4 = Vec4(x127, x128, x129, x130);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1720]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1736]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1752]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1760], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58426
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58427

lab58426:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58424
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58417
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58415
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58416

lab58415:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58416:

lab58417:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58420
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58418
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58419

lab58418:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58419:

lab58420:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58423
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58421
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58422

lab58421:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58422:

lab58423:
    jmp lab58425

lab58424:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58425:

lab58427:
    ; ##store link to previous block
    mov rcx, [rsp + 1760]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1768]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1776], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58439
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58440

lab58439:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58437
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58430
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58428
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58429

lab58428:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58429:

lab58430:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58433
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58431
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58432

lab58431:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58432:

lab58433:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58436
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58434
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58435

lab58434:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58435:

lab58436:
    jmp lab58438

lab58437:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58438:

lab58440:
    ; #load tag
    mov qword [rsp + 1768], 0
    ; lit x133 <- 13;
    mov qword [rsp + 1752], 13
    ; lit x134 <- 13;
    mov qword [rsp + 1736], 13
    ; lit x135 <- 16;
    mov qword [rsp + 1720], 16
    ; lit x136 <- 10;
    mov qword [rsp + 1704], 10
    ; let x132: Vec4 = Vec4(x133, x134, x135, x136);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1704]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1720]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1736]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1744], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58452
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58453

lab58452:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58450
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58443
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58441
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58442

lab58441:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58442:

lab58443:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58446
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58444
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58445

lab58444:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58445:

lab58446:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58449
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58447
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58448

lab58447:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58448:

lab58449:
    jmp lab58451

lab58450:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58451:

lab58453:
    ; ##store link to previous block
    mov rcx, [rsp + 1744]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1752]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1760], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58465
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58466

lab58465:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58463
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58456
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58454
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58455

lab58454:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58455:

lab58456:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58459
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58457
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58458

lab58457:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58458:

lab58459:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58462
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58460
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58461

lab58460:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58461:

lab58462:
    jmp lab58464

lab58463:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58464:

lab58466:
    ; #load tag
    mov qword [rsp + 1752], 0
    ; lit x139 <- 14;
    mov qword [rsp + 1736], 14
    ; lit x140 <- 14;
    mov qword [rsp + 1720], 14
    ; lit x141 <- 16;
    mov qword [rsp + 1704], 16
    ; lit x142 <- 12;
    mov qword [rsp + 1688], 12
    ; let x138: Vec4 = Vec4(x139, x140, x141, x142);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1688]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1704]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1720]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1728], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58478
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58479

lab58478:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58476
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58469
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58467
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58468

lab58467:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58468:

lab58469:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58472
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58470
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58471

lab58470:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58471:

lab58472:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58475
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58473
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58474

lab58473:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58474:

lab58475:
    jmp lab58477

lab58476:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58477:

lab58479:
    ; ##store link to previous block
    mov rcx, [rsp + 1728]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1736]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1744], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58491
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58492

lab58491:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58489
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58482
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58480
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58481

lab58480:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58481:

lab58482:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58485
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58483
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58484

lab58483:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58484:

lab58485:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58488
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58486
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58487

lab58486:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58487:

lab58488:
    jmp lab58490

lab58489:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58490:

lab58492:
    ; #load tag
    mov qword [rsp + 1736], 0
    ; lit x145 <- 15;
    mov qword [rsp + 1720], 15
    ; lit x146 <- 15;
    mov qword [rsp + 1704], 15
    ; lit x147 <- 16;
    mov qword [rsp + 1688], 16
    ; lit x148 <- 14;
    mov qword [rsp + 1672], 14
    ; let x144: Vec4 = Vec4(x145, x146, x147, x148);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1672]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1688]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1704]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1712], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58504
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58505

lab58504:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58502
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58495
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58493
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58494

lab58493:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58494:

lab58495:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58498
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58496
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58497

lab58496:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58497:

lab58498:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58501
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58499
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58500

lab58499:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58500:

lab58501:
    jmp lab58503

lab58502:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58503:

lab58505:
    ; ##store link to previous block
    mov rcx, [rsp + 1712]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1720]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1728], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58517
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58518

lab58517:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58515
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58508
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58506
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58507

lab58506:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58507:

lab58508:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58511
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58509
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58510

lab58509:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58510:

lab58511:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58514
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58512
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58513

lab58512:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58513:

lab58514:
    jmp lab58516

lab58515:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58516:

lab58518:
    ; #load tag
    mov qword [rsp + 1720], 0
    ; let x149: List[Vec4] = Nil();
    ; #mark no allocation
    mov qword [rsp + 1712], 0
    ; #load tag
    mov qword [rsp + 1704], 0
    ; let x143: List[Vec4] = Cons(x144, x149);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1704]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1712]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1720]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1728]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1728], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58530
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58531

lab58530:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58528
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58521
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58519
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58520

lab58519:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58520:

lab58521:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58524
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58522
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58523

lab58522:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58523:

lab58524:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58527
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58525
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58526

lab58525:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58526:

lab58527:
    jmp lab58529

lab58528:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58529:

lab58531:
    ; #load tag
    mov qword [rsp + 1720], 5
    ; let x137: List[Vec4] = Cons(x138, x143);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1720]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1728]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1736]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1744]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1744], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58543
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58544

lab58543:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58541
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58534
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58532
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58533

lab58532:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58533:

lab58534:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58537
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58535
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58536

lab58535:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58536:

lab58537:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58540
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58538
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58539

lab58538:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58539:

lab58540:
    jmp lab58542

lab58541:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58542:

lab58544:
    ; #load tag
    mov qword [rsp + 1736], 5
    ; let x131: List[Vec4] = Cons(x132, x137);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1736]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1744]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1752]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1760]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1760], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58556
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58557

lab58556:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58554
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58547
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58545
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58546

lab58545:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58546:

lab58547:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58550
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58548
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58549

lab58548:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58549:

lab58550:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58553
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58551
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58552

lab58551:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58552:

lab58553:
    jmp lab58555

lab58554:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58555:

lab58557:
    ; #load tag
    mov qword [rsp + 1752], 5
    ; let x125: List[Vec4] = Cons(x126, x131);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1752]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1760]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1768]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1776]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1776], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58569
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58570

lab58569:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58567
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58560
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58558
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58559

lab58558:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58559:

lab58560:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58563
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58561
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58562

lab58561:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58562:

lab58563:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58566
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58564
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58565

lab58564:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58565:

lab58566:
    jmp lab58568

lab58567:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58568:

lab58570:
    ; #load tag
    mov qword [rsp + 1768], 5
    ; let x119: List[Vec4] = Cons(x120, x125);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1768]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1776]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1784]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1792]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1792], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58582
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58583

lab58582:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58580
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58573
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58571
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58572

lab58571:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58572:

lab58573:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58576
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58574
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58575

lab58574:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58575:

lab58576:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58579
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58577
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58578

lab58577:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58578:

lab58579:
    jmp lab58581

lab58580:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58581:

lab58583:
    ; #load tag
    mov qword [rsp + 1784], 5
    ; let x113: List[Vec4] = Cons(x114, x119);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1784]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1792]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1800]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1808]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1808], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58595
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58596

lab58595:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58593
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58586
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58584
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58585

lab58584:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58585:

lab58586:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58589
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58587
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58588

lab58587:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58588:

lab58589:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58592
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58590
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58591

lab58590:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58591:

lab58592:
    jmp lab58594

lab58593:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58594:

lab58596:
    ; #load tag
    mov qword [rsp + 1800], 5
    ; let x107: List[Vec4] = Cons(x108, x113);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1800]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1808]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1816]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1824]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1824], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58608
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58609

lab58608:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58606
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58599
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58597
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58598

lab58597:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58598:

lab58599:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58602
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58600
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58601

lab58600:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58601:

lab58602:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58605
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58603
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58604

lab58603:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58604:

lab58605:
    jmp lab58607

lab58606:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58607:

lab58609:
    ; #load tag
    mov qword [rsp + 1816], 5
    ; let x101: List[Vec4] = Cons(x102, x107);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1816]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1824]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1832]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1840]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1840], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58621
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58622

lab58621:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58619
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58612
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58610
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58611

lab58610:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58611:

lab58612:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58615
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58613
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58614

lab58613:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58614:

lab58615:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58618
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58616
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58617

lab58616:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58617:

lab58618:
    jmp lab58620

lab58619:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58620:

lab58622:
    ; #load tag
    mov qword [rsp + 1832], 5
    ; let x95: List[Vec4] = Cons(x96, x101);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1832]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1840]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1848]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1856]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1856], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58634
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58635

lab58634:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58632
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58625
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58623
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58624

lab58623:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58624:

lab58625:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58628
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58626
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58627

lab58626:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58627:

lab58628:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58631
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58629
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58630

lab58629:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58630:

lab58631:
    jmp lab58633

lab58632:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58633:

lab58635:
    ; #load tag
    mov qword [rsp + 1848], 5
    ; let x89: List[Vec4] = Cons(x90, x95);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1848]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1856]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1864]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1872]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1872], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58647
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58648

lab58647:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58645
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58638
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58636
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58637

lab58636:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58637:

lab58638:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58641
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58639
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58640

lab58639:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58640:

lab58641:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58644
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58642
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58643

lab58642:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58643:

lab58644:
    jmp lab58646

lab58645:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58646:

lab58648:
    ; #load tag
    mov qword [rsp + 1864], 5
    ; let x83: List[Vec4] = Cons(x84, x89);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1864]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1872]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1880]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1888]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1888], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58660
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58661

lab58660:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58658
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58651
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58649
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58650

lab58649:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58650:

lab58651:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58654
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58652
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58653

lab58652:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58653:

lab58654:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58657
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58655
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58656

lab58655:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58656:

lab58657:
    jmp lab58659

lab58658:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58659:

lab58661:
    ; #load tag
    mov qword [rsp + 1880], 5
    ; let x77: List[Vec4] = Cons(x78, x83);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1880]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1888]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1896]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1904]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1904], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58673
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58674

lab58673:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58671
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58664
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58662
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58663

lab58662:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58663:

lab58664:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58667
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58665
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58666

lab58665:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58666:

lab58667:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58670
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58668
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58669

lab58668:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58669:

lab58670:
    jmp lab58672

lab58671:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58672:

lab58674:
    ; #load tag
    mov qword [rsp + 1896], 5
    ; let x71: List[Vec4] = Cons(x72, x77);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1904]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1920]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1920], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58686
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58687

lab58686:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58684
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58677
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58675
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58676

lab58675:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58676:

lab58677:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58680
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58678
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58679

lab58678:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58679:

lab58680:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58683
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58681
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58682

lab58681:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58682:

lab58683:
    jmp lab58685

lab58684:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58685:

lab58687:
    ; #load tag
    mov qword [rsp + 1912], 5
    ; let x65: List[Vec4] = Cons(x66, x71);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1912]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1920]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1928]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1936]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58699
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58700

lab58699:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58697
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58690
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58688
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58689

lab58688:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58689:

lab58690:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58693
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58691
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58692

lab58691:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58692:

lab58693:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58696
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58694
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58695

lab58694:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58695:

lab58696:
    jmp lab58698

lab58697:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58698:

lab58700:
    ; #load tag
    mov qword [rsp + 1928], 5
    ; let x59: List[Vec4] = Cons(x60, x65);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1936]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1952]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1952], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58712
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58713

lab58712:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58710
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58703
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58701
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58702

lab58701:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58702:

lab58703:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58706
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58704
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58705

lab58704:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58705:

lab58706:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58709
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58707
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58708

lab58707:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58708:

lab58709:
    jmp lab58711

lab58710:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58711:

lab58713:
    ; #load tag
    mov qword [rsp + 1944], 5
    ; let x53: List[Vec4] = Cons(x54, x59);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1952]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58725
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58726

lab58725:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58723
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58716
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58714
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58715

lab58714:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58715:

lab58716:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58719
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58717
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58718

lab58717:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58718:

lab58719:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58722
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58720
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58721

lab58720:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58721:

lab58722:
    jmp lab58724

lab58723:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58724:

lab58726:
    ; #load tag
    mov qword [rsp + 1960], 5
    ; let x47: List[Vec4] = Cons(x48, x53);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58738
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58739

lab58738:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58736
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58729
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58727
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58728

lab58727:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58728:

lab58729:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58732
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58730
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58731

lab58730:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58731:

lab58732:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58735
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58733
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58734

lab58733:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58734:

lab58735:
    jmp lab58737

lab58736:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58737:

lab58739:
    ; #load tag
    mov qword [rsp + 1976], 5
    ; let x41: List[Vec4] = Cons(x42, x47);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58751
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58752

lab58751:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58749
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58742
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58740
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58741

lab58740:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58741:

lab58742:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58745
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58743
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58744

lab58743:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58744:

lab58745:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58748
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58746
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58747

lab58746:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58747:

lab58748:
    jmp lab58750

lab58749:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58750:

lab58752:
    ; #load tag
    mov qword [rsp + 1992], 5
    ; let x35: List[Vec4] = Cons(x36, x41);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58764
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58765

lab58764:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58762
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58755
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58753
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58754

lab58753:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58754:

lab58755:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58758
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58756
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58757

lab58756:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58757:

lab58758:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58761
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58759
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58760

lab58759:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58760:

lab58761:
    jmp lab58763

lab58762:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58763:

lab58765:
    ; #load tag
    mov qword [rsp + 2008], 5
    ; let x29: List[Vec4] = Cons(x30, x35);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58777
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58778

lab58777:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58775
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58768
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58766
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58767

lab58766:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58767:

lab58768:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58771
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58769
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58770

lab58769:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58770:

lab58771:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58774
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58772
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58773

lab58772:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58773:

lab58774:
    jmp lab58776

lab58775:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58776:

lab58778:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; let x23: List[Vec4] = Cons(x24, x29);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58790
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab58791

lab58790:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58788
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58781
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58779
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58780

lab58779:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58780:

lab58781:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58784
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58782
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58783

lab58782:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58783:

lab58784:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58787
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58785
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58786

lab58785:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58786:

lab58787:
    jmp lab58789

lab58788:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58789:

lab58791:
    ; #load tag
    mov r15, 5
    ; let x17: List[Vec4] = Cons(x18, x23);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58803
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab58804

lab58803:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58801
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58794
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58792
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58793

lab58792:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58793:

lab58794:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58797
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58795
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58796

lab58795:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58796:

lab58797:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58800
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58798
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58799

lab58798:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58799:

lab58800:
    jmp lab58802

lab58801:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58802:

lab58804:
    ; #load tag
    mov r13, 5
    ; let x11: List[Vec4] = Cons(x12, x17);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58816
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab58817

lab58816:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58814
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58807
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58805
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58806

lab58805:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58806:

lab58807:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58810
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58808
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58809

lab58808:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58809:

lab58810:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58813
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58811
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58812

lab58811:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58812:

lab58813:
    jmp lab58815

lab58814:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58815:

lab58817:
    ; #load tag
    mov r11, 5
    ; let x5: List[Vec4] = Cons(x6, x11);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58829
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab58830

lab58829:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58827
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58820
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58818
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58819

lab58818:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58819:

lab58820:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58823
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58821
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58822

lab58821:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58822:

lab58823:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58826
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58824
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58825

lab58824:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58825:

lab58826:
    jmp lab58828

lab58827:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58828:

lab58830:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x5 !-> x5)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

s_tile_:
    ; lit x1 <- 0;
    mov rdi, 0
    ; lit x2 <- 0;
    mov r9, 0
    ; lit x3 <- 4;
    mov r11, 4
    ; lit x4 <- 2;
    mov r13, 2
    ; let x0: Vec4 = Vec4(x1, x2, x3, x4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58842
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab58843

lab58842:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58840
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58833
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58831
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58832

lab58831:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58832:

lab58833:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58836
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58834
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58835

lab58834:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58835:

lab58836:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58839
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58837
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58838

lab58837:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58838:

lab58839:
    jmp lab58841

lab58840:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58841:

lab58843:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58855
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab58856

lab58855:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58853
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58846
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58844
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58845

lab58844:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58845:

lab58846:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58849
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58847
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58848

lab58847:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58848:

lab58849:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58852
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58850
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58851

lab58850:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58851:

lab58852:
    jmp lab58854

lab58853:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58854:

lab58856:
    ; #load tag
    mov rdi, 0
    ; lit x7 <- 4;
    mov r9, 4
    ; lit x8 <- 2;
    mov r11, 2
    ; lit x9 <- 8;
    mov r13, 8
    ; lit x10 <- 2;
    mov r15, 2
    ; let x6: Vec4 = Vec4(x7, x8, x9, x10);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    mov [rbx + 24], r11
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58868
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab58869

lab58868:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58866
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58859
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58857
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58858

lab58857:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58858:

lab58859:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58862
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58860
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58861

lab58860:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58861:

lab58862:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58865
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58863
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58864

lab58863:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58864:

lab58865:
    jmp lab58867

lab58866:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58867:

lab58869:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58881
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab58882

lab58881:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58879
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58872
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58870
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58871

lab58870:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58871:

lab58872:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58875
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58873
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58874

lab58873:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58874:

lab58875:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58878
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58876
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58877

lab58876:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58877:

lab58878:
    jmp lab58880

lab58879:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58880:

lab58882:
    ; #load tag
    mov r9, 0
    ; lit x13 <- 8;
    mov r11, 8
    ; lit x14 <- 2;
    mov r13, 2
    ; lit x15 <- 16;
    mov r15, 16
    ; lit x16 <- 0;
    mov qword [rsp + 2024], 0
    ; let x12: Vec4 = Vec4(x13, x14, x15, x16);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov [rbx + 40], r15
    mov qword [rbx + 32], 0
    mov [rbx + 24], r13
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58894
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab58895

lab58894:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58892
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58885
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58883
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58884

lab58883:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58884:

lab58885:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58888
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58886
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58887

lab58886:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58887:

lab58888:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58891
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58889
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58890

lab58889:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58890:

lab58891:
    jmp lab58893

lab58892:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58893:

lab58895:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58907
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab58908

lab58907:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58905
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58898
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58896
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58897

lab58896:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58897:

lab58898:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58901
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58899
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58900

lab58899:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58900:

lab58901:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58904
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58902
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58903

lab58902:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58903:

lab58904:
    jmp lab58906

lab58905:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58906:

lab58908:
    ; #load tag
    mov r11, 0
    ; lit x19 <- 0;
    mov r13, 0
    ; lit x20 <- 4;
    mov r15, 4
    ; lit x21 <- 2;
    mov qword [rsp + 2024], 2
    ; lit x22 <- 1;
    mov qword [rsp + 2008], 1
    ; let x18: Vec4 = Vec4(x19, x20, x21, x22);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov [rbx + 24], r15
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58920
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab58921

lab58920:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58918
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58911
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58909
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58910

lab58909:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58910:

lab58911:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58914
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58912
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58913

lab58912:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58913:

lab58914:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58917
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58915
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58916

lab58915:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58916:

lab58917:
    jmp lab58919

lab58918:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58919:

lab58921:
    ; ##store link to previous block
    mov [rbx + 48], r14
    ; ##store values
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58933
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab58934

lab58933:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58931
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58924
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58922
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58923

lab58922:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58923:

lab58924:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58927
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58925
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58926

lab58925:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58926:

lab58927:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58930
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58928
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58929

lab58928:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58929:

lab58930:
    jmp lab58932

lab58931:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58932:

lab58934:
    ; #load tag
    mov r13, 0
    ; lit x25 <- 0;
    mov r15, 0
    ; lit x26 <- 6;
    mov qword [rsp + 2024], 6
    ; lit x27 <- 7;
    mov qword [rsp + 2008], 7
    ; lit x28 <- 4;
    mov qword [rsp + 1992], 4
    ; let x24: Vec4 = Vec4(x25, x26, x27, x28);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58946
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58947

lab58946:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58944
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58937
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58935
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58936

lab58935:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58936:

lab58937:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58940
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58938
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58939

lab58938:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58939:

lab58940:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58943
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58941
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58942

lab58941:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58942:

lab58943:
    jmp lab58945

lab58944:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58945:

lab58947:
    ; ##store link to previous block
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    ; ##store values
    mov [rbx + 40], r15
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58959
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab58960

lab58959:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58957
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58950
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58948
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58949

lab58948:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58949:

lab58950:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58953
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58951
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58952

lab58951:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58952:

lab58953:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58956
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58954
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58955

lab58954:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58955:

lab58956:
    jmp lab58958

lab58957:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58958:

lab58960:
    ; #load tag
    mov r15, 0
    ; lit x31 <- 0;
    mov qword [rsp + 2024], 0
    ; lit x32 <- 8;
    mov qword [rsp + 2008], 8
    ; lit x33 <- 8;
    mov qword [rsp + 1992], 8
    ; lit x34 <- 6;
    mov qword [rsp + 1976], 6
    ; let x30: Vec4 = Vec4(x31, x32, x33, x34);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 2008]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58972
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58973

lab58972:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58970
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58963
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58961
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58962

lab58961:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58962:

lab58963:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58966
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58964
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58965

lab58964:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58965:

lab58966:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58969
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58967
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58968

lab58967:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58968:

lab58969:
    jmp lab58971

lab58970:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58971:

lab58973:
    ; ##store link to previous block
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58985
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58986

lab58985:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58983
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58976
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58974
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58975

lab58974:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58975:

lab58976:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58979
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58977
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58978

lab58977:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58978:

lab58979:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58982
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58980
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58981

lab58980:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58981:

lab58982:
    jmp lab58984

lab58983:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58984:

lab58986:
    ; #load tag
    mov qword [rsp + 2024], 0
    ; lit x37 <- 0;
    mov qword [rsp + 2008], 0
    ; lit x38 <- 10;
    mov qword [rsp + 1992], 10
    ; lit x39 <- 7;
    mov qword [rsp + 1976], 7
    ; lit x40 <- 8;
    mov qword [rsp + 1960], 8
    ; let x36: Vec4 = Vec4(x37, x38, x39, x40);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab58998
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab58999

lab58998:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab58996
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab58989
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58987
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58988

lab58987:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58988:

lab58989:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab58992
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58990
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58991

lab58990:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58991:

lab58992:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab58995
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab58993
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab58994

lab58993:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab58994:

lab58995:
    jmp lab58997

lab58996:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab58997:

lab58999:
    ; ##store link to previous block
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59011
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59012

lab59011:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59009
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59002
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59000
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59001

lab59000:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59001:

lab59002:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59005
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59003
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59004

lab59003:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59004:

lab59005:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59008
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59006
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59007

lab59006:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59007:

lab59008:
    jmp lab59010

lab59009:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59010:

lab59012:
    ; #load tag
    mov qword [rsp + 2008], 0
    ; lit x43 <- 0;
    mov qword [rsp + 1992], 0
    ; lit x44 <- 12;
    mov qword [rsp + 1976], 12
    ; lit x45 <- 7;
    mov qword [rsp + 1960], 7
    ; lit x46 <- 10;
    mov qword [rsp + 1944], 10
    ; let x42: Vec4 = Vec4(x43, x44, x45, x46);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1976]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59024
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59025

lab59024:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59022
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59015
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59013
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59014

lab59013:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59014:

lab59015:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59018
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59016
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59017

lab59016:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59017:

lab59018:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59021
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59019
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59020

lab59019:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59020:

lab59021:
    jmp lab59023

lab59022:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59023:

lab59025:
    ; ##store link to previous block
    mov rcx, [rsp + 1984]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59037
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59038

lab59037:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59035
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59028
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59026
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59027

lab59026:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59027:

lab59028:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59031
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59029
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59030

lab59029:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59030:

lab59031:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59034
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59032
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59033

lab59032:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59033:

lab59034:
    jmp lab59036

lab59035:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59036:

lab59038:
    ; #load tag
    mov qword [rsp + 1992], 0
    ; lit x49 <- 0;
    mov qword [rsp + 1976], 0
    ; lit x50 <- 14;
    mov qword [rsp + 1960], 14
    ; lit x51 <- 7;
    mov qword [rsp + 1944], 7
    ; lit x52 <- 13;
    mov qword [rsp + 1928], 13
    ; let x48: Vec4 = Vec4(x49, x50, x51, x52);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1960]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59050
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59051

lab59050:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59048
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59041
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59039
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59040

lab59039:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59040:

lab59041:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59044
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59042
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59043

lab59042:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59043:

lab59044:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59047
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59045
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59046

lab59045:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59046:

lab59047:
    jmp lab59049

lab59048:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59049:

lab59051:
    ; ##store link to previous block
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59063
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59064

lab59063:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59061
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59054
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59052
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59053

lab59052:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59053:

lab59054:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59057
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59055
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59056

lab59055:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59056:

lab59057:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59060
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59058
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59059

lab59058:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59059:

lab59060:
    jmp lab59062

lab59061:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59062:

lab59064:
    ; #load tag
    mov qword [rsp + 1976], 0
    ; lit x55 <- 13;
    mov qword [rsp + 1960], 13
    ; lit x56 <- 13;
    mov qword [rsp + 1944], 13
    ; lit x57 <- 16;
    mov qword [rsp + 1928], 16
    ; lit x58 <- 14;
    mov qword [rsp + 1912], 14
    ; let x54: Vec4 = Vec4(x55, x56, x57, x58);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1912]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1928]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1944]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1952], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59076
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59077

lab59076:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59074
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59067
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59065
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59066

lab59065:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59066:

lab59067:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59070
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59068
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59069

lab59068:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59069:

lab59070:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59073
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59071
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59072

lab59071:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59072:

lab59073:
    jmp lab59075

lab59074:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59075:

lab59077:
    ; ##store link to previous block
    mov rcx, [rsp + 1952]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59089
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59090

lab59089:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59087
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59080
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59078
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59079

lab59078:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59079:

lab59080:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59083
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59081
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59082

lab59081:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59082:

lab59083:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59086
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59084
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59085

lab59084:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59085:

lab59086:
    jmp lab59088

lab59087:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59088:

lab59090:
    ; #load tag
    mov qword [rsp + 1960], 0
    ; lit x61 <- 14;
    mov qword [rsp + 1944], 14
    ; lit x62 <- 11;
    mov qword [rsp + 1928], 11
    ; lit x63 <- 16;
    mov qword [rsp + 1912], 16
    ; lit x64 <- 12;
    mov qword [rsp + 1896], 12
    ; let x60: Vec4 = Vec4(x61, x62, x63, x64);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1928]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59102
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59103

lab59102:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59100
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59093
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59091
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59092

lab59091:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59092:

lab59093:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59096
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59094
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59095

lab59094:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59095:

lab59096:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59099
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59097
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59098

lab59097:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59098:

lab59099:
    jmp lab59101

lab59100:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59101:

lab59103:
    ; ##store link to previous block
    mov rcx, [rsp + 1936]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1952], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59115
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59116

lab59115:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59113
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59106
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59104
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59105

lab59104:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59105:

lab59106:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59109
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59107
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59108

lab59107:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59108:

lab59109:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59112
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59110
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59111

lab59110:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59111:

lab59112:
    jmp lab59114

lab59113:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59114:

lab59116:
    ; #load tag
    mov qword [rsp + 1944], 0
    ; lit x67 <- 15;
    mov qword [rsp + 1928], 15
    ; lit x68 <- 9;
    mov qword [rsp + 1912], 9
    ; lit x69 <- 16;
    mov qword [rsp + 1896], 16
    ; lit x70 <- 10;
    mov qword [rsp + 1880], 10
    ; let x66: Vec4 = Vec4(x67, x68, x69, x70);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1880]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1896]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1912]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1920], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59128
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59129

lab59128:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59126
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59119
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59117
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59118

lab59117:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59118:

lab59119:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59122
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59120
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59121

lab59120:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59121:

lab59122:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59125
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59123
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59124

lab59123:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59124:

lab59125:
    jmp lab59127

lab59126:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59127:

lab59129:
    ; ##store link to previous block
    mov rcx, [rsp + 1920]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59141
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59142

lab59141:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59139
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59132
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59130
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59131

lab59130:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59131:

lab59132:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59135
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59133
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59134

lab59133:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59134:

lab59135:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59138
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59136
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59137

lab59136:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59137:

lab59138:
    jmp lab59140

lab59139:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59140:

lab59142:
    ; #load tag
    mov qword [rsp + 1928], 0
    ; lit x73 <- 16;
    mov qword [rsp + 1912], 16
    ; lit x74 <- 0;
    mov qword [rsp + 1896], 0
    ; lit x75 <- 10;
    mov qword [rsp + 1880], 10
    ; lit x76 <- 4;
    mov qword [rsp + 1864], 4
    ; let x72: Vec4 = Vec4(x73, x74, x75, x76);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1864]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1880]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1896]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1904], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59154
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59155

lab59154:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59152
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59145
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59143
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59144

lab59143:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59144:

lab59145:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59148
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59146
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59147

lab59146:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59147:

lab59148:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59151
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59149
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59150

lab59149:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59150:

lab59151:
    jmp lab59153

lab59152:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59153:

lab59155:
    ; ##store link to previous block
    mov rcx, [rsp + 1904]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1920], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59167
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59168

lab59167:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59165
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59158
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59156
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59157

lab59156:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59157:

lab59158:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59161
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59159
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59160

lab59159:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59160:

lab59161:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59164
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59162
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59163

lab59162:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59163:

lab59164:
    jmp lab59166

lab59165:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59166:

lab59168:
    ; #load tag
    mov qword [rsp + 1912], 0
    ; lit x79 <- 10;
    mov qword [rsp + 1896], 10
    ; lit x80 <- 4;
    mov qword [rsp + 1880], 4
    ; lit x81 <- 8;
    mov qword [rsp + 1864], 8
    ; lit x82 <- 6;
    mov qword [rsp + 1848], 6
    ; let x78: Vec4 = Vec4(x79, x80, x81, x82);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1848]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1864]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1880]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1888], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59180
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59181

lab59180:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59178
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59171
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59169
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59170

lab59169:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59170:

lab59171:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59174
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59172
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59173

lab59172:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59173:

lab59174:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59177
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59175
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59176

lab59175:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59176:

lab59177:
    jmp lab59179

lab59178:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59179:

lab59181:
    ; ##store link to previous block
    mov rcx, [rsp + 1888]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1904], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59193
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59194

lab59193:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59191
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59184
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59182
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59183

lab59182:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59183:

lab59184:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59187
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59185
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59186

lab59185:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59186:

lab59187:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59190
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59188
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59189

lab59188:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59189:

lab59190:
    jmp lab59192

lab59191:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59192:

lab59194:
    ; #load tag
    mov qword [rsp + 1896], 0
    ; lit x85 <- 8;
    mov qword [rsp + 1880], 8
    ; lit x86 <- 6;
    mov qword [rsp + 1864], 6
    ; lit x87 <- 7;
    mov qword [rsp + 1848], 7
    ; lit x88 <- 8;
    mov qword [rsp + 1832], 8
    ; let x84: Vec4 = Vec4(x85, x86, x87, x88);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1832]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1848]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1864]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1872], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59206
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59207

lab59206:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59204
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59197
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59195
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59196

lab59195:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59196:

lab59197:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59200
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59198
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59199

lab59198:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59199:

lab59200:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59203
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59201
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59202

lab59201:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59202:

lab59203:
    jmp lab59205

lab59204:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59205:

lab59207:
    ; ##store link to previous block
    mov rcx, [rsp + 1872]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1880]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1888], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59219
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59220

lab59219:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59217
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59210
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59208
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59209

lab59208:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59209:

lab59210:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59213
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59211
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59212

lab59211:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59212:

lab59213:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59216
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59214
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59215

lab59214:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59215:

lab59216:
    jmp lab59218

lab59217:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59218:

lab59220:
    ; #load tag
    mov qword [rsp + 1880], 0
    ; lit x91 <- 7;
    mov qword [rsp + 1864], 7
    ; lit x92 <- 8;
    mov qword [rsp + 1848], 8
    ; lit x93 <- 7;
    mov qword [rsp + 1832], 7
    ; lit x94 <- 13;
    mov qword [rsp + 1816], 13
    ; let x90: Vec4 = Vec4(x91, x92, x93, x94);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1816]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1832]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1848]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1856], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59232
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59233

lab59232:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59230
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59223
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59221
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59222

lab59221:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59222:

lab59223:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59226
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59224
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59225

lab59224:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59225:

lab59226:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59229
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59227
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59228

lab59227:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59228:

lab59229:
    jmp lab59231

lab59230:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59231:

lab59233:
    ; ##store link to previous block
    mov rcx, [rsp + 1856]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1864]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1872], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59245
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59246

lab59245:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59243
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59236
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59234
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59235

lab59234:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59235:

lab59236:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59239
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59237
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59238

lab59237:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59238:

lab59239:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59242
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59240
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59241

lab59240:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59241:

lab59242:
    jmp lab59244

lab59243:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59244:

lab59246:
    ; #load tag
    mov qword [rsp + 1864], 0
    ; lit x97 <- 7;
    mov qword [rsp + 1848], 7
    ; lit x98 <- 13;
    mov qword [rsp + 1832], 13
    ; lit x99 <- 8;
    mov qword [rsp + 1816], 8
    ; lit x100 <- 16;
    mov qword [rsp + 1800], 16
    ; let x96: Vec4 = Vec4(x97, x98, x99, x100);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1800]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1816]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1832]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1840], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59258
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59259

lab59258:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59256
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59249
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59247
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59248

lab59247:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59248:

lab59249:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59252
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59250
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59251

lab59250:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59251:

lab59252:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59255
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59253
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59254

lab59253:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59254:

lab59255:
    jmp lab59257

lab59256:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59257:

lab59259:
    ; ##store link to previous block
    mov rcx, [rsp + 1840]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1848]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1856], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59271
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59272

lab59271:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59269
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59262
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59260
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59261

lab59260:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59261:

lab59262:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59265
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59263
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59264

lab59263:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59264:

lab59265:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59268
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59266
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59267

lab59266:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59267:

lab59268:
    jmp lab59270

lab59269:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59270:

lab59272:
    ; #load tag
    mov qword [rsp + 1848], 0
    ; lit x103 <- 12;
    mov qword [rsp + 1832], 12
    ; lit x104 <- 16;
    mov qword [rsp + 1816], 16
    ; lit x105 <- 13;
    mov qword [rsp + 1800], 13
    ; lit x106 <- 13;
    mov qword [rsp + 1784], 13
    ; let x102: Vec4 = Vec4(x103, x104, x105, x106);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1784]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1800]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1816]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1824], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59284
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59285

lab59284:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59282
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59275
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59273
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59274

lab59273:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59274:

lab59275:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59278
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59276
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59277

lab59276:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59277:

lab59278:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59281
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59279
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59280

lab59279:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59280:

lab59281:
    jmp lab59283

lab59282:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59283:

lab59285:
    ; ##store link to previous block
    mov rcx, [rsp + 1824]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1832]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1840], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59297
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59298

lab59297:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59295
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59288
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59286
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59287

lab59286:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59287:

lab59288:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59291
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59289
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59290

lab59289:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59290:

lab59291:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59294
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59292
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59293

lab59292:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59293:

lab59294:
    jmp lab59296

lab59295:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59296:

lab59298:
    ; #load tag
    mov qword [rsp + 1832], 0
    ; lit x109 <- 13;
    mov qword [rsp + 1816], 13
    ; lit x110 <- 13;
    mov qword [rsp + 1800], 13
    ; lit x111 <- 14;
    mov qword [rsp + 1784], 14
    ; lit x112 <- 11;
    mov qword [rsp + 1768], 11
    ; let x108: Vec4 = Vec4(x109, x110, x111, x112);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1768]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1784]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1800]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1808], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59310
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59311

lab59310:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59308
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59301
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59299
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59300

lab59299:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59300:

lab59301:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59304
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59302
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59303

lab59302:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59303:

lab59304:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59307
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59305
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59306

lab59305:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59306:

lab59307:
    jmp lab59309

lab59308:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59309:

lab59311:
    ; ##store link to previous block
    mov rcx, [rsp + 1808]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1816]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1824], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59323
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59324

lab59323:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59321
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59314
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59312
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59313

lab59312:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59313:

lab59314:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59317
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59315
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59316

lab59315:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59316:

lab59317:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59320
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59318
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59319

lab59318:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59319:

lab59320:
    jmp lab59322

lab59321:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59322:

lab59324:
    ; #load tag
    mov qword [rsp + 1816], 0
    ; lit x115 <- 14;
    mov qword [rsp + 1800], 14
    ; lit x116 <- 11;
    mov qword [rsp + 1784], 11
    ; lit x117 <- 15;
    mov qword [rsp + 1768], 15
    ; lit x118 <- 9;
    mov qword [rsp + 1752], 9
    ; let x114: Vec4 = Vec4(x115, x116, x117, x118);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1752]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1768]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1784]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1792], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59336
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59337

lab59336:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59334
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59327
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59325
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59326

lab59325:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59326:

lab59327:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59330
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59328
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59329

lab59328:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59329:

lab59330:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59333
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59331
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59332

lab59331:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59332:

lab59333:
    jmp lab59335

lab59334:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59335:

lab59337:
    ; ##store link to previous block
    mov rcx, [rsp + 1792]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1800]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1808], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59349
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59350

lab59349:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59347
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59340
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59338
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59339

lab59338:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59339:

lab59340:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59343
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59341
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59342

lab59341:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59342:

lab59343:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59346
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59344
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59345

lab59344:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59345:

lab59346:
    jmp lab59348

lab59347:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59348:

lab59350:
    ; #load tag
    mov qword [rsp + 1800], 0
    ; lit x121 <- 15;
    mov qword [rsp + 1784], 15
    ; lit x122 <- 9;
    mov qword [rsp + 1768], 9
    ; lit x123 <- 16;
    mov qword [rsp + 1752], 16
    ; lit x124 <- 8;
    mov qword [rsp + 1736], 8
    ; let x120: Vec4 = Vec4(x121, x122, x123, x124);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1736]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1752]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1768]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1776], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59362
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59363

lab59362:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59360
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59353
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59351
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59352

lab59351:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59352:

lab59353:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59356
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59354
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59355

lab59354:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59355:

lab59356:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59359
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59357
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59358

lab59357:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59358:

lab59359:
    jmp lab59361

lab59360:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59361:

lab59363:
    ; ##store link to previous block
    mov rcx, [rsp + 1776]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1784]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1792], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59375
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59376

lab59375:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59373
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59366
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59364
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59365

lab59364:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59365:

lab59366:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59369
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59367
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59368

lab59367:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59368:

lab59369:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59372
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59370
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59371

lab59370:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59371:

lab59372:
    jmp lab59374

lab59373:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59374:

lab59376:
    ; #load tag
    mov qword [rsp + 1784], 0
    ; lit x127 <- 10;
    mov qword [rsp + 1768], 10
    ; lit x128 <- 16;
    mov qword [rsp + 1752], 16
    ; lit x129 <- 11;
    mov qword [rsp + 1736], 11
    ; lit x130 <- 10;
    mov qword [rsp + 1720], 10
    ; let x126: Vec4 = Vec4(x127, x128, x129, x130);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1720]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1736]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1752]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1760], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59388
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59389

lab59388:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59386
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59379
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59377
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59378

lab59377:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59378:

lab59379:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59382
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59380
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59381

lab59380:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59381:

lab59382:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59385
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59383
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59384

lab59383:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59384:

lab59385:
    jmp lab59387

lab59386:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59387:

lab59389:
    ; ##store link to previous block
    mov rcx, [rsp + 1760]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1768]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1776], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59401
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59402

lab59401:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59399
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59392
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59390
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59391

lab59390:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59391:

lab59392:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59395
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59393
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59394

lab59393:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59394:

lab59395:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59398
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59396
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59397

lab59396:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59397:

lab59398:
    jmp lab59400

lab59399:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59400:

lab59402:
    ; #load tag
    mov qword [rsp + 1768], 0
    ; lit x133 <- 12;
    mov qword [rsp + 1752], 12
    ; lit x134 <- 4;
    mov qword [rsp + 1736], 4
    ; lit x135 <- 10;
    mov qword [rsp + 1720], 10
    ; lit x136 <- 6;
    mov qword [rsp + 1704], 6
    ; let x132: Vec4 = Vec4(x133, x134, x135, x136);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1704]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1720]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1736]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1744], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59414
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59415

lab59414:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59412
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59405
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59403
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59404

lab59403:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59404:

lab59405:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59408
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59406
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59407

lab59406:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59407:

lab59408:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59411
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59409
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59410

lab59409:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59410:

lab59411:
    jmp lab59413

lab59412:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59413:

lab59415:
    ; ##store link to previous block
    mov rcx, [rsp + 1744]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1752]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1760], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59427
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59428

lab59427:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59425
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59418
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59416
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59417

lab59416:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59417:

lab59418:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59421
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59419
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59420

lab59419:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59420:

lab59421:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59424
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59422
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59423

lab59422:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59423:

lab59424:
    jmp lab59426

lab59425:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59426:

lab59428:
    ; #load tag
    mov qword [rsp + 1752], 0
    ; lit x139 <- 10;
    mov qword [rsp + 1736], 10
    ; lit x140 <- 6;
    mov qword [rsp + 1720], 6
    ; lit x141 <- 12;
    mov qword [rsp + 1704], 12
    ; lit x142 <- 7;
    mov qword [rsp + 1688], 7
    ; let x138: Vec4 = Vec4(x139, x140, x141, x142);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1688]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1704]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1720]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1728], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59440
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59441

lab59440:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59438
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59431
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59429
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59430

lab59429:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59430:

lab59431:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59434
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59432
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59433

lab59432:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59433:

lab59434:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59437
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59435
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59436

lab59435:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59436:

lab59437:
    jmp lab59439

lab59438:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59439:

lab59441:
    ; ##store link to previous block
    mov rcx, [rsp + 1728]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1736]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1744], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59453
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59454

lab59453:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59451
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59444
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59442
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59443

lab59442:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59443:

lab59444:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59447
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59445
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59446

lab59445:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59446:

lab59447:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59450
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59448
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59449

lab59448:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59449:

lab59450:
    jmp lab59452

lab59451:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59452:

lab59454:
    ; #load tag
    mov qword [rsp + 1736], 0
    ; lit x145 <- 12;
    mov qword [rsp + 1720], 12
    ; lit x146 <- 7;
    mov qword [rsp + 1704], 7
    ; lit x147 <- 12;
    mov qword [rsp + 1688], 12
    ; lit x148 <- 4;
    mov qword [rsp + 1672], 4
    ; let x144: Vec4 = Vec4(x145, x146, x147, x148);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1672]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1688]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1704]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1712], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59466
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59467

lab59466:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59464
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59457
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59455
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59456

lab59455:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59456:

lab59457:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59460
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59458
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59459

lab59458:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59459:

lab59460:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59463
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59461
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59462

lab59461:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59462:

lab59463:
    jmp lab59465

lab59464:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59465:

lab59467:
    ; ##store link to previous block
    mov rcx, [rsp + 1712]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1720]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1728], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59479
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59480

lab59479:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59477
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59470
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59468
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59469

lab59468:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59469:

lab59470:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59473
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59471
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59472

lab59471:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59472:

lab59473:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59476
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59474
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59475

lab59474:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59475:

lab59476:
    jmp lab59478

lab59477:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59478:

lab59480:
    ; #load tag
    mov qword [rsp + 1720], 0
    ; lit x151 <- 15;
    mov qword [rsp + 1704], 15
    ; lit x152 <- 5;
    mov qword [rsp + 1688], 5
    ; lit x153 <- 13;
    mov qword [rsp + 1672], 13
    ; lit x154 <- 7;
    mov qword [rsp + 1656], 7
    ; let x150: Vec4 = Vec4(x151, x152, x153, x154);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1656]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1672]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1688]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1696], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59492
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59493

lab59492:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59490
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59483
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59481
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59482

lab59481:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59482:

lab59483:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59486
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59484
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59485

lab59484:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59485:

lab59486:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59489
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59487
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59488

lab59487:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59488:

lab59489:
    jmp lab59491

lab59490:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59491:

lab59493:
    ; ##store link to previous block
    mov rcx, [rsp + 1696]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1704]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1712], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59505
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59506

lab59505:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59503
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59496
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59494
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59495

lab59494:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59495:

lab59496:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59499
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59497
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59498

lab59497:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59498:

lab59499:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59502
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59500
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59501

lab59500:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59501:

lab59502:
    jmp lab59504

lab59503:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59504:

lab59506:
    ; #load tag
    mov qword [rsp + 1704], 0
    ; lit x157 <- 13;
    mov qword [rsp + 1688], 13
    ; lit x158 <- 7;
    mov qword [rsp + 1672], 7
    ; lit x159 <- 15;
    mov qword [rsp + 1656], 15
    ; lit x160 <- 8;
    mov qword [rsp + 1640], 8
    ; let x156: Vec4 = Vec4(x157, x158, x159, x160);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1640]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1656]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1672]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1680], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59518
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59519

lab59518:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59516
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59509
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59507
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59508

lab59507:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59508:

lab59509:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59512
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59510
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59511

lab59510:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59511:

lab59512:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59515
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59513
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59514

lab59513:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59514:

lab59515:
    jmp lab59517

lab59516:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59517:

lab59519:
    ; ##store link to previous block
    mov rcx, [rsp + 1680]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1688]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1696], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59531
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59532

lab59531:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59529
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59522
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59520
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59521

lab59520:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59521:

lab59522:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59525
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59523
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59524

lab59523:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59524:

lab59525:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59528
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59526
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59527

lab59526:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59527:

lab59528:
    jmp lab59530

lab59529:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59530:

lab59532:
    ; #load tag
    mov qword [rsp + 1688], 0
    ; lit x163 <- 15;
    mov qword [rsp + 1672], 15
    ; lit x164 <- 8;
    mov qword [rsp + 1656], 8
    ; lit x165 <- 15;
    mov qword [rsp + 1640], 15
    ; lit x166 <- 5;
    mov qword [rsp + 1624], 5
    ; let x162: Vec4 = Vec4(x163, x164, x165, x166);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1624]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1640]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1656]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1664], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59544
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59545

lab59544:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59542
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59535
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59533
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59534

lab59533:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59534:

lab59535:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59538
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59536
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59537

lab59536:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59537:

lab59538:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59541
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59539
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59540

lab59539:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59540:

lab59541:
    jmp lab59543

lab59542:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59543:

lab59545:
    ; ##store link to previous block
    mov rcx, [rsp + 1664]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1672]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1680], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59557
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59558

lab59557:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59555
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59548
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59546
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59547

lab59546:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59547:

lab59548:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59551
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59549
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59550

lab59549:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59550:

lab59551:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59554
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59552
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59553

lab59552:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59553:

lab59554:
    jmp lab59556

lab59555:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59556:

lab59558:
    ; #load tag
    mov qword [rsp + 1672], 0
    ; let x167: List[Vec4] = Nil();
    ; #mark no allocation
    mov qword [rsp + 1664], 0
    ; #load tag
    mov qword [rsp + 1656], 0
    ; let x161: List[Vec4] = Cons(x162, x167);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1656]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1664]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1672]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1680]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1680], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59570
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59571

lab59570:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59568
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59561
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59559
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59560

lab59559:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59560:

lab59561:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59564
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59562
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59563

lab59562:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59563:

lab59564:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59567
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59565
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59566

lab59565:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59566:

lab59567:
    jmp lab59569

lab59568:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59569:

lab59571:
    ; #load tag
    mov qword [rsp + 1672], 5
    ; let x155: List[Vec4] = Cons(x156, x161);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1672]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1680]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1688]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1696]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1696], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59583
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59584

lab59583:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59581
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59574
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59572
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59573

lab59572:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59573:

lab59574:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59577
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59575
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59576

lab59575:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59576:

lab59577:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59580
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59578
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59579

lab59578:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59579:

lab59580:
    jmp lab59582

lab59581:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59582:

lab59584:
    ; #load tag
    mov qword [rsp + 1688], 5
    ; let x149: List[Vec4] = Cons(x150, x155);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1688]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1696]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1704]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1712]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1712], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59596
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59597

lab59596:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59594
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59587
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59585
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59586

lab59585:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59586:

lab59587:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59590
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59588
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59589

lab59588:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59589:

lab59590:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59593
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59591
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59592

lab59591:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59592:

lab59593:
    jmp lab59595

lab59594:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59595:

lab59597:
    ; #load tag
    mov qword [rsp + 1704], 5
    ; let x143: List[Vec4] = Cons(x144, x149);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1704]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1712]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1720]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1728]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1728], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59609
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59610

lab59609:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59607
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59600
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59598
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59599

lab59598:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59599:

lab59600:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59603
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59601
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59602

lab59601:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59602:

lab59603:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59606
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59604
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59605

lab59604:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59605:

lab59606:
    jmp lab59608

lab59607:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59608:

lab59610:
    ; #load tag
    mov qword [rsp + 1720], 5
    ; let x137: List[Vec4] = Cons(x138, x143);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1720]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1728]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1736]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1744]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1744], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59622
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59623

lab59622:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59620
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59613
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59611
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59612

lab59611:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59612:

lab59613:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59616
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59614
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59615

lab59614:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59615:

lab59616:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59619
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59617
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59618

lab59617:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59618:

lab59619:
    jmp lab59621

lab59620:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59621:

lab59623:
    ; #load tag
    mov qword [rsp + 1736], 5
    ; let x131: List[Vec4] = Cons(x132, x137);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1736]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1744]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1752]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1760]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1760], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59635
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59636

lab59635:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59633
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59626
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59624
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59625

lab59624:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59625:

lab59626:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59629
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59627
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59628

lab59627:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59628:

lab59629:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59632
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59630
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59631

lab59630:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59631:

lab59632:
    jmp lab59634

lab59633:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59634:

lab59636:
    ; #load tag
    mov qword [rsp + 1752], 5
    ; let x125: List[Vec4] = Cons(x126, x131);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1752]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1760]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1768]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1776]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1776], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59648
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59649

lab59648:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59646
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59639
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59637
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59638

lab59637:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59638:

lab59639:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59642
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59640
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59641

lab59640:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59641:

lab59642:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59645
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59643
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59644

lab59643:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59644:

lab59645:
    jmp lab59647

lab59646:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59647:

lab59649:
    ; #load tag
    mov qword [rsp + 1768], 5
    ; let x119: List[Vec4] = Cons(x120, x125);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1768]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1776]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1784]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1792]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1792], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59661
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59662

lab59661:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59659
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59652
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59650
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59651

lab59650:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59651:

lab59652:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59655
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59653
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59654

lab59653:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59654:

lab59655:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59658
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59656
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59657

lab59656:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59657:

lab59658:
    jmp lab59660

lab59659:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59660:

lab59662:
    ; #load tag
    mov qword [rsp + 1784], 5
    ; let x113: List[Vec4] = Cons(x114, x119);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1784]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1792]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1800]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1808]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1808], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59674
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59675

lab59674:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59672
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59665
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59663
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59664

lab59663:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59664:

lab59665:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59668
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59666
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59667

lab59666:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59667:

lab59668:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59671
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59669
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59670

lab59669:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59670:

lab59671:
    jmp lab59673

lab59672:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59673:

lab59675:
    ; #load tag
    mov qword [rsp + 1800], 5
    ; let x107: List[Vec4] = Cons(x108, x113);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1800]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1808]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1816]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1824]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1824], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59687
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59688

lab59687:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59685
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59678
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59676
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59677

lab59676:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59677:

lab59678:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59681
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59679
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59680

lab59679:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59680:

lab59681:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59684
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59682
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59683

lab59682:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59683:

lab59684:
    jmp lab59686

lab59685:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59686:

lab59688:
    ; #load tag
    mov qword [rsp + 1816], 5
    ; let x101: List[Vec4] = Cons(x102, x107);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1816]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1824]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1832]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1840]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1840], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59700
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59701

lab59700:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59698
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59691
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59689
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59690

lab59689:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59690:

lab59691:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59694
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59692
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59693

lab59692:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59693:

lab59694:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59697
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59695
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59696

lab59695:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59696:

lab59697:
    jmp lab59699

lab59698:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59699:

lab59701:
    ; #load tag
    mov qword [rsp + 1832], 5
    ; let x95: List[Vec4] = Cons(x96, x101);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1832]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1840]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1848]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1856]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1856], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59713
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59714

lab59713:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59711
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59704
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59702
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59703

lab59702:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59703:

lab59704:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59707
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59705
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59706

lab59705:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59706:

lab59707:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59710
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59708
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59709

lab59708:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59709:

lab59710:
    jmp lab59712

lab59711:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59712:

lab59714:
    ; #load tag
    mov qword [rsp + 1848], 5
    ; let x89: List[Vec4] = Cons(x90, x95);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1848]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1856]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1864]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1872]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1872], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59726
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59727

lab59726:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59724
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59717
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59715
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59716

lab59715:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59716:

lab59717:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59720
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59718
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59719

lab59718:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59719:

lab59720:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59723
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59721
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59722

lab59721:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59722:

lab59723:
    jmp lab59725

lab59724:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59725:

lab59727:
    ; #load tag
    mov qword [rsp + 1864], 5
    ; let x83: List[Vec4] = Cons(x84, x89);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1864]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1872]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1880]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1888]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1888], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59739
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59740

lab59739:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59737
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59730
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59728
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59729

lab59728:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59729:

lab59730:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59733
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59731
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59732

lab59731:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59732:

lab59733:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59736
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59734
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59735

lab59734:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59735:

lab59736:
    jmp lab59738

lab59737:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59738:

lab59740:
    ; #load tag
    mov qword [rsp + 1880], 5
    ; let x77: List[Vec4] = Cons(x78, x83);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1880]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1888]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1896]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1904]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1904], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59752
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59753

lab59752:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59750
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59743
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59741
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59742

lab59741:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59742:

lab59743:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59746
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59744
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59745

lab59744:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59745:

lab59746:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59749
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59747
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59748

lab59747:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59748:

lab59749:
    jmp lab59751

lab59750:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59751:

lab59753:
    ; #load tag
    mov qword [rsp + 1896], 5
    ; let x71: List[Vec4] = Cons(x72, x77);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1904]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1920]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1920], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59765
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59766

lab59765:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59763
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59756
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59754
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59755

lab59754:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59755:

lab59756:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59759
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59757
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59758

lab59757:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59758:

lab59759:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59762
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59760
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59761

lab59760:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59761:

lab59762:
    jmp lab59764

lab59763:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59764:

lab59766:
    ; #load tag
    mov qword [rsp + 1912], 5
    ; let x65: List[Vec4] = Cons(x66, x71);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1912]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1920]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1928]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1936]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59778
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59779

lab59778:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59776
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59769
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59767
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59768

lab59767:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59768:

lab59769:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59772
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59770
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59771

lab59770:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59771:

lab59772:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59775
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59773
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59774

lab59773:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59774:

lab59775:
    jmp lab59777

lab59776:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59777:

lab59779:
    ; #load tag
    mov qword [rsp + 1928], 5
    ; let x59: List[Vec4] = Cons(x60, x65);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1936]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1952]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1952], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59791
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59792

lab59791:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59789
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59782
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59780
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59781

lab59780:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59781:

lab59782:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59785
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59783
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59784

lab59783:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59784:

lab59785:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59788
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59786
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59787

lab59786:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59787:

lab59788:
    jmp lab59790

lab59789:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59790:

lab59792:
    ; #load tag
    mov qword [rsp + 1944], 5
    ; let x53: List[Vec4] = Cons(x54, x59);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1952]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59804
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59805

lab59804:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59802
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59795
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59793
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59794

lab59793:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59794:

lab59795:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59798
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59796
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59797

lab59796:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59797:

lab59798:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59801
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59799
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59800

lab59799:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59800:

lab59801:
    jmp lab59803

lab59802:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59803:

lab59805:
    ; #load tag
    mov qword [rsp + 1960], 5
    ; let x47: List[Vec4] = Cons(x48, x53);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59817
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59818

lab59817:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59815
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59808
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59806
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59807

lab59806:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59807:

lab59808:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59811
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59809
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59810

lab59809:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59810:

lab59811:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59814
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59812
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59813

lab59812:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59813:

lab59814:
    jmp lab59816

lab59815:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59816:

lab59818:
    ; #load tag
    mov qword [rsp + 1976], 5
    ; let x41: List[Vec4] = Cons(x42, x47);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59830
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59831

lab59830:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59828
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59821
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59819
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59820

lab59819:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59820:

lab59821:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59824
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59822
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59823

lab59822:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59823:

lab59824:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59827
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59825
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59826

lab59825:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59826:

lab59827:
    jmp lab59829

lab59828:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59829:

lab59831:
    ; #load tag
    mov qword [rsp + 1992], 5
    ; let x35: List[Vec4] = Cons(x36, x41);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59843
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59844

lab59843:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59841
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59834
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59832
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59833

lab59832:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59833:

lab59834:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59837
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59835
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59836

lab59835:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59836:

lab59837:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59840
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59838
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59839

lab59838:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59839:

lab59840:
    jmp lab59842

lab59841:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59842:

lab59844:
    ; #load tag
    mov qword [rsp + 2008], 5
    ; let x29: List[Vec4] = Cons(x30, x35);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59856
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59857

lab59856:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59854
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59847
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59845
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59846

lab59845:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59846:

lab59847:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59850
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59848
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59849

lab59848:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59849:

lab59850:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59853
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59851
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59852

lab59851:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59852:

lab59853:
    jmp lab59855

lab59854:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59855:

lab59857:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; let x23: List[Vec4] = Cons(x24, x29);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59869
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab59870

lab59869:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59867
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59860
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59858
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59859

lab59858:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59859:

lab59860:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59863
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59861
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59862

lab59861:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59862:

lab59863:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59866
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59864
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59865

lab59864:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59865:

lab59866:
    jmp lab59868

lab59867:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59868:

lab59870:
    ; #load tag
    mov r15, 5
    ; let x17: List[Vec4] = Cons(x18, x23);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59882
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab59883

lab59882:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59880
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59873
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59871
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59872

lab59871:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59872:

lab59873:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59876
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59874
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59875

lab59874:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59875:

lab59876:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59879
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59877
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59878

lab59877:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59878:

lab59879:
    jmp lab59881

lab59880:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59881:

lab59883:
    ; #load tag
    mov r13, 5
    ; let x11: List[Vec4] = Cons(x12, x17);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59895
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab59896

lab59895:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59893
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59886
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59884
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59885

lab59884:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59885:

lab59886:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59889
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59887
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59888

lab59887:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59888:

lab59889:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59892
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59890
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59891

lab59890:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59891:

lab59892:
    jmp lab59894

lab59893:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59894:

lab59896:
    ; #load tag
    mov r11, 5
    ; let x5: List[Vec4] = Cons(x6, x11);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59908
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab59909

lab59908:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59906
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59899
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59897
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59898

lab59897:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59898:

lab59899:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59902
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59900
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59901

lab59900:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59901:

lab59902:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59905
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59903
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59904

lab59903:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59904:

lab59905:
    jmp lab59907

lab59906:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59907:

lab59909:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x5 !-> x5)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

nil_:
    ; substitute (a0 !-> a0);
    ; #erase a
    cmp rax, 0
    je lab59912
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab59910
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab59911

lab59910:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab59911:

lab59912:
    ; #erase b
    cmp rsi, 0
    je lab59915
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab59913
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab59914

lab59913:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab59914:

lab59915:
    ; #erase c
    cmp r8, 0
    je lab59918
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab59916
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab59917

lab59916:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab59917:

lab59918:
    ; #move variables
    mov rax, r10
    mov rdx, r11
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

tup2_:
    ; substitute (a0 !-> a0)(c_d !-> c_d)(a_b !-> a_b);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch a_b \{ ... \};
    ; #if there is only one clause, we can just fall through

Vec_59919:

Vec_59919_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab59920
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    jmp lab59921

lab59920:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]

lab59921:
    ; substitute (a0 !-> a0)(b !-> b)(a !-> a)(c_d !-> c_d);
    ; #move variables
    mov r10, rsi
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch c_d \{ ... \};
    ; #if there is only one clause, we can just fall through

Vec_59922:

Vec_59922_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab59923
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]
    jmp lab59924

lab59923:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]

lab59924:
    ; substitute (a !-> a)(b !-> b)(c !-> c)(d !-> d)(a0 !-> a0);
    ; #move variables
    mov r12, rax
    mov rcx, r9
    mov r9, r11
    mov r11, r13
    mov r13, rdx
    mov rdx, rcx
    ; invoke a0 Vec4
    jmp r13

grid_lscomp_:
    ; substitute (a0 !-> a0)(m !-> m)(n !-> n)(a !-> a)(b !-> b)(c !-> c)(ls !-> ls);
    ; #move variables
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], rax
    mov rax, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Vec4_59925]
    add rcx, [rsp + 2024]
    jmp rcx

List_Vec4_59925:
    jmp near List_Vec4_59925_Nil
    jmp near List_Vec4_59925_Cons

List_Vec4_59925_Nil:
    ; substitute (a0 !-> a0);
    ; #erase a
    cmp r10, 0
    je lab59928
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab59926
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab59927

lab59926:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab59927:

lab59928:
    ; #erase b
    cmp r12, 0
    je lab59931
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab59929
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab59930

lab59929:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab59930:

lab59931:
    ; #erase c
    cmp r14, 0
    je lab59934
    ; ######check refcount
    cmp qword [r14 + 0], 0
    je lab59932
    ; ######either decrement refcount ...
    add qword [r14 + 0], -1
    jmp lab59933

lab59932:
    ; ######... or add block to lazy free list
    mov [r14 + 0], rbp
    mov rbp, r14

lab59933:

lab59934:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Vec4_59925_Cons:
    ; #load from memory
    mov rcx, [rsp + 2032]
    ; ##check refcount
    cmp qword [rcx + 0], 0
    je lab59937
    ; ##either decrement refcount and share children...
    add qword [rcx + 0], -1
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab59935
    ; ####increment refcount
    add qword [rcx + 0], 1

lab59935:
    mov rcx, [rax + 40]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 32]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab59936
    ; ####increment refcount
    add qword [rcx + 0], 1

lab59936:
    mov rax, [rsp + 2040]
    jmp lab59938

lab59937:
    ; ##... or release blocks onto linear free list when loading
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2016], rcx
    mov rcx, [rax + 40]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 32]
    mov [rsp + 2032], rcx
    mov rax, [rsp + 2040]

lab59938:
    ; substitute (a0 !-> a0)(m !-> m)(n !-> n)(a !-> a)(b !-> b)(c !-> c)(t !-> t)(v !-> v);
    ; #move variables
    mov rcx, [rsp + 2016]
    mov [rsp + 2040], rcx
    mov rcx, [rsp + 2032]
    mov [rsp + 2016], rcx
    mov rcx, [rsp + 2040]
    mov [rsp + 2032], rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2040], rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2008], rcx
    mov rcx, [rsp + 2040]
    mov [rsp + 2024], rcx
    ; switch v \{ ... \};
    ; #if there is only one clause, we can just fall through

Vec4_59939:

Vec4_59939_Vec4:
    ; #load from memory
    mov rcx, [rsp + 2016]
    ; ##check refcount
    cmp qword [rcx + 0], 0
    je lab59940
    ; ##either decrement refcount and share children...
    add qword [rcx + 0], -1
    mov [rsp + 2040], rax
    mov rax, [rsp + 2016]
    ; ###load link to next block
    mov rcx, [rax + 48]
    mov [rsp + 2000], rcx
    ; ###load values
    mov rcx, [rax + 40]
    mov [rsp + 2008], rcx
    mov rax, [rsp + 2000]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1960], rcx
    mov rcx, [rax + 40]
    mov [rsp + 1976], rcx
    mov rcx, [rax + 24]
    mov [rsp + 1992], rcx
    mov rax, [rsp + 2040]
    jmp lab59941

lab59940:
    ; ##... or release blocks onto linear free list when loading
    mov [rsp + 2040], rax
    mov rax, [rsp + 2016]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rcx, [rax + 48]
    mov [rsp + 2000], rcx
    ; ###load values
    mov rcx, [rax + 40]
    mov [rsp + 2008], rcx
    mov rax, [rsp + 2000]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1960], rcx
    mov rcx, [rax + 40]
    mov [rsp + 1976], rcx
    mov rcx, [rax + 24]
    mov [rsp + 1992], rcx
    mov rax, [rsp + 2040]

lab59941:
    ; substitute (y1 !-> y1)(m0 !-> m)(n0 !-> n)(a12 !-> a)(b0 !-> b)(c0 !-> c)(x1 !-> x1)(x0 !-> x0)(y0 !-> y0)(t !-> t)(c !-> c)(a0 !-> a0)(m !-> m)(n !-> n)(a !-> a)(b !-> b);
    ; #share a
    cmp r10, 0
    je lab59942
    ; ####increment refcount
    add qword [r10 + 0], 1

lab59942:
    ; #share b
    cmp r12, 0
    je lab59943
    ; ####increment refcount
    add qword [r12 + 0], 1

lab59943:
    ; #share c
    cmp r14, 0
    je lab59944
    ; ####increment refcount
    add qword [r14 + 0], 1

lab59944:
    ; #move variables
    mov [rsp + 1952], rax
    mov [rsp + 1944], rdx
    mov [rsp + 1928], rdi
    mov [rsp + 1912], r9
    mov [rsp + 1904], r10
    mov [rsp + 1896], r11
    mov [rsp + 1888], r12
    mov [rsp + 1880], r13
    mov [rsp + 1968], r14
    mov rdx, [rsp + 1960]
    mov [rsp + 1960], r15
    mov rcx, [rsp + 2032]
    mov [rsp + 1984], rcx
    mov rcx, [rsp + 1976]
    mov [rsp + 2040], rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 1976], rcx
    mov rcx, [rsp + 2040]
    mov [rsp + 2024], rcx
    ; new a1: Vec4 = (t, c, a0, m, n, a, b)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1880]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1888]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1896]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1904]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 1912]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1920], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59956
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59957

lab59956:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59954
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59947
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59945
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59946

lab59945:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59946:

lab59947:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59950
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59948
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59949

lab59948:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59949:

lab59950:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59953
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59951
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59952

lab59951:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59952:

lab59953:
    jmp lab59955

lab59954:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59955:

lab59957:
    ; ##store link to previous block
    mov rcx, [rsp + 1920]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1944]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 1952]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1952], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59969
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59970

lab59969:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59967
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59960
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59958
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59959

lab59958:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59959:

lab59960:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59963
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59961
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59962

lab59961:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59962:

lab59963:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59966
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59964
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59965

lab59964:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59965:

lab59966:
    jmp lab59968

lab59967:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59968:

lab59970:
    ; ##store link to previous block
    mov rcx, [rsp + 1952]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 1976]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59982
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab59983

lab59982:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59980
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59973
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59971
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59972

lab59971:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59972:

lab59973:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59976
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59974
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59975

lab59974:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59975:

lab59976:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59979
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59977
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59978

lab59977:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59978:

lab59979:
    jmp lab59981

lab59980:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59981:

lab59983:
    ; #load tag
    lea rcx, [rel Vec4_59984]
    mov [rsp + 1976], rcx
    ; substitute (y0 !-> y0)(m00 !-> m0)(n00 !-> n0)(a120 !-> a12)(b00 !-> b0)(c00 !-> c0)(x0 !-> x0)(x1 !-> x1)(c0 !-> c0)(a1 !-> a1)(y1 !-> y1)(m0 !-> m0)(n0 !-> n0)(a12 !-> a12)(b0 !-> b0);
    ; #share a12
    cmp r10, 0
    je lab59985
    ; ####increment refcount
    add qword [r10 + 0], 1

lab59985:
    ; #share b0
    cmp r12, 0
    je lab59986
    ; ####increment refcount
    add qword [r12 + 0], 1

lab59986:
    ; #share c0
    cmp r14, 0
    je lab59987
    ; ####increment refcount
    add qword [r14 + 0], 1

lab59987:
    ; #move variables
    mov [rsp + 1960], rdx
    mov [rsp + 1944], rdi
    mov [rsp + 1928], r9
    mov [rsp + 1920], r10
    mov [rsp + 1912], r11
    mov [rsp + 1904], r12
    mov [rsp + 1896], r13
    mov [rsp + 2000], r14
    mov rdx, [rsp + 1992]
    mov [rsp + 1992], r15
    mov rcx, [rsp + 2008]
    mov [rsp + 2040], rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2008], rcx
    mov rcx, [rsp + 2040]
    mov [rsp + 2024], rcx
    ; new a2: Vec = (x1, c0, a1, y1, m0, n0, a12, b0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1904]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1920]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 1928]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab59999
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60000

lab59999:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab59997
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab59990
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59988
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59989

lab59988:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59989:

lab59990:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab59993
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59991
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59992

lab59991:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59992:

lab59993:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab59996
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab59994
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab59995

lab59994:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab59995:

lab59996:
    jmp lab59998

lab59997:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab59998:

lab60000:
    ; ##store link to previous block
    mov rcx, [rsp + 1936]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1960]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60012
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60013

lab60012:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60010
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60003
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60001
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60002

lab60001:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60002:

lab60003:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60006
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60004
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60005

lab60004:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60005:

lab60006:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60009
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60007
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60008

lab60007:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60008:

lab60009:
    jmp lab60011

lab60010:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60011:

lab60013:
    ; ##store link to previous block
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 1992]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60025
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60026

lab60025:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60023
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60016
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60014
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60015

lab60014:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60015:

lab60016:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60019
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60017
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60018

lab60017:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60018:

lab60019:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60022
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60020
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60021

lab60020:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60021:

lab60022:
    jmp lab60024

lab60023:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60024:

lab60026:
    ; ##store link to previous block
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60038
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60039

lab60038:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60036
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60029
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60027
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60028

lab60027:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60028:

lab60029:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60032
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60030
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60031

lab60030:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60031:

lab60032:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60035
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60033
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60034

lab60033:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60034:

lab60035:
    jmp lab60037

lab60036:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60037:

lab60039:
    ; #load tag
    lea rcx, [rel Vec_60040]
    mov [rsp + 2008], rcx
    ; substitute (x0 !-> x0)(m00 !-> m00)(b00 !-> b00)(a120 !-> a120)(n00 !-> n00)(c00 !-> c00)(y0 !-> y0)(a2 !-> a2);
    ; #move variables
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], rdx
    mov rdx, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    mov r8, r12
    ; new a3: Vec = (n00, c00, y0, a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov [rbx + 24], r15
    mov [rbx + 16], r14
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60052
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab60053

lab60052:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60050
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60043
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60041
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60042

lab60041:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60042:

lab60043:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60046
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60044
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60045

lab60044:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60045:

lab60046:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60049
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60047
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60048

lab60047:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60048:

lab60049:
    jmp lab60051

lab60050:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60051:

lab60053:
    ; ##store link to previous block
    mov [rbx + 48], r14
    ; ##store values
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60065
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab60066

lab60065:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60063
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60056
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60054
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60055

lab60054:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60055:

lab60056:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60059
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60057
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60058

lab60057:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60058:

lab60059:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60062
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60060
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60061

lab60060:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60061:

lab60062:
    jmp lab60064

lab60063:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60064:

lab60066:
    ; #load tag
    lea r13, [rel Vec_60067]
    ; new a4: Vec = (a120, a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60079
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab60080

lab60079:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60077
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60070
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60068
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60069

lab60068:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60069:

lab60070:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60073
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60071
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60072

lab60071:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60072:

lab60073:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60076
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60074
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60075

lab60074:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60075:

lab60076:
    jmp lab60078

lab60077:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60078:

lab60080:
    ; #load tag
    lea r11, [rel Vec_60081]
    ; substitute (b00 !-> b00)(x0 !-> x0)(m00 !-> m00)(a4 !-> a4);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    ; jump scale_vec2_
    jmp scale_vec2_

Vec_60081:

Vec_60081_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60084
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab60082
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60082:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60083
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60083:
    jmp lab60085

lab60084:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab60085:
    ; substitute (a3 !-> a3)(a120 !-> a120)(x20 !-> x20)(y10 !-> y10);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rsi, r8
    mov rax, r10
    ; let x5: Vec = Vec(x20, y10);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60097
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60098

lab60097:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60095
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60088
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60086
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60087

lab60086:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60087:

lab60088:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60091
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60089
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60090

lab60089:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60090:

lab60091:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60094
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60092
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60093

lab60092:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60093:

lab60094:
    jmp lab60096

lab60095:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60096:

lab60098:
    ; #load tag
    mov r9, 0
    ; substitute (a120 !-> a120)(x5 !-> x5)(a3 !-> a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump vec_add_
    jmp vec_add_

Vec_60067:

Vec_60067_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60101
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab60099
    ; ####increment refcount
    add qword [r14 + 0], 1

lab60099:
    mov r13, [r10 + 40]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab60100
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60100:
    jmp lab60102

lab60101:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab60102:
    ; substitute (a2 !-> a2)(y0 !-> y0)(n00 !-> n00)(c00 !-> c00)(x19 !-> x19)(y9 !-> y9);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    mov rax, r14
    ; let x4: Vec = Vec(x19, y9);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60114
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab60115

lab60114:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60112
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60105
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60103
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60104

lab60103:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60104:

lab60105:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60108
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60106
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60107

lab60106:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60107:

lab60108:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60111
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60109
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60110

lab60109:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60110:

lab60111:
    jmp lab60113

lab60112:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60113:

lab60115:
    ; #load tag
    mov r13, 0
    ; substitute (c00 !-> c00)(y0 !-> y0)(n00 !-> n00)(a2 !-> a2)(x4 !-> x4);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; new a5: Vec = (a2, x4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60127
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab60128

lab60127:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60125
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60118
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60116
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60117

lab60116:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60117:

lab60118:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60121
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60119
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60120

lab60119:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60120:

lab60121:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60124
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60122
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60123

lab60122:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60123:

lab60124:
    jmp lab60126

lab60125:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60126:

lab60128:
    ; #load tag
    lea r11, [rel Vec_60129]
    ; jump scale_vec2_
    jmp scale_vec2_

Vec_60129:

Vec_60129_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60132
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab60130
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60130:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60131
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60131:
    jmp lab60133

lab60132:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab60133:
    ; substitute (x4 !-> x4)(a2 !-> a2)(x18 !-> x18)(y8 !-> y8);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rsi, r8
    mov rax, r10
    ; let x6: Vec = Vec(x18, y8);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60145
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60146

lab60145:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60143
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60136
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60134
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60135

lab60134:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60135:

lab60136:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60139
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60137
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60138

lab60137:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60138:

lab60139:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60142
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60140
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60141

lab60140:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60141:

lab60142:
    jmp lab60144

lab60143:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60144:

lab60146:
    ; #load tag
    mov r9, 0
    ; substitute (x4 !-> x4)(x6 !-> x6)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump vec_add_
    jmp vec_add_

Vec_60040:

Vec_60040_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60151
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab60147
    ; ####increment refcount
    add qword [r12 + 0], 1

lab60147:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab60148
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60148:
    ; ###load link to next block
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    ; ###load values
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 24]
    mov [rsp + 2040], rax
    mov rax, [rsp + 2016]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1976], rcx
    mov rcx, [rax + 48]
    mov [rsp + 1984], rcx
    cmp rcx, 0
    je lab60149
    ; ####increment refcount
    add qword [rcx + 0], 1

lab60149:
    mov rcx, [rax + 40]
    mov [rsp + 1992], rcx
    mov rcx, [rax + 32]
    mov [rsp + 2000], rcx
    cmp rcx, 0
    je lab60150
    ; ####increment refcount
    add qword [rcx + 0], 1

lab60150:
    mov rcx, [rax + 24]
    mov [rsp + 2008], rcx
    mov rax, [rsp + 2040]
    jmp lab60152

lab60151:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load link to next block
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    ; ###load values
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 24]
    mov [rsp + 2040], rax
    mov rax, [rsp + 2016]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1976], rcx
    mov rcx, [rax + 48]
    mov [rsp + 1984], rcx
    mov rcx, [rax + 40]
    mov [rsp + 1992], rcx
    mov rcx, [rax + 32]
    mov [rsp + 2000], rcx
    mov rcx, [rax + 24]
    mov [rsp + 2008], rcx
    mov rax, [rsp + 2040]

lab60152:
    ; substitute (b0 !-> b0)(a12 !-> a12)(x1 !-> x1)(c0 !-> c0)(a1 !-> a1)(y1 !-> y1)(m0 !-> m0)(n0 !-> n0)(x17 !-> x17)(y7 !-> y7);
    ; #move variables
    mov rcx, [rsp + 1976]
    mov [rsp + 1976], rdi
    mov rdi, [rsp + 1992]
    mov [rsp + 1992], rdx
    mov rdx, rcx
    mov rsi, [rsp + 2000]
    mov rax, [rsp + 1984]
    ; let x3: Vec = Vec(x17, y7);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60164
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60165

lab60164:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60162
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60155
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60153
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60154

lab60153:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60154:

lab60155:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60158
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60156
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60157

lab60156:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60157:

lab60158:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60161
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60159
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60160

lab60159:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60160:

lab60161:
    jmp lab60163

lab60162:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60163:

lab60165:
    ; #load tag
    mov qword [rsp + 1992], 0
    ; substitute (b0 !-> b0)(a12 !-> a12)(x1 !-> x1)(c0 !-> c0)(n0 !-> n0)(y1 !-> y1)(m0 !-> m0)(a1 !-> a1)(x3 !-> x3);
    ; #move variables
    mov [rsp + 2016], r12
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r13
    mov r13, rcx
    ; new a6: Vec = (a1, x3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60177
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60178

lab60177:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60175
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60168
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60166
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60167

lab60166:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60167:

lab60168:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60171
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60169
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60170

lab60169:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60170:

lab60171:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60174
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60172
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60173

lab60172:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60173:

lab60174:
    jmp lab60176

lab60175:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60176:

lab60178:
    ; #load tag
    lea rcx, [rel Vec_60179]
    mov [rsp + 2008], rcx
    ; substitute (b0 !-> b0)(a12 !-> a12)(x1 !-> x1)(m0 !-> m0)(n0 !-> n0)(y1 !-> y1)(c0 !-> c0)(a6 !-> a6);
    ; #move variables
    mov [rsp + 2032], r10
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r11
    mov r11, rcx
    ; new a7: Vec = (n0, y1, c0, a6)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    mov [rbx + 24], r15
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60191
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab60192

lab60191:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60189
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60182
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60180
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60181

lab60180:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60181:

lab60182:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60185
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60183
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60184

lab60183:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60184:

lab60185:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60188
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60186
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60187

lab60186:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60187:

lab60188:
    jmp lab60190

lab60189:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60190:

lab60192:
    ; ##store link to previous block
    mov [rbx + 48], r14
    ; ##store values
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60204
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab60205

lab60204:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60202
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60195
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60193
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60194

lab60193:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60194:

lab60195:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60198
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60196
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60197

lab60196:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60197:

lab60198:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60201
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60199
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60200

lab60199:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60200:

lab60201:
    jmp lab60203

lab60202:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60203:

lab60205:
    ; #load tag
    lea r13, [rel Vec_60206]
    ; substitute (b0 !-> b0)(m0 !-> m0)(x1 !-> x1)(a12 !-> a12)(a7 !-> a7);
    ; #move variables
    mov r10, rsi
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; new a8: Vec = (a12, a7)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60218
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab60219

lab60218:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60216
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60209
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60207
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60208

lab60207:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60208:

lab60209:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60212
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60210
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60211

lab60210:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60211:

lab60212:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60215
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60213
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60214

lab60213:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60214:

lab60215:
    jmp lab60217

lab60216:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60217:

lab60219:
    ; #load tag
    lea r11, [rel Vec_60220]
    ; substitute (b0 !-> b0)(x1 !-> x1)(m0 !-> m0)(a8 !-> a8);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump scale_vec2_
    jmp scale_vec2_

Vec_60220:

Vec_60220_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60223
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab60221
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60221:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60222
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60222:
    jmp lab60224

lab60223:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab60224:
    ; substitute (a7 !-> a7)(a12 !-> a12)(x16 !-> x16)(y6 !-> y6);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rsi, r8
    mov rax, r10
    ; let x9: Vec = Vec(x16, y6);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60236
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60237

lab60236:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60234
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60227
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60225
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60226

lab60225:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60226:

lab60227:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60230
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60228
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60229

lab60228:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60229:

lab60230:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60233
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60231
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60232

lab60231:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60232:

lab60233:
    jmp lab60235

lab60234:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60235:

lab60237:
    ; #load tag
    mov r9, 0
    ; substitute (a12 !-> a12)(x9 !-> x9)(a7 !-> a7);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump vec_add_
    jmp vec_add_

Vec_60206:

Vec_60206_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60240
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab60238
    ; ####increment refcount
    add qword [r14 + 0], 1

lab60238:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab60239
    ; ####increment refcount
    add qword [r12 + 0], 1

lab60239:
    mov r11, [r10 + 24]
    jmp lab60241

lab60240:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]

lab60241:
    ; substitute (a6 !-> a6)(c0 !-> c0)(n0 !-> n0)(y1 !-> y1)(x15 !-> x15)(y5 !-> y5);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    mov rsi, r12
    mov rax, r14
    ; let x8: Vec = Vec(x15, y5);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60253
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab60254

lab60253:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60251
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60244
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60242
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60243

lab60242:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60243:

lab60244:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60247
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60245
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60246

lab60245:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60246:

lab60247:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60250
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60248
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60249

lab60248:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60249:

lab60250:
    jmp lab60252

lab60251:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60252:

lab60254:
    ; #load tag
    mov r13, 0
    ; substitute (y1 !-> y1)(c0 !-> c0)(n0 !-> n0)(a6 !-> a6)(x8 !-> x8);
    ; #move variables
    mov r10, rax
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; new a9: Vec = (a6, x8)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60266
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab60267

lab60266:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60264
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60257
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60255
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60256

lab60255:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60256:

lab60257:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60260
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60258
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60259

lab60258:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60259:

lab60260:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60263
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60261
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60262

lab60261:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60262:

lab60263:
    jmp lab60265

lab60264:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60265:

lab60267:
    ; #load tag
    lea r11, [rel Vec_60268]
    ; substitute (c0 !-> c0)(y1 !-> y1)(n0 !-> n0)(a9 !-> a9);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump scale_vec2_
    jmp scale_vec2_

Vec_60268:

Vec_60268_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60271
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab60269
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60269:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60270
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60270:
    jmp lab60272

lab60271:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab60272:
    ; substitute (x8 !-> x8)(a6 !-> a6)(x14 !-> x14)(y4 !-> y4);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rsi, r8
    mov rax, r10
    ; let x10: Vec = Vec(x14, y4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60284
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60285

lab60284:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60282
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60275
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60273
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60274

lab60273:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60274:

lab60275:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60278
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60276
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60277

lab60276:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60277:

lab60278:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60281
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60279
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60280

lab60279:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60280:

lab60281:
    jmp lab60283

lab60282:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60283:

lab60285:
    ; #load tag
    mov r9, 0
    ; substitute (x8 !-> x8)(x10 !-> x10)(a6 !-> a6);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump vec_add_
    jmp vec_add_

Vec_60179:

Vec_60179_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60288
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab60286
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60286:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60287
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60287:
    jmp lab60289

lab60288:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab60289:
    ; substitute (x3 !-> x3)(a1 !-> a1)(x13 !-> x13)(y3 !-> y3);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rsi, r8
    mov rax, r10
    ; let x7: Vec = Vec(x13, y3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60301
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60302

lab60301:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60299
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60292
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60290
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60291

lab60290:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60291:

lab60292:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60295
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60293
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60294

lab60293:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60294:

lab60295:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60298
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60296
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60297

lab60296:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60297:

lab60298:
    jmp lab60300

lab60299:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60300:

lab60302:
    ; #load tag
    mov r9, 0
    ; substitute (x3 !-> x3)(x7 !-> x7)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump tup2_
    jmp tup2_

Vec4_59984:

Vec4_59984_Vec4:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab60308
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load link to next block
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    ; ###load values
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    cmp r14, 0
    je lab60303
    ; ####increment refcount
    add qword [r14 + 0], 1

lab60303:
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]
    cmp r12, 0
    je lab60304
    ; ####increment refcount
    add qword [r12 + 0], 1

lab60304:
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###load link to next block
    mov rcx, [rax + 48]
    mov [rsp + 2000], rcx
    ; ###load values
    mov rcx, [rax + 40]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 24]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 16]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab60305
    ; ####increment refcount
    add qword [rcx + 0], 1

lab60305:
    mov rax, [rsp + 2000]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1960], rcx
    mov rcx, [rax + 48]
    mov [rsp + 1968], rcx
    cmp rcx, 0
    je lab60306
    ; ####increment refcount
    add qword [rcx + 0], 1

lab60306:
    mov rcx, [rax + 40]
    mov [rsp + 1976], rcx
    mov rcx, [rax + 32]
    mov [rsp + 1984], rcx
    cmp rcx, 0
    je lab60307
    ; ####increment refcount
    add qword [rcx + 0], 1

lab60307:
    mov rcx, [rax + 24]
    mov [rsp + 1992], rcx
    mov rax, [rsp + 2040]
    jmp lab60309

lab60308:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load link to next block
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    ; ###load values
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rcx, [rax + 48]
    mov [rsp + 2000], rcx
    ; ###load values
    mov rcx, [rax + 40]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 24]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 16]
    mov [rsp + 2032], rcx
    mov rax, [rsp + 2000]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1960], rcx
    mov rcx, [rax + 48]
    mov [rsp + 1968], rcx
    mov rcx, [rax + 40]
    mov [rsp + 1976], rcx
    mov rcx, [rax + 32]
    mov [rsp + 1984], rcx
    mov rcx, [rax + 24]
    mov [rsp + 1992], rcx
    mov rax, [rsp + 2040]

lab60309:
    ; substitute (b !-> b)(a !-> a)(n !-> n)(m !-> m)(t !-> t)(c !-> c)(a0 !-> a0)(x12 !-> x12)(y2 !-> y2)(z0 !-> z0)(w0 !-> w0);
    ; #move variables
    mov rcx, [rsp + 1960]
    mov [rsp + 1960], r11
    mov r11, [rsp + 2008]
    mov [rsp + 2008], rdx
    mov rdx, rcx
    mov rcx, [rsp + 1976]
    mov [rsp + 1976], r9
    mov r9, [rsp + 1992]
    mov [rsp + 1992], rdi
    mov rdi, rcx
    mov rsi, [rsp + 1984]
    mov rax, [rsp + 1968]
    ; let x2: Vec4 = Vec4(x12, y2, z0, w0);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60321
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60322

lab60321:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60319
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60312
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60310
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60311

lab60310:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60311:

lab60312:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60315
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60313
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60314

lab60313:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60314:

lab60315:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60318
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60316
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60317

lab60316:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60317:

lab60318:
    jmp lab60320

lab60319:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60320:

lab60322:
    ; ##store link to previous block
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60334
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60335

lab60334:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60332
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60325
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60323
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60324

lab60323:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60324:

lab60325:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60328
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60326
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60327

lab60326:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60327:

lab60328:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60331
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60329
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60330

lab60329:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60330:

lab60331:
    jmp lab60333

lab60332:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60333:

lab60335:
    ; #load tag
    mov qword [rsp + 2008], 0
    ; new a10: List[Vec4] = (a0, x2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60347
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60348

lab60347:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60345
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60338
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60336
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60337

lab60336:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60337:

lab60338:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60341
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60339
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60340

lab60339:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60340:

lab60341:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60344
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60342
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60343

lab60342:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60343:

lab60344:
    jmp lab60346

lab60345:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60346:

lab60348:
    ; #load tag
    lea rcx, [rel List_Vec4_60349]
    mov [rsp + 2024], rcx
    ; substitute (t !-> t)(m !-> m)(n !-> n)(a !-> a)(b !-> b)(c !-> c)(a10 !-> a10);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov r10, rsi
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump grid_lscomp_
    jmp grid_lscomp_

List_Vec4_60349:
    jmp near List_Vec4_60349_Nil
    jmp near List_Vec4_60349_Cons

List_Vec4_60349_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab60352
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab60350
    ; ####increment refcount
    add qword [rsi + 0], 1

lab60350:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab60351
    ; ####increment refcount
    add qword [rax + 0], 1

lab60351:
    jmp lab60353

lab60352:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab60353:
    ; let x11: List[Vec4] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x2 !-> x2)(x11 !-> x11)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Vec4_60349_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60356
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab60354
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60354:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60355
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60355:
    jmp lab60357

lab60356:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab60357:
    ; substitute (x2 !-> x2)(a0 !-> a0)(a11 !-> a11)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x11: List[Vec4] = Cons(a11, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60369
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60370

lab60369:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60367
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60360
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60358
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60359

lab60358:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60359:

lab60360:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60363
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60361
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60362

lab60361:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60362:

lab60363:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60366
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60364
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60365

lab60364:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60365:

lab60366:
    jmp lab60368

lab60367:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60368:

lab60370:
    ; #load tag
    mov r9, 5
    ; substitute (x2 !-> x2)(x11 !-> x11)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

grid_:
    ; substitute (segments !-> segments)(m !-> m)(n !-> n)(a !-> a)(b !-> b)(c !-> c)(a0 !-> a0);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    ; jump grid_lscomp_
    jmp grid_lscomp_

rot_:
    ; substitute (b0 !-> b)(a !-> a)(b !-> b)(c !-> c)(a0 !-> a0)(p !-> p);
    ; #share b
    cmp r8, 0
    je lab60371
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60371:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov rax, r8
    mov rdx, r9
    ; new a2: Vec = (b, c, a0, p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60383
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab60384

lab60383:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60381
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60374
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60372
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60373

lab60372:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60373:

lab60374:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60377
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60375
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60376

lab60375:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60376:

lab60377:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60380
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60378
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60379

lab60378:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60379:

lab60380:
    jmp lab60382

lab60381:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60382:

lab60384:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60396
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60397

lab60396:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60394
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60387
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60385
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60386

lab60385:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60386:

lab60387:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60390
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60388
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60389

lab60388:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60389:

lab60390:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60393
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60391
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60392

lab60391:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60392:

lab60393:
    jmp lab60395

lab60394:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60395:

lab60397:
    ; #load tag
    lea r9, [rel Vec_60398]
    ; substitute (a !-> a)(b0 !-> b0)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump vec_add_
    jmp vec_add_

Vec_60398:

Vec_60398_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60403
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60399
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60399:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab60400
    ; ####increment refcount
    add qword [r14 + 0], 1

lab60400:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab60401
    ; ####increment refcount
    add qword [r12 + 0], 1

lab60401:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab60402
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60402:
    jmp lab60404

lab60403:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab60404:
    ; substitute (p !-> p)(a0 !-> a0)(b !-> b)(c !-> c)(x6 !-> x6)(y1 !-> y1);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    mov rsi, r12
    mov rax, r14
    ; let x0: Vec = Vec(x6, y1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60416
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab60417

lab60416:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60414
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60407
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60405
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60406

lab60405:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60406:

lab60407:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60410
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60408
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60409

lab60408:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60409:

lab60410:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60413
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60411
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60412

lab60411:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60412:

lab60413:
    jmp lab60415

lab60414:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60415:

lab60417:
    ; #load tag
    mov r13, 0
    ; substitute (b !-> b)(a0 !-> a0)(p !-> p)(c !-> c)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a1: Vec = (a0, p, c, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60429
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60430

lab60429:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60427
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60420
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60418
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60419

lab60418:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60419:

lab60420:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60423
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60421
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60422

lab60421:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60422:

lab60423:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60426
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60424
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60425

lab60424:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60425:

lab60426:
    jmp lab60428

lab60427:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60428:

lab60430:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60442
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab60443

lab60442:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60440
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60433
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60431
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60432

lab60431:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60432:

lab60433:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60436
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60434
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60435

lab60434:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60435:

lab60436:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60439
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60437
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60438

lab60437:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60438:

lab60439:
    jmp lab60441

lab60440:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60441:

lab60443:
    ; #load tag
    lea rdi, [rel Vec_60444]
    ; lit x3 <- 0;
    mov r9, 0
    ; lit x4 <- 0;
    mov r11, 0
    ; let x2: Vec = Vec(x3, x4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60456
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60457

lab60456:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60454
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60447
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60445
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60446

lab60445:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60446:

lab60447:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60450
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60448
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60449

lab60448:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60449:

lab60450:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60453
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60451
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60452

lab60451:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60452:

lab60453:
    jmp lab60455

lab60454:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60455:

lab60457:
    ; #load tag
    mov r9, 0
    ; substitute (x2 !-> x2)(b !-> b)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump vec_sub_
    jmp vec_sub_

Vec_60444:

Vec_60444_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60462
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60458
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60458:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab60459
    ; ####increment refcount
    add qword [r14 + 0], 1

lab60459:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab60460
    ; ####increment refcount
    add qword [r12 + 0], 1

lab60460:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab60461
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60461:
    jmp lab60463

lab60462:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab60463:
    ; substitute (x0 !-> x0)(c !-> c)(a0 !-> a0)(p !-> p)(x5 !-> x5)(y0 !-> y0);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    mov rsi, r12
    mov rax, r14
    ; let x1: Vec = Vec(x5, y0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60475
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab60476

lab60475:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60473
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60466
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60464
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60465

lab60464:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60465:

lab60466:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60469
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60467
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60468

lab60467:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60468:

lab60469:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60472
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60470
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60471

lab60470:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60471:

lab60472:
    jmp lab60474

lab60473:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60474:

lab60476:
    ; #load tag
    mov r13, 0
    ; substitute (x0 !-> x0)(c !-> c)(p !-> p)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r10
    mov r10, r12
    mov r12, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r13
    mov r13, r9
    mov r9, rcx
    ; let a4: Fun[Vec, List[Vec4]] = Ap(x1, a0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60488
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab60489

lab60488:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60486
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60479
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60477
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60478

lab60477:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60478:

lab60479:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60482
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60480
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60481

lab60480:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60481:

lab60482:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60485
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60483
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60484

lab60483:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60484:

lab60485:
    jmp lab60487

lab60486:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60487:

lab60489:
    ; #load tag
    mov r11, 0
    ; substitute (x0 !-> x0)(p !-> p)(c !-> c)(a4 !-> a4);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; let a3: Fun[Vec, Fun[Vec, List[Vec4]]] = Ap(c, a4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60501
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60502

lab60501:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60499
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60492
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60490
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60491

lab60490:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60491:

lab60492:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60495
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60493
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60494

lab60493:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60494:

lab60495:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60498
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60496
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60497

lab60496:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60497:

lab60498:
    jmp lab60500

lab60499:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60500:

lab60502:
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(a3 !-> a3)(p !-> p);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke p Ap
    jmp r9

append_vec4_:
    ; substitute (a0 !-> a0)(l2 !-> l2)(l1 !-> l1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch l1 \{ ... \};
    lea rcx, [rel List_Vec4_60503]
    add rcx, r9
    jmp rcx

List_Vec4_60503:
    jmp near List_Vec4_60503_Nil
    jmp near List_Vec4_60503_Cons

List_Vec4_60503_Nil:
    ; switch l2 \{ ... \};
    lea rcx, [rel List_Vec4_60504]
    add rcx, rdi
    jmp rcx

List_Vec4_60504:
    jmp near List_Vec4_60504_Nil
    jmp near List_Vec4_60504_Cons

List_Vec4_60504_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Vec4_60504_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab60507
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab60505
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60505:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab60506
    ; ####increment refcount
    add qword [rsi + 0], 1

lab60506:
    jmp lab60508

lab60507:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab60508:
    ; substitute (a2 !-> a2)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Vec4_60503_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60511
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab60509
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60509:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60510
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60510:
    jmp lab60512

lab60511:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab60512:
    ; substitute (vs !-> vs)(l2 !-> l2)(v !-> v)(a0 !-> a0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; new a1: List[Vec4] = (v, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60524
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60525

lab60524:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60522
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60515
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60513
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60514

lab60513:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60514:

lab60515:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60518
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60516
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60517

lab60516:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60517:

lab60518:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60521
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60519
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60520

lab60519:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60520:

lab60521:
    jmp lab60523

lab60522:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60523:

lab60525:
    ; #load tag
    lea r9, [rel List_Vec4_60526]
    ; jump append_vec4_
    jmp append_vec4_

List_Vec4_60526:
    jmp near List_Vec4_60526_Nil
    jmp near List_Vec4_60526_Cons

List_Vec4_60526_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab60529
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab60527
    ; ####increment refcount
    add qword [rsi + 0], 1

lab60527:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab60528
    ; ####increment refcount
    add qword [rax + 0], 1

lab60528:
    jmp lab60530

lab60529:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab60530:
    ; let x0: List[Vec4] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (v !-> v)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Vec4_60526_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60533
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab60531
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60531:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60532
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60532:
    jmp lab60534

lab60533:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab60534:
    ; substitute (a0 !-> a0)(v !-> v)(a3 !-> a3)(as1 !-> as1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Vec4] = Cons(a3, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60546
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60547

lab60546:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60544
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60537
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60535
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60536

lab60535:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60536:

lab60537:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60540
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60538
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60539

lab60538:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60539:

lab60540:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60543
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60541
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60542

lab60541:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60542:

lab60543:
    jmp lab60545

lab60544:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60545:

lab60547:
    ; #load tag
    mov r9, 5
    ; substitute (v !-> v)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

beside_:
    ; substitute (m0 !-> m)(n0 !-> n)(p !-> p)(c0 !-> c)(a16 !-> a)(b0 !-> b)(c !-> c)(a0 !-> a0)(m !-> m)(n !-> n)(b !-> b)(q !-> q)(a !-> a);
    ; #share a
    cmp r12, 0
    je lab60548
    ; ####increment refcount
    add qword [r12 + 0], 1

lab60548:
    ; #share b
    cmp r14, 0
    je lab60549
    ; ####increment refcount
    add qword [r14 + 0], 1

lab60549:
    ; #share c
    cmp qword [rsp + 2032], 0
    je lab60550
    mov rcx, [rsp + 2032]
    add qword [rcx + 0], 1

lab60550:
    ; #move variables
    mov [rsp + 1992], rdx
    mov [rsp + 1976], rdi
    mov [rsp + 1952], r10
    mov [rsp + 1944], r11
    mov [rsp + 1936], r12
    mov [rsp + 1928], r13
    mov [rsp + 1968], r14
    mov [rsp + 1960], r15
    mov r10, [rsp + 2032]
    mov r11, [rsp + 2024]
    ; new a1: List[Vec4] = (c, a0, m, n, b, q, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1936]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1952]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 1960]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60562
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60563

lab60562:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60560
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60553
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60551
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60552

lab60551:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60552:

lab60553:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60556
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60554
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60555

lab60554:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60555:

lab60556:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60559
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60557
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60558

lab60557:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60558:

lab60559:
    jmp lab60561

lab60560:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60561:

lab60563:
    ; ##store link to previous block
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60575
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60576

lab60575:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60573
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60566
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60564
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60565

lab60564:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60565:

lab60566:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60569
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60567
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60568

lab60567:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60568:

lab60569:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60572
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60570
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60571

lab60570:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60571:

lab60572:
    jmp lab60574

lab60573:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60574:

lab60576:
    ; ##store link to previous block
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60588
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60589

lab60588:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60586
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60579
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60577
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60578

lab60577:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60578:

lab60579:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60582
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60580
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60581

lab60580:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60581:

lab60582:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60585
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60583
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60584

lab60583:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60584:

lab60585:
    jmp lab60587

lab60586:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60587:

lab60589:
    ; #load tag
    lea rcx, [rel List_Vec4_60590]
    mov [rsp + 2024], rcx
    ; substitute (m0 !-> m0)(n0 !-> n0)(b0 !-> b0)(c0 !-> c0)(a16 !-> a16)(p !-> p)(a1 !-> a1);
    ; #move variables
    mov rcx, r14
    mov r14, r8
    mov r8, rcx
    mov rcx, r15
    mov r15, r9
    mov r9, rcx
    ; new a2: Vec = (c0, a16, p, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60602
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab60603

lab60602:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60600
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60593
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60591
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60592

lab60591:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60592:

lab60593:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60596
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60594
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60595

lab60594:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60595:

lab60596:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60599
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60597
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60598

lab60597:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60598:

lab60599:
    jmp lab60601

lab60600:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60601:

lab60603:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60615
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab60616

lab60615:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60613
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60606
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60604
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60605

lab60604:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60605:

lab60606:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60609
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60607
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60608

lab60607:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60608:

lab60609:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60612
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60610
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60611

lab60610:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60611:

lab60612:
    jmp lab60614

lab60613:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60614:

lab60616:
    ; #load tag
    lea r11, [rel Vec_60617]
    ; x2 <- m0 + n0;
    mov r13, rdx
    add r13, rdi
    ; substitute (b0 !-> b0)(m0 !-> m0)(x2 !-> x2)(a2 !-> a2);
    ; #move variables
    mov rdi, rdx
    mov rax, r8
    mov rdx, r9
    mov r9, r13
    ; jump scale_vec2_
    jmp scale_vec2_

Vec_60617:

Vec_60617_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60622
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60618
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60618:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab60619
    ; ####increment refcount
    add qword [r14 + 0], 1

lab60619:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab60620
    ; ####increment refcount
    add qword [r12 + 0], 1

lab60620:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab60621
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60621:
    jmp lab60623

lab60622:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab60623:
    ; substitute (a1 !-> a1)(p !-> p)(c0 !-> c0)(a16 !-> a16)(x12 !-> x12)(y3 !-> y3);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    mov rsi, r12
    mov rax, r14
    ; let x1: Vec = Vec(x12, y3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60635
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab60636

lab60635:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60633
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60626
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60624
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60625

lab60624:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60625:

lab60626:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60629
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60627
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60628

lab60627:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60628:

lab60629:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60632
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60630
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60631

lab60630:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60631:

lab60632:
    jmp lab60634

lab60633:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60634:

lab60636:
    ; #load tag
    mov r13, 0
    ; substitute (x1 !-> x1)(p !-> p)(a16 !-> a16)(c0 !-> c0)(a1 !-> a1);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; let a11: Fun[Vec, List[Vec4]] = Ap(c0, a1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60648
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab60649

lab60648:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60646
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60639
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60637
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60638

lab60637:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60638:

lab60639:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60642
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60640
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60641

lab60640:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60641:

lab60642:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60645
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60643
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60644

lab60643:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60644:

lab60645:
    jmp lab60647

lab60646:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60647:

lab60649:
    ; #load tag
    mov r11, 0
    ; substitute (a16 !-> a16)(p !-> p)(x1 !-> x1)(a11 !-> a11);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; let a10: Fun[Vec, Fun[Vec, List[Vec4]]] = Ap(x1, a11);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60661
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60662

lab60661:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60659
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60652
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60650
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60651

lab60650:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60651:

lab60652:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60655
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60653
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60654

lab60653:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60654:

lab60655:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60658
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60656
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60657

lab60656:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60657:

lab60658:
    jmp lab60660

lab60659:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60660:

lab60662:
    ; #load tag
    mov r9, 0
    ; substitute (a16 !-> a16)(a10 !-> a10)(p !-> p);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke p Ap
    jmp r9

List_Vec4_60590:
    jmp near List_Vec4_60590_Nil
    jmp near List_Vec4_60590_Cons

List_Vec4_60590_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab60668
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab60663
    ; ####increment refcount
    add qword [rsi + 0], 1

lab60663:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab60664
    ; ####increment refcount
    add qword [rax + 0], 1

lab60664:
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab60665
    ; ####increment refcount
    add qword [rcx + 0], 1

lab60665:
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    cmp r14, 0
    je lab60666
    ; ####increment refcount
    add qword [r14 + 0], 1

lab60666:
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]
    cmp r12, 0
    je lab60667
    ; ####increment refcount
    add qword [r12 + 0], 1

lab60667:
    jmp lab60669

lab60668:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]

lab60669:
    ; let x0: List[Vec4] = Nil();
    ; #mark no allocation
    mov qword [rsp + 2016], 0
    ; #load tag
    mov qword [rsp + 2008], 0
    ; substitute (a !-> a)(a0 !-> a0)(b !-> b)(c !-> c)(m !-> m)(n !-> n)(q !-> q)(x0 !-> x0);
    ; #move variables
    mov r10, rax
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r15
    mov r15, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    mov r8, r12
    mov rax, [rsp + 2032]
    mov [rsp + 2032], r14
    ; jump lift_beside_0_
    jmp lift_beside_0_

List_Vec4_60590_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60675
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab60670
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60670:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab60671
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60671:
    ; ###load link to next block
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    ; ###load values
    mov r15, [r12 + 40]
    mov r13, [r12 + 24]
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1992], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2000], rcx
    cmp rcx, 0
    je lab60672
    ; ####increment refcount
    add qword [rcx + 0], 1

lab60672:
    mov rcx, [rax + 40]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 32]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab60673
    ; ####increment refcount
    add qword [rcx + 0], 1

lab60673:
    mov rcx, [rax + 24]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 16]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab60674
    ; ####increment refcount
    add qword [rcx + 0], 1

lab60674:
    mov rax, [rsp + 2040]
    jmp lab60676

lab60675:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load link to next block
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    ; ###load values
    mov r15, [r12 + 40]
    mov r13, [r12 + 24]
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1992], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2000], rcx
    mov rcx, [rax + 40]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 32]
    mov [rsp + 2016], rcx
    mov rcx, [rax + 24]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 16]
    mov [rsp + 2032], rcx
    mov rax, [rsp + 2040]

lab60676:
    ; substitute (a !-> a)(q !-> q)(c !-> c)(a0 !-> a0)(m !-> m)(n !-> n)(b !-> b)(a15 !-> a15)(as1 !-> as1);
    ; #move variables
    mov rcx, [rsp + 2000]
    mov [rsp + 2000], rsi
    mov rsi, [rsp + 2016]
    mov [rsp + 2016], rax
    mov rax, rcx
    mov rcx, [rsp + 1992]
    mov [rsp + 1992], rdi
    mov rdi, [rsp + 2008]
    mov [rsp + 2008], rdx
    mov rdx, rcx
    ; let x0: List[Vec4] = Cons(a15, as1);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60688
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60689

lab60688:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60686
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60679
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60677
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60678

lab60677:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60678:

lab60679:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60682
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60680
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60681

lab60680:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60681:

lab60682:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60685
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60683
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60684

lab60683:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60684:

lab60685:
    jmp lab60687

lab60686:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60687:

lab60689:
    ; #load tag
    mov qword [rsp + 2008], 5
    ; substitute (a !-> a)(a0 !-> a0)(b !-> b)(c !-> c)(m !-> m)(n !-> n)(q !-> q)(x0 !-> x0);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, [rsp + 2032]
    mov [rsp + 2032], rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, [rsp + 2024]
    mov [rsp + 2024], rdi
    mov rdi, rcx
    ; jump lift_beside_0_
    jmp lift_beside_0_

lift_beside_0_:
    ; substitute (a !-> a)(q !-> q)(b !-> b)(c !-> c)(m !-> m)(n !-> n)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], rsi
    mov rsi, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], rdi
    mov rdi, rcx
    ; new a4: List[Vec4] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60701
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60702

lab60701:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60699
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60692
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60690
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60691

lab60690:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60691:

lab60692:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60695
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60693
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60694

lab60693:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60694:

lab60695:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60698
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60696
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60697

lab60696:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60697:

lab60698:
    jmp lab60700

lab60699:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60700:

lab60702:
    ; #load tag
    lea rcx, [rel List_Vec4_60703]
    mov [rsp + 2024], rcx
    ; substitute (a !-> a)(n0 !-> n)(b0 !-> b)(m0 !-> m)(m !-> m)(n !-> n)(a4 !-> a4)(c !-> c)(q !-> q)(b !-> b);
    ; #share b
    cmp r8, 0
    je lab60704
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60704:
    ; #move variables
    mov [rsp + 2000], rsi
    mov [rsp + 1992], rdi
    mov [rsp + 1984], r8
    mov [rsp + 1976], r9
    mov [rsp + 2016], r10
    mov [rsp + 2008], r11
    mov r11, r13
    mov rdi, r15
    ; new a7: Vec = (m, n, a4, c, q, b)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60716
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60717

lab60716:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60714
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60707
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60705
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60706

lab60705:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60706:

lab60707:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60710
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60708
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60709

lab60708:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60709:

lab60710:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60713
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60711
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60712

lab60711:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60712:

lab60713:
    jmp lab60715

lab60714:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60715:

lab60717:
    ; ##store link to previous block
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    mov [rbx + 24], r15
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60729
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab60730

lab60729:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60727
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60720
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60718
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60719

lab60718:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60719:

lab60720:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60723
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60721
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60722

lab60721:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60722:

lab60723:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60726
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60724
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60725

lab60724:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60725:

lab60726:
    jmp lab60728

lab60727:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60728:

lab60730:
    ; ##store link to previous block
    mov [rbx + 48], r14
    ; ##store values
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60742
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab60743

lab60742:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60740
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60733
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60731
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60732

lab60731:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60732:

lab60733:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60736
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60734
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60735

lab60734:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60735:

lab60736:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60739
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60737
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60738

lab60737:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60738:

lab60739:
    jmp lab60741

lab60740:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60741:

lab60743:
    ; #load tag
    lea r13, [rel Vec_60744]
    ; substitute (m0 !-> m0)(n0 !-> n0)(b0 !-> b0)(a !-> a)(a7 !-> a7);
    ; #move variables
    mov r10, rax
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; new a8: Vec = (a, a7)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60756
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab60757

lab60756:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60754
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60747
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60745
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60746

lab60745:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60746:

lab60747:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60750
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60748
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60749

lab60748:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60749:

lab60750:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60753
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60751
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60752

lab60751:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60752:

lab60753:
    jmp lab60755

lab60754:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60755:

lab60757:
    ; #load tag
    lea r11, [rel Vec_60758]
    ; x6 <- m0 + n0;
    mov r13, rdx
    add r13, rdi
    ; substitute (b0 !-> b0)(m0 !-> m0)(x6 !-> x6)(a8 !-> a8);
    ; #move variables
    mov rdi, rdx
    mov rax, r8
    mov rdx, r9
    mov r9, r13
    ; jump scale_vec2_
    jmp scale_vec2_

Vec_60758:

Vec_60758_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60761
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab60759
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60759:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60760
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60760:
    jmp lab60762

lab60761:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab60762:
    ; substitute (a7 !-> a7)(a !-> a)(x11 !-> x11)(y2 !-> y2);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rsi, r8
    mov rax, r10
    ; let x5: Vec = Vec(x11, y2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60774
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60775

lab60774:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60772
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60765
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60763
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60764

lab60763:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60764:

lab60765:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60768
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60766
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60767

lab60766:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60767:

lab60768:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60771
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60769
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60770

lab60769:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60770:

lab60771:
    jmp lab60773

lab60772:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60773:

lab60775:
    ; #load tag
    mov r9, 0
    ; substitute (a !-> a)(x5 !-> x5)(a7 !-> a7);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump vec_add_
    jmp vec_add_

Vec_60744:

Vec_60744_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60780
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab60776
    ; ####increment refcount
    add qword [r12 + 0], 1

lab60776:
    mov r11, [r10 + 24]
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab60777
    ; ####increment refcount
    add qword [rcx + 0], 1

lab60777:
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab60778
    ; ####increment refcount
    add qword [rcx + 0], 1

lab60778:
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]
    cmp r14, 0
    je lab60779
    ; ####increment refcount
    add qword [r14 + 0], 1

lab60779:
    jmp lab60781

lab60780:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]

lab60781:
    ; substitute (b !-> b)(q !-> q)(m !-> m)(n !-> n)(a4 !-> a4)(c !-> c)(x10 !-> x10)(y1 !-> y1);
    ; #move variables
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], rdi
    mov rdi, [rsp + 2024]
    mov [rsp + 2024], rdx
    mov rdx, rcx
    mov rsi, [rsp + 2032]
    mov rax, [rsp + 2016]
    ; let x4: Vec = Vec(x10, y1);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60793
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60794

lab60793:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60791
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60784
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60782
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60783

lab60782:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60783:

lab60784:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60787
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60785
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60786

lab60785:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60786:

lab60787:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60790
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60788
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60789

lab60788:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60789:

lab60790:
    jmp lab60792

lab60791:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60792:

lab60794:
    ; #load tag
    mov qword [rsp + 2024], 0
    ; substitute (b !-> b)(n !-> n)(m !-> m)(q !-> q)(a4 !-> a4)(c !-> c)(x4 !-> x4);
    ; #move variables
    mov r10, rsi
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; new a5: Vec = (q, a4, c, x4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60806
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab60807

lab60806:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60804
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60797
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60795
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60796

lab60795:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60796:

lab60797:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60800
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60798
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60799

lab60798:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60799:

lab60800:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60803
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60801
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60802

lab60801:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60802:

lab60803:
    jmp lab60805

lab60804:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60805:

lab60807:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60819
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab60820

lab60819:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60817
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60810
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60808
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60809

lab60808:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60809:

lab60810:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60813
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60811
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60812

lab60811:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60812:

lab60813:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60816
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60814
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60815

lab60814:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60815:

lab60816:
    jmp lab60818

lab60817:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60818:

lab60820:
    ; #load tag
    lea r11, [rel Vec_60821]
    ; x8 <- n + m;
    mov r13, rdi
    add r13, r9
    ; substitute (b !-> b)(n !-> n)(x8 !-> x8)(a5 !-> a5);
    ; #move variables
    mov r9, r13
    ; jump scale_vec2_
    jmp scale_vec2_

Vec_60821:

Vec_60821_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60826
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60822
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60822:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab60823
    ; ####increment refcount
    add qword [r14 + 0], 1

lab60823:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab60824
    ; ####increment refcount
    add qword [r12 + 0], 1

lab60824:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab60825
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60825:
    jmp lab60827

lab60826:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab60827:
    ; substitute (x4 !-> x4)(c !-> c)(q !-> q)(a4 !-> a4)(x9 !-> x9)(y0 !-> y0);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    mov rsi, r12
    mov rax, r14
    ; let x7: Vec = Vec(x9, y0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60839
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab60840

lab60839:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60837
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60830
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60828
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60829

lab60828:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60829:

lab60830:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60833
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60831
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60832

lab60831:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60832:

lab60833:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60836
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60834
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60835

lab60834:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60835:

lab60836:
    jmp lab60838

lab60837:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60838:

lab60840:
    ; #load tag
    mov r13, 0
    ; substitute (x4 !-> x4)(x7 !-> x7)(q !-> q)(c !-> c)(a4 !-> a4);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, rdi
    mov rdi, rcx
    ; let a13: Fun[Vec, List[Vec4]] = Ap(c, a4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60852
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab60853

lab60852:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60850
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60843
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60841
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60842

lab60841:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60842:

lab60843:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60846
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60844
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60845

lab60844:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60845:

lab60846:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60849
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60847
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60848

lab60847:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60848:

lab60849:
    jmp lab60851

lab60850:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60851:

lab60853:
    ; #load tag
    mov r11, 0
    ; substitute (x4 !-> x4)(q !-> q)(x7 !-> x7)(a13 !-> a13);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; let a12: Fun[Vec, Fun[Vec, List[Vec4]]] = Ap(x7, a13);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60865
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60866

lab60865:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60863
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60856
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60854
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60855

lab60854:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60855:

lab60856:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60859
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60857
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60858

lab60857:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60858:

lab60859:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60862
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60860
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60861

lab60860:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60861:

lab60862:
    jmp lab60864

lab60863:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60864:

lab60866:
    ; #load tag
    mov r9, 0
    ; substitute (x4 !-> x4)(a12 !-> a12)(q !-> q);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke q Ap
    jmp r9

List_Vec4_60703:
    jmp near List_Vec4_60703_Nil
    jmp near List_Vec4_60703_Cons

List_Vec4_60703_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab60869
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab60867
    ; ####increment refcount
    add qword [rsi + 0], 1

lab60867:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab60868
    ; ####increment refcount
    add qword [rax + 0], 1

lab60868:
    jmp lab60870

lab60869:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab60870:
    ; let x3: List[Vec4] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump append_vec4_
    jmp append_vec4_

List_Vec4_60703_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60873
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab60871
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60871:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60872
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60872:
    jmp lab60874

lab60873:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab60874:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a14 !-> a14)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x3: List[Vec4] = Cons(a14, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60886
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab60887

lab60886:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60884
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60877
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60875
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60876

lab60875:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60876:

lab60877:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60880
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60878
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60879

lab60878:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60879:

lab60880:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60883
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60881
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60882

lab60881:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60882:

lab60883:
    jmp lab60885

lab60884:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60885:

lab60887:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump append_vec4_
    jmp append_vec4_

above_:
    ; substitute (m0 !-> m)(n0 !-> n)(p !-> p)(c0 !-> c)(a16 !-> a)(b0 !-> b)(c !-> c)(a0 !-> a0)(m !-> m)(n !-> n)(b !-> b)(q !-> q)(a !-> a);
    ; #share a
    cmp r12, 0
    je lab60888
    ; ####increment refcount
    add qword [r12 + 0], 1

lab60888:
    ; #share b
    cmp r14, 0
    je lab60889
    ; ####increment refcount
    add qword [r14 + 0], 1

lab60889:
    ; #share c
    cmp qword [rsp + 2032], 0
    je lab60890
    mov rcx, [rsp + 2032]
    add qword [rcx + 0], 1

lab60890:
    ; #move variables
    mov [rsp + 1992], rdx
    mov [rsp + 1976], rdi
    mov [rsp + 1952], r10
    mov [rsp + 1944], r11
    mov [rsp + 1936], r12
    mov [rsp + 1928], r13
    mov [rsp + 1968], r14
    mov [rsp + 1960], r15
    mov r10, [rsp + 2032]
    mov r11, [rsp + 2024]
    ; new a1: List[Vec4] = (c, a0, m, n, b, q, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1936]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1952]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 1960]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60902
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60903

lab60902:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60900
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60893
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60891
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60892

lab60891:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60892:

lab60893:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60896
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60894
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60895

lab60894:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60895:

lab60896:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60899
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60897
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60898

lab60897:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60898:

lab60899:
    jmp lab60901

lab60900:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60901:

lab60903:
    ; ##store link to previous block
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60915
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60916

lab60915:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60913
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60906
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60904
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60905

lab60904:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60905:

lab60906:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60909
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60907
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60908

lab60907:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60908:

lab60909:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60912
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60910
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60911

lab60910:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60911:

lab60912:
    jmp lab60914

lab60913:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60914:

lab60916:
    ; ##store link to previous block
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60928
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60929

lab60928:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60926
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60919
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60917
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60918

lab60917:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60918:

lab60919:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60922
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60920
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60921

lab60920:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60921:

lab60922:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60925
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60923
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60924

lab60923:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60924:

lab60925:
    jmp lab60927

lab60926:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60927:

lab60929:
    ; #load tag
    lea rcx, [rel List_Vec4_60930]
    mov [rsp + 2024], rcx
    ; substitute (m00 !-> m0)(n00 !-> n0)(a16 !-> a16)(c00 !-> c0)(c0 !-> c0)(b0 !-> b0)(a1 !-> a1)(m0 !-> m0)(n0 !-> n0)(p !-> p);
    ; #share c0
    cmp r10, 0
    je lab60931
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60931:
    ; #move variables
    mov [rsp + 2008], rdx
    mov [rsp + 1992], rdi
    mov [rsp + 1984], r8
    mov [rsp + 1976], r9
    mov r8, r12
    mov r12, r10
    mov r9, r13
    mov r13, r11
    ; new a4: Vec = (c0, b0, a1, m0, n0, p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 2008]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60943
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab60944

lab60943:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60941
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60934
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60932
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60933

lab60932:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60933:

lab60934:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60937
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60935
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60936

lab60935:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60936:

lab60937:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60940
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60938
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60939

lab60938:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60939:

lab60940:
    jmp lab60942

lab60941:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60942:

lab60944:
    ; ##store link to previous block
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    mov [rbx + 24], r15
    mov [rbx + 16], r14
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60956
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab60957

lab60956:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60954
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60947
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60945
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60946

lab60945:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60946:

lab60947:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60950
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60948
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60949

lab60948:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60949:

lab60950:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60953
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60951
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60952

lab60951:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60952:

lab60953:
    jmp lab60955

lab60954:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60955:

lab60957:
    ; ##store link to previous block
    mov [rbx + 48], r14
    ; ##store values
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60969
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab60970

lab60969:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60967
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60960
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60958
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60959

lab60958:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60959:

lab60960:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60963
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60961
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60962

lab60961:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60962:

lab60963:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60966
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60964
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60965

lab60964:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60965:

lab60966:
    jmp lab60968

lab60967:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60968:

lab60970:
    ; #load tag
    lea r13, [rel Vec_60971]
    ; substitute (m00 !-> m00)(n00 !-> n00)(c00 !-> c00)(a16 !-> a16)(a4 !-> a4);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; new a5: Vec = (a16, a4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab60983
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab60984

lab60983:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60981
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60974
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60972
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60973

lab60972:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60973:

lab60974:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60977
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60975
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60976

lab60975:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60976:

lab60977:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60980
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60978
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60979

lab60978:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60979:

lab60980:
    jmp lab60982

lab60981:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab60982:

lab60984:
    ; #load tag
    lea r11, [rel Vec_60985]
    ; x3 <- m00 + n00;
    mov r13, rdx
    add r13, rdi
    ; substitute (c00 !-> c00)(n00 !-> n00)(x3 !-> x3)(a5 !-> a5);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r9, r13
    ; jump scale_vec2_
    jmp scale_vec2_

Vec_60985:

Vec_60985_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab60988
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab60986
    ; ####increment refcount
    add qword [r10 + 0], 1

lab60986:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab60987
    ; ####increment refcount
    add qword [r8 + 0], 1

lab60987:
    jmp lab60989

lab60988:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab60989:
    ; substitute (a4 !-> a4)(a16 !-> a16)(x12 !-> x12)(y3 !-> y3);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rsi, r8
    mov rax, r10
    ; let x2: Vec = Vec(x12, y3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61001
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab61002

lab61001:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab60999
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab60992
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60990
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60991

lab60990:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60991:

lab60992:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab60995
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60993
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60994

lab60993:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60994:

lab60995:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab60998
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab60996
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab60997

lab60996:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab60997:

lab60998:
    jmp lab61000

lab60999:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61000:

lab61002:
    ; #load tag
    mov r9, 0
    ; substitute (a16 !-> a16)(x2 !-> x2)(a4 !-> a4);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump vec_add_
    jmp vec_add_

Vec_60971:

Vec_60971_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61007
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61003
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61003:
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab61004
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61004:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab61005
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61005:
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab61006
    ; ####increment refcount
    add qword [rcx + 0], 1

lab61006:
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 24]
    jmp lab61008

lab61007:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 24]

lab61008:
    ; substitute (p !-> p)(n0 !-> n0)(c0 !-> c0)(b0 !-> b0)(a1 !-> a1)(m0 !-> m0)(x11 !-> x11)(y2 !-> y2);
    ; #move variables
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], rdi
    mov rdi, [rsp + 2024]
    mov [rsp + 2024], rdx
    mov rdx, rcx
    mov rax, [rsp + 2016]
    ; let x1: Vec = Vec(x11, y2);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61020
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab61021

lab61020:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61018
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61011
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61009
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61010

lab61009:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61010:

lab61011:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61014
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61012
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61013

lab61012:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61013:

lab61014:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61017
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61015
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61016

lab61015:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61016:

lab61017:
    jmp lab61019

lab61018:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61019:

lab61021:
    ; #load tag
    mov qword [rsp + 2024], 0
    ; substitute (m0 !-> m0)(n0 !-> n0)(c0 !-> c0)(b0 !-> b0)(a1 !-> a1)(p !-> p)(x1 !-> x1);
    ; #move variables
    mov r14, rax
    mov rcx, r15
    mov r15, rdx
    mov rdx, rcx
    ; new a2: Vec = (b0, a1, p, x1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61033
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab61034

lab61033:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61031
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61024
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61022
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61023

lab61022:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61023:

lab61024:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61027
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61025
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61026

lab61025:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61026:

lab61027:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61030
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61028
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61029

lab61028:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61029:

lab61030:
    jmp lab61032

lab61031:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61032:

lab61034:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61046
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab61047

lab61046:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61044
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61037
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61035
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61036

lab61035:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61036:

lab61037:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61040
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61038
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61039

lab61038:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61039:

lab61040:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61043
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61041
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61042

lab61041:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61042:

lab61043:
    jmp lab61045

lab61044:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61045:

lab61047:
    ; #load tag
    lea r11, [rel Vec_61048]
    ; x5 <- n0 + m0;
    mov r13, rdi
    add r13, rdx
    ; substitute (c0 !-> c0)(m0 !-> m0)(x5 !-> x5)(a2 !-> a2);
    ; #move variables
    mov rdi, rdx
    mov rax, r8
    mov rdx, r9
    mov r9, r13
    ; jump scale_vec2_
    jmp scale_vec2_

Vec_61048:

Vec_61048_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61053
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61049
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61049:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab61050
    ; ####increment refcount
    add qword [r14 + 0], 1

lab61050:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab61051
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61051:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab61052
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61052:
    jmp lab61054

lab61053:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab61054:
    ; substitute (x1 !-> x1)(p !-> p)(b0 !-> b0)(a1 !-> a1)(x10 !-> x10)(y1 !-> y1);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    mov rsi, r12
    mov rax, r14
    ; let x4: Vec = Vec(x10, y1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61066
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab61067

lab61066:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61064
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61057
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61055
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61056

lab61055:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61056:

lab61057:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61060
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61058
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61059

lab61058:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61059:

lab61060:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61063
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61061
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61062

lab61061:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61062:

lab61063:
    jmp lab61065

lab61064:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61065:

lab61067:
    ; #load tag
    mov r13, 0
    ; substitute (x1 !-> x1)(p !-> p)(b0 !-> b0)(x4 !-> x4)(a1 !-> a1);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, rcx
    ; let a11: Fun[Vec, List[Vec4]] = Ap(x4, a1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61079
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab61080

lab61079:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61077
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61070
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61068
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61069

lab61068:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61069:

lab61070:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61073
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61071
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61072

lab61071:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61072:

lab61073:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61076
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61074
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61075

lab61074:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61075:

lab61076:
    jmp lab61078

lab61077:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61078:

lab61080:
    ; #load tag
    mov r11, 0
    ; let a10: Fun[Vec, Fun[Vec, List[Vec4]]] = Ap(b0, a11);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61092
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab61093

lab61092:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61090
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61083
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61081
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61082

lab61081:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61082:

lab61083:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61086
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61084
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61085

lab61084:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61085:

lab61086:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61089
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61087
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61088

lab61087:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61088:

lab61089:
    jmp lab61091

lab61090:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61091:

lab61093:
    ; #load tag
    mov r9, 0
    ; substitute (x1 !-> x1)(a10 !-> a10)(p !-> p);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke p Ap
    jmp r9

List_Vec4_60930:
    jmp near List_Vec4_60930_Nil
    jmp near List_Vec4_60930_Cons

List_Vec4_60930_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab61099
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab61094
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61094:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab61095
    ; ####increment refcount
    add qword [rax + 0], 1

lab61095:
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab61096
    ; ####increment refcount
    add qword [rcx + 0], 1

lab61096:
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    cmp r14, 0
    je lab61097
    ; ####increment refcount
    add qword [r14 + 0], 1

lab61097:
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]
    cmp r12, 0
    je lab61098
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61098:
    jmp lab61100

lab61099:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]

lab61100:
    ; let x0: List[Vec4] = Nil();
    ; #mark no allocation
    mov qword [rsp + 2016], 0
    ; #load tag
    mov qword [rsp + 2008], 0
    ; substitute (a !-> a)(a0 !-> a0)(b !-> b)(c !-> c)(m !-> m)(n !-> n)(q !-> q)(x0 !-> x0);
    ; #move variables
    mov r10, rax
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r15
    mov r15, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    mov r8, r12
    mov rax, [rsp + 2032]
    mov [rsp + 2032], r14
    ; jump lift_above_0_
    jmp lift_above_0_

List_Vec4_60930_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61106
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab61101
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61101:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab61102
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61102:
    ; ###load link to next block
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    ; ###load values
    mov r15, [r12 + 40]
    mov r13, [r12 + 24]
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1992], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2000], rcx
    cmp rcx, 0
    je lab61103
    ; ####increment refcount
    add qword [rcx + 0], 1

lab61103:
    mov rcx, [rax + 40]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 32]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab61104
    ; ####increment refcount
    add qword [rcx + 0], 1

lab61104:
    mov rcx, [rax + 24]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 16]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab61105
    ; ####increment refcount
    add qword [rcx + 0], 1

lab61105:
    mov rax, [rsp + 2040]
    jmp lab61107

lab61106:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load link to next block
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    ; ###load values
    mov r15, [r12 + 40]
    mov r13, [r12 + 24]
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1992], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2000], rcx
    mov rcx, [rax + 40]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 32]
    mov [rsp + 2016], rcx
    mov rcx, [rax + 24]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 16]
    mov [rsp + 2032], rcx
    mov rax, [rsp + 2040]

lab61107:
    ; substitute (a !-> a)(q !-> q)(c !-> c)(a0 !-> a0)(m !-> m)(n !-> n)(b !-> b)(a15 !-> a15)(as1 !-> as1);
    ; #move variables
    mov rcx, [rsp + 2000]
    mov [rsp + 2000], rsi
    mov rsi, [rsp + 2016]
    mov [rsp + 2016], rax
    mov rax, rcx
    mov rcx, [rsp + 1992]
    mov [rsp + 1992], rdi
    mov rdi, [rsp + 2008]
    mov [rsp + 2008], rdx
    mov rdx, rcx
    ; let x0: List[Vec4] = Cons(a15, as1);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61119
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab61120

lab61119:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61117
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61110
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61108
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61109

lab61108:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61109:

lab61110:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61113
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61111
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61112

lab61111:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61112:

lab61113:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61116
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61114
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61115

lab61114:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61115:

lab61116:
    jmp lab61118

lab61117:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61118:

lab61120:
    ; #load tag
    mov qword [rsp + 2008], 5
    ; substitute (a !-> a)(a0 !-> a0)(b !-> b)(c !-> c)(m !-> m)(n !-> n)(q !-> q)(x0 !-> x0);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, [rsp + 2032]
    mov [rsp + 2032], rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, [rsp + 2024]
    mov [rsp + 2024], rdi
    mov rdi, rcx
    ; jump lift_above_0_
    jmp lift_above_0_

lift_above_0_:
    ; substitute (a !-> a)(q !-> q)(b !-> b)(c !-> c)(m !-> m)(n !-> n)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], rsi
    mov rsi, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], rdi
    mov rdi, rcx
    ; new a7: List[Vec4] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61132
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab61133

lab61132:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61130
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61123
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61121
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61122

lab61121:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61122:

lab61123:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61126
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61124
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61125

lab61124:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61125:

lab61126:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61129
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61127
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61128

lab61127:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61128:

lab61129:
    jmp lab61131

lab61130:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61131:

lab61133:
    ; #load tag
    lea rcx, [rel List_Vec4_61134]
    mov [rsp + 2024], rcx
    ; substitute (n !-> n)(m !-> m)(c !-> c)(b !-> b)(q !-> q)(a !-> a)(a7 !-> a7);
    ; #move variables
    mov r14, rax
    mov rcx, r15
    mov r15, rdx
    mov rdx, rcx
    mov r12, rsi
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; new a8: Vec = (b, q, a, a7)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61146
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab61147

lab61146:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61144
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61137
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61135
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61136

lab61135:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61136:

lab61137:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61140
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61138
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61139

lab61138:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61139:

lab61140:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61143
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61141
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61142

lab61141:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61142:

lab61143:
    jmp lab61145

lab61144:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61145:

lab61147:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61159
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab61160

lab61159:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61157
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61150
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61148
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61149

lab61148:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61149:

lab61150:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61153
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61151
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61152

lab61151:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61152:

lab61153:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61156
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61154
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61155

lab61154:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61155:

lab61156:
    jmp lab61158

lab61157:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61158:

lab61160:
    ; #load tag
    lea r11, [rel Vec_61161]
    ; x8 <- m + n;
    mov r13, rdi
    add r13, rdx
    ; substitute (c !-> c)(n !-> n)(x8 !-> x8)(a8 !-> a8);
    ; #move variables
    mov rdi, rdx
    mov rax, r8
    mov rdx, r9
    mov r9, r13
    ; jump scale_vec2_
    jmp scale_vec2_

Vec_61161:

Vec_61161_Vec:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61166
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61162
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61162:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab61163
    ; ####increment refcount
    add qword [r14 + 0], 1

lab61163:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab61164
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61164:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab61165
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61165:
    jmp lab61167

lab61166:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab61167:
    ; substitute (a7 !-> a7)(a !-> a)(b !-> b)(q !-> q)(x9 !-> x9)(y0 !-> y0);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    mov rsi, r12
    mov rax, r14
    ; let x7: Vec = Vec(x9, y0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61179
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab61180

lab61179:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61177
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61170
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61168
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61169

lab61168:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61169:

lab61170:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61173
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61171
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61172

lab61171:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61172:

lab61173:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61176
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61174
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61175

lab61174:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61175:

lab61176:
    jmp lab61178

lab61177:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61178:

lab61180:
    ; #load tag
    mov r13, 0
    ; substitute (q !-> q)(a !-> a)(b !-> b)(x7 !-> x7)(a7 !-> a7);
    ; #move variables
    mov rcx, r10
    mov r10, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, r13
    mov r13, rdx
    mov rdx, rcx
    ; let a13: Fun[Vec, List[Vec4]] = Ap(x7, a7);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61192
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab61193

lab61192:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61190
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61183
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61181
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61182

lab61181:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61182:

lab61183:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61186
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61184
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61185

lab61184:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61185:

lab61186:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61189
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61187
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61188

lab61187:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61188:

lab61189:
    jmp lab61191

lab61190:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61191:

lab61193:
    ; #load tag
    mov r11, 0
    ; let a12: Fun[Vec, Fun[Vec, List[Vec4]]] = Ap(b, a13);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61205
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab61206

lab61205:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61203
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61196
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61194
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61195

lab61194:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61195:

lab61196:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61199
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61197
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61198

lab61197:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61198:

lab61199:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61202
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61200
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61201

lab61200:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61201:

lab61202:
    jmp lab61204

lab61203:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61204:

lab61206:
    ; #load tag
    mov r9, 0
    ; substitute (a !-> a)(a12 !-> a12)(q !-> q);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke q Ap
    jmp r9

List_Vec4_61134:
    jmp near List_Vec4_61134_Nil
    jmp near List_Vec4_61134_Cons

List_Vec4_61134_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab61209
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab61207
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61207:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab61208
    ; ####increment refcount
    add qword [rax + 0], 1

lab61208:
    jmp lab61210

lab61209:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab61210:
    ; let x6: List[Vec4] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x6 !-> x6)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump append_vec4_
    jmp append_vec4_

List_Vec4_61134_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61213
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61211
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61211:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61212
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61212:
    jmp lab61214

lab61213:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61214:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a14 !-> a14)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x6: List[Vec4] = Cons(a14, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61226
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab61227

lab61226:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61224
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61217
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61215
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61216

lab61215:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61216:

lab61217:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61220
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61218
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61219

lab61218:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61219:

lab61220:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61223
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61221
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61222

lab61221:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61222:

lab61223:
    jmp lab61225

lab61224:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61225:

lab61227:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x6 !-> x6)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump append_vec4_
    jmp append_vec4_

tile_to_grid_:
    ; lit x0 <- 16;
    mov r15, 16
    ; lit x1 <- 16;
    mov qword [rsp + 2024], 16
    ; substitute (x0 !-> x0)(x1 !-> x1)(arg !-> arg)(arg2 !-> arg2)(arg3 !-> arg3)(arg4 !-> arg4)(a0 !-> a0);
    ; #move variables
    mov [rsp + 2032], r12
    mov r12, r8
    mov r8, rax
    mov rcx, r15
    mov r15, r11
    mov r11, rdi
    mov rdi, [rsp + 2024]
    mov [rsp + 2024], r13
    mov r13, r9
    mov r9, rdx
    mov rdx, rcx
    mov r14, r10
    mov r10, rsi
    ; jump grid_
    jmp grid_

p_:
    ; new a1: List[Vec4] = (arg, q6, q7, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61239
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab61240

lab61239:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61237
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61230
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61228
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61229

lab61228:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61229:

lab61230:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61233
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61231
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61232

lab61231:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61232:

lab61233:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61236
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61234
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61235

lab61234:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61235:

lab61236:
    jmp lab61238

lab61237:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61238:

lab61240:
    ; ##store link to previous block
    mov [rbx + 48], rsi
    ; ##store values
    mov [rbx + 40], rdx
    mov [rbx + 32], rax
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rax, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61252
    ; ####initialize refcount of just acquired block
    mov qword [rax + 0], 0
    jmp lab61253

lab61252:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61250
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61243
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61241
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61242

lab61241:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61242:

lab61243:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61246
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61244
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61245

lab61244:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61245:

lab61246:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61249
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61247
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61248

lab61247:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61248:

lab61249:
    jmp lab61251

lab61250:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61251:

lab61253:
    ; #load tag
    lea rdx, [rel List_Vec4_61254]
    ; jump p_tile_
    jmp p_tile_

List_Vec4_61254:
    jmp near List_Vec4_61254_Nil
    jmp near List_Vec4_61254_Cons

List_Vec4_61254_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab61259
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab61255
    ; ####increment refcount
    add qword [rax + 0], 1

lab61255:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab61256
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61256:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab61257
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61257:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab61258
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61258:
    jmp lab61260

lab61259:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab61260:
    ; let x0: List[Vec4] = Nil();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 0
    ; substitute (x0 !-> x0)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump tile_to_grid_
    jmp tile_to_grid_

List_Vec4_61254_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61265
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61261
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61261:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab61262
    ; ####increment refcount
    add qword [r14 + 0], 1

lab61262:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab61263
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61263:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab61264
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61264:
    jmp lab61266

lab61265:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab61266:
    ; substitute (a0 !-> a0)(q7 !-> q7)(arg !-> arg)(q6 !-> q6)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, r14
    mov r14, rsi
    mov rsi, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    ; let x0: List[Vec4] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61278
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab61279

lab61278:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61276
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61269
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61267
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61268

lab61267:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61268:

lab61269:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61272
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61270
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61271

lab61270:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61271:

lab61272:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61275
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61273
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61274

lab61273:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61274:

lab61275:
    jmp lab61277

lab61276:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61277:

lab61279:
    ; #load tag
    mov r13, 5
    ; substitute (x0 !-> x0)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump tile_to_grid_
    jmp tile_to_grid_

q_:
    ; new a1: List[Vec4] = (arg, q6, q7, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61291
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab61292

lab61291:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61289
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61282
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61280
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61281

lab61280:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61281:

lab61282:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61285
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61283
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61284

lab61283:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61284:

lab61285:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61288
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61286
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61287

lab61286:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61287:

lab61288:
    jmp lab61290

lab61289:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61290:

lab61292:
    ; ##store link to previous block
    mov [rbx + 48], rsi
    ; ##store values
    mov [rbx + 40], rdx
    mov [rbx + 32], rax
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rax, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61304
    ; ####initialize refcount of just acquired block
    mov qword [rax + 0], 0
    jmp lab61305

lab61304:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61302
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61295
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61293
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61294

lab61293:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61294:

lab61295:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61298
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61296
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61297

lab61296:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61297:

lab61298:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61301
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61299
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61300

lab61299:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61300:

lab61301:
    jmp lab61303

lab61302:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61303:

lab61305:
    ; #load tag
    lea rdx, [rel List_Vec4_61306]
    ; jump q_tile_
    jmp q_tile_

List_Vec4_61306:
    jmp near List_Vec4_61306_Nil
    jmp near List_Vec4_61306_Cons

List_Vec4_61306_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab61311
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab61307
    ; ####increment refcount
    add qword [rax + 0], 1

lab61307:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab61308
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61308:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab61309
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61309:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab61310
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61310:
    jmp lab61312

lab61311:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab61312:
    ; let x0: List[Vec4] = Nil();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 0
    ; substitute (x0 !-> x0)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump tile_to_grid_
    jmp tile_to_grid_

List_Vec4_61306_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61317
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61313
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61313:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab61314
    ; ####increment refcount
    add qword [r14 + 0], 1

lab61314:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab61315
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61315:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab61316
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61316:
    jmp lab61318

lab61317:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab61318:
    ; substitute (a0 !-> a0)(q7 !-> q7)(arg !-> arg)(q6 !-> q6)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, r14
    mov r14, rsi
    mov rsi, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    ; let x0: List[Vec4] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61330
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab61331

lab61330:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61328
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61321
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61319
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61320

lab61319:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61320:

lab61321:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61324
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61322
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61323

lab61322:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61323:

lab61324:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61327
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61325
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61326

lab61325:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61326:

lab61327:
    jmp lab61329

lab61328:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61329:

lab61331:
    ; #load tag
    mov r13, 5
    ; substitute (x0 !-> x0)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump tile_to_grid_
    jmp tile_to_grid_

r_:
    ; new a1: List[Vec4] = (arg, q6, q7, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61343
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab61344

lab61343:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61341
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61334
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61332
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61333

lab61332:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61333:

lab61334:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61337
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61335
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61336

lab61335:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61336:

lab61337:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61340
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61338
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61339

lab61338:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61339:

lab61340:
    jmp lab61342

lab61341:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61342:

lab61344:
    ; ##store link to previous block
    mov [rbx + 48], rsi
    ; ##store values
    mov [rbx + 40], rdx
    mov [rbx + 32], rax
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rax, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61356
    ; ####initialize refcount of just acquired block
    mov qword [rax + 0], 0
    jmp lab61357

lab61356:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61354
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61347
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61345
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61346

lab61345:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61346:

lab61347:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61350
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61348
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61349

lab61348:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61349:

lab61350:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61353
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61351
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61352

lab61351:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61352:

lab61353:
    jmp lab61355

lab61354:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61355:

lab61357:
    ; #load tag
    lea rdx, [rel List_Vec4_61358]
    ; jump r_tile_
    jmp r_tile_

List_Vec4_61358:
    jmp near List_Vec4_61358_Nil
    jmp near List_Vec4_61358_Cons

List_Vec4_61358_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab61363
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab61359
    ; ####increment refcount
    add qword [rax + 0], 1

lab61359:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab61360
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61360:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab61361
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61361:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab61362
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61362:
    jmp lab61364

lab61363:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab61364:
    ; let x0: List[Vec4] = Nil();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 0
    ; substitute (x0 !-> x0)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump tile_to_grid_
    jmp tile_to_grid_

List_Vec4_61358_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61369
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61365
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61365:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab61366
    ; ####increment refcount
    add qword [r14 + 0], 1

lab61366:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab61367
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61367:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab61368
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61368:
    jmp lab61370

lab61369:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab61370:
    ; substitute (a0 !-> a0)(q7 !-> q7)(arg !-> arg)(q6 !-> q6)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, r14
    mov r14, rsi
    mov rsi, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    ; let x0: List[Vec4] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61382
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab61383

lab61382:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61380
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61373
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61371
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61372

lab61371:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61372:

lab61373:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61376
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61374
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61375

lab61374:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61375:

lab61376:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61379
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61377
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61378

lab61377:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61378:

lab61379:
    jmp lab61381

lab61380:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61381:

lab61383:
    ; #load tag
    mov r13, 5
    ; substitute (x0 !-> x0)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump tile_to_grid_
    jmp tile_to_grid_

s_:
    ; new a1: List[Vec4] = (arg, q6, q7, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61395
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab61396

lab61395:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61393
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61386
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61384
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61385

lab61384:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61385:

lab61386:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61389
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61387
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61388

lab61387:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61388:

lab61389:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61392
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61390
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61391

lab61390:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61391:

lab61392:
    jmp lab61394

lab61393:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61394:

lab61396:
    ; ##store link to previous block
    mov [rbx + 48], rsi
    ; ##store values
    mov [rbx + 40], rdx
    mov [rbx + 32], rax
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rax, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61408
    ; ####initialize refcount of just acquired block
    mov qword [rax + 0], 0
    jmp lab61409

lab61408:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61406
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61399
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61397
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61398

lab61397:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61398:

lab61399:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61402
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61400
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61401

lab61400:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61401:

lab61402:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61405
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61403
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61404

lab61403:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61404:

lab61405:
    jmp lab61407

lab61406:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61407:

lab61409:
    ; #load tag
    lea rdx, [rel List_Vec4_61410]
    ; jump s_tile_
    jmp s_tile_

List_Vec4_61410:
    jmp near List_Vec4_61410_Nil
    jmp near List_Vec4_61410_Cons

List_Vec4_61410_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab61415
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab61411
    ; ####increment refcount
    add qword [rax + 0], 1

lab61411:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab61412
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61412:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab61413
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61413:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab61414
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61414:
    jmp lab61416

lab61415:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab61416:
    ; let x0: List[Vec4] = Nil();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 0
    ; substitute (x0 !-> x0)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump tile_to_grid_
    jmp tile_to_grid_

List_Vec4_61410_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61421
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61417
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61417:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab61418
    ; ####increment refcount
    add qword [r14 + 0], 1

lab61418:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab61419
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61419:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab61420
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61420:
    jmp lab61422

lab61421:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab61422:
    ; substitute (a0 !-> a0)(q7 !-> q7)(arg !-> arg)(q6 !-> q6)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, r14
    mov r14, rsi
    mov rsi, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    ; let x0: List[Vec4] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61434
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab61435

lab61434:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61432
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61425
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61423
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61424

lab61423:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61424:

lab61425:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61428
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61426
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61427

lab61426:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61427:

lab61428:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61431
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61429
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61430

lab61429:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61430:

lab61431:
    jmp lab61433

lab61432:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61433:

lab61435:
    ; #load tag
    mov r13, 5
    ; substitute (x0 !-> x0)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump tile_to_grid_
    jmp tile_to_grid_

quartet_:
    ; lit x0 <- 1;
    mov qword [rsp + 1992], 1
    ; lit x1 <- 1;
    mov qword [rsp + 1976], 1
    ; substitute (x1 !-> x1)(x0 !-> x0)(c !-> c)(d !-> d)(arg !-> arg)(a6 !-> a6)(a7 !-> a7)(a0 !-> a0)(b !-> b)(a !-> a);
    ; #move variables
    mov [rsp + 1984], rax
    mov rcx, [rsp + 1976]
    mov [rsp + 1976], rdx
    mov rdx, rcx
    mov [rsp + 2000], rsi
    mov rcx, [rsp + 1992]
    mov [rsp + 1992], rdi
    mov rdi, rcx
    ; new x2: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (b, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61447
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab61448

lab61447:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61445
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61438
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61436
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61437

lab61436:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61437:

lab61438:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61441
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61439
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61440

lab61439:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61440:

lab61441:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61444
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61442
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61443

lab61442:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61443:

lab61444:
    jmp lab61446

lab61445:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61446:

lab61448:
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61449]
    mov [rsp + 1992], rcx
    ; substitute (x1 !-> x1)(x0 !-> x0)(x2 !-> x2)(a0 !-> a0)(arg !-> arg)(a6 !-> a6)(a7 !-> a7)(d !-> d)(c !-> c);
    ; #move variables
    mov rcx, [rsp + 2000]
    mov [rsp + 2000], r8
    mov r8, rcx
    mov rcx, [rsp + 1992]
    mov [rsp + 1992], r9
    mov r9, rcx
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], r10
    mov r10, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r11
    mov r11, rcx
    ; new x3: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (d, c)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61461
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab61462

lab61461:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61459
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61452
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61450
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61451

lab61450:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61451:

lab61452:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61455
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61453
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61454

lab61453:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61454:

lab61455:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61458
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61456
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61457

lab61456:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61457:

lab61458:
    jmp lab61460

lab61459:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61460:

lab61462:
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61463]
    mov [rsp + 2008], rcx
    ; substitute (x0 !-> x0)(x1 !-> x1)(x2 !-> x2)(x3 !-> x3)(arg !-> arg)(a6 !-> a6)(a7 !-> a7)(a0 !-> a0);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], r10
    mov r10, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r11
    mov r11, rcx
    ; jump above_
    jmp above_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61463:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61463_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61466
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61464
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61464:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61465
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61465:
    jmp lab61467

lab61466:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61467:
    ; substitute (p50 !-> p50)(c !-> c)(d !-> d)(a4 !-> a4);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch a4 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61468:

Fun_Vec_Fun_Vec_List_Vec4_61468_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab61471
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab61469
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61469:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab61470
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61470:
    jmp lab61472

lab61471:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab61472:
    ; switch a5 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61473:

Fun_Vec_List_Vec4_61473_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab61476
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab61474
    ; ####increment refcount
    add qword [r14 + 0], 1

lab61474:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab61475
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61475:
    jmp lab61477

lab61476:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab61477:
    ; lit x4 <- 1;
    mov qword [rsp + 2024], 1
    ; lit x5 <- 1;
    mov qword [rsp + 2008], 1
    ; substitute (x4 !-> x4)(x5 !-> x5)(c !-> c)(d !-> d)(p50 !-> p50)(p60 !-> p60)(p70 !-> p70)(a8 !-> a8);
    ; #move variables
    mov [rsp + 2032], r12
    mov r12, rax
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r13
    mov r13, rdx
    mov rdx, rcx
    mov [rsp + 2016], r14
    mov r14, r10
    mov r10, r8
    mov r8, rsi
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r15
    mov r15, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump beside_
    jmp beside_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61449:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61449_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61480
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61478
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61478:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61479
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61479:
    jmp lab61481

lab61480:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61481:
    ; substitute (p5 !-> p5)(a !-> a)(b !-> b)(a1 !-> a1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61482:

Fun_Vec_Fun_Vec_List_Vec4_61482_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab61485
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab61483
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61483:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab61484
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61484:
    jmp lab61486

lab61485:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab61486:
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61487:

Fun_Vec_List_Vec4_61487_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab61490
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab61488
    ; ####increment refcount
    add qword [r14 + 0], 1

lab61488:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab61489
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61489:
    jmp lab61491

lab61490:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab61491:
    ; lit x6 <- 1;
    mov qword [rsp + 2024], 1
    ; lit x7 <- 1;
    mov qword [rsp + 2008], 1
    ; substitute (x6 !-> x6)(x7 !-> x7)(a !-> a)(b !-> b)(p5 !-> p5)(p6 !-> p6)(p7 !-> p7)(a3 !-> a3);
    ; #move variables
    mov [rsp + 2032], r12
    mov r12, rax
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r13
    mov r13, rdx
    mov rdx, rcx
    mov [rsp + 2016], r14
    mov r14, r10
    mov r10, r8
    mov r8, rsi
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r15
    mov r15, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump beside_
    jmp beside_

t_:
    ; new x0: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61492]
    ; new x1: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    lea r15, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61493]
    ; new x2: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61494]
    mov [rsp + 2024], rcx
    ; new x3: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2016], 0
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61495]
    mov [rsp + 2008], rcx
    ; substitute (x0 !-> x0)(x1 !-> x1)(x2 !-> x2)(x3 !-> x3)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r14
    mov r14, rsi
    mov rsi, rcx
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], r8
    mov r8, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r9
    mov r9, rcx
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], r10
    mov r10, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r11
    mov r11, rcx
    ; jump quartet_
    jmp quartet_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61495:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61495_Ap:
    ; switch a10 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61496:

Fun_Vec_Fun_Vec_List_Vec4_61496_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61499
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61497
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61497:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61498
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61498:
    jmp lab61500

lab61499:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61500:
    ; switch a11 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61501:

Fun_Vec_List_Vec4_61501_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61504
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61502
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61502:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61503
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61503:
    jmp lab61505

lab61504:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61505:
    ; jump s_
    jmp s_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61494:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61494_Ap:
    ; switch a7 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61506:

Fun_Vec_Fun_Vec_List_Vec4_61506_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61509
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61507
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61507:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61508
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61508:
    jmp lab61510

lab61509:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61510:
    ; switch a8 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61511:

Fun_Vec_List_Vec4_61511_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61514
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61512
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61512:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61513
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61513:
    jmp lab61515

lab61514:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61515:
    ; jump r_
    jmp r_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61493:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61493_Ap:
    ; switch a4 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61516:

Fun_Vec_Fun_Vec_List_Vec4_61516_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61519
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61517
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61517:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61518
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61518:
    jmp lab61520

lab61519:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61520:
    ; switch a5 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61521:

Fun_Vec_List_Vec4_61521_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61524
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61522
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61522:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61523
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61523:
    jmp lab61525

lab61524:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61525:
    ; jump q_
    jmp q_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61492:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61492_Ap:
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61526:

Fun_Vec_Fun_Vec_List_Vec4_61526_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61529
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61527
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61527:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61528
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61528:
    jmp lab61530

lab61529:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61530:
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61531:

Fun_Vec_List_Vec4_61531_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61534
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61532
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61532:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61533
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61533:
    jmp lab61535

lab61534:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61535:
    ; jump p_
    jmp p_

cycle__:
    ; substitute (p10 !-> p1)(arg !-> arg)(p3 !-> p3)(p4 !-> p4)(a0 !-> a0)(p1 !-> p1);
    ; #share p1
    cmp rax, 0
    je lab61536
    ; ####increment refcount
    add qword [rax + 0], 1

lab61536:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    ; new x0: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (p1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61548
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab61549

lab61548:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61546
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61539
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61537
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61538

lab61537:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61538:

lab61539:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61542
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61540
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61541

lab61540:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61541:

lab61542:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61545
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61543
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61544

lab61543:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61544:

lab61545:
    jmp lab61547

lab61546:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61547:

lab61549:
    ; #load tag
    lea r15, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61550]
    ; substitute (p100 !-> p10)(arg !-> arg)(p3 !-> p3)(p4 !-> p4)(a0 !-> a0)(x0 !-> x0)(p10 !-> p10);
    ; #share p10
    cmp rax, 0
    je lab61551
    ; ####increment refcount
    add qword [rax + 0], 1

lab61551:
    ; #move variables
    mov [rsp + 2032], rax
    mov [rsp + 2024], rdx
    ; new x1: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (p10)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61563
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab61564

lab61563:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61561
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61554
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61552
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61553

lab61552:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61553:

lab61554:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61557
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61555
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61556

lab61555:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61556:

lab61557:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61560
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61558
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61559

lab61558:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61559:

lab61560:
    jmp lab61562

lab61561:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61562:

lab61564:
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61565]
    mov [rsp + 2024], rcx
    ; substitute (p1000 !-> p100)(arg !-> arg)(p3 !-> p3)(p4 !-> p4)(a0 !-> a0)(x0 !-> x0)(x1 !-> x1)(p100 !-> p100);
    ; #share p100
    cmp rax, 0
    je lab61566
    ; ####increment refcount
    add qword [rax + 0], 1

lab61566:
    ; #move variables
    mov [rsp + 2016], rax
    mov [rsp + 2008], rdx
    ; new x2: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (p100)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61578
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab61579

lab61578:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61576
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61569
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61567
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61568

lab61567:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61568:

lab61569:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61572
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61570
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61571

lab61570:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61571:

lab61572:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61575
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61573
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61574

lab61573:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61574:

lab61575:
    jmp lab61577

lab61576:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61577:

lab61579:
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61580]
    mov [rsp + 2008], rcx
    ; substitute (p1000 !-> p1000)(x0 !-> x0)(x1 !-> x1)(x2 !-> x2)(arg !-> arg)(p3 !-> p3)(p4 !-> p4)(a0 !-> a0);
    ; #move variables
    mov rcx, r14
    mov r14, r8
    mov r8, [rsp + 2032]
    mov [rsp + 2032], r10
    mov r10, [rsp + 2016]
    mov [rsp + 2016], r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r15
    mov r15, r9
    mov r9, [rsp + 2024]
    mov [rsp + 2024], r11
    mov r11, [rsp + 2008]
    mov [rsp + 2008], r13
    mov r13, rdi
    mov rdi, rcx
    ; jump quartet_
    jmp quartet_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61580:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61580_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61582
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab61581
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61581:
    jmp lab61583

lab61582:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab61583:
    ; substitute (a22 !-> a22)(p100 !-> p100)(a13 !-> a13);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch a13 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61584:

Fun_Vec_Fun_Vec_List_Vec4_61584_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61587
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61585
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61585:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61586
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61586:
    jmp lab61588

lab61587:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61588:
    ; switch a14 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61589:

Fun_Vec_List_Vec4_61589_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab61592
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab61590
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61590:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab61591
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61591:
    jmp lab61593

lab61592:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab61593:
    ; substitute (a22 !-> a22)(a15 !-> a15)(b3 !-> b3)(c3 !-> c3)(p100 !-> p100);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    ; new x3: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (p100)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61605
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab61606

lab61605:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61603
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61596
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61594
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61595

lab61594:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61595:

lab61596:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61599
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61597
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61598

lab61597:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61598:

lab61599:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61602
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61600
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61601

lab61600:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61601:

lab61602:
    jmp lab61604

lab61603:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61604:

lab61606:
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61607]
    ; substitute (x3 !-> x3)(a22 !-> a22)(b3 !-> b3)(c3 !-> c3)(a15 !-> a15);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump rot_
    jmp rot_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61607:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61607_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61609
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab61608
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61608:
    jmp lab61610

lab61609:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab61610:
    ; substitute (a23 !-> a23)(p100 !-> p100)(a16 !-> a16);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch a16 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61611:

Fun_Vec_Fun_Vec_List_Vec4_61611_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61614
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61612
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61612:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61613
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61613:
    jmp lab61615

lab61614:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61615:
    ; switch a17 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61616:

Fun_Vec_List_Vec4_61616_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab61619
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab61617
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61617:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab61618
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61618:
    jmp lab61620

lab61619:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab61620:
    ; substitute (p100 !-> p100)(a23 !-> a23)(b4 !-> b4)(c4 !-> c4)(a18 !-> a18);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump rot_
    jmp rot_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61565:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61565_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61622
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab61621
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61621:
    jmp lab61623

lab61622:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab61623:
    ; substitute (a21 !-> a21)(p10 !-> p10)(a10 !-> a10);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch a10 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61624:

Fun_Vec_Fun_Vec_List_Vec4_61624_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61627
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61625
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61625:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61626
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61626:
    jmp lab61628

lab61627:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61628:
    ; switch a11 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61629:

Fun_Vec_List_Vec4_61629_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab61632
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab61630
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61630:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab61631
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61631:
    jmp lab61633

lab61632:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab61633:
    ; substitute (p10 !-> p10)(a21 !-> a21)(b2 !-> b2)(c2 !-> c2)(a12 !-> a12);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump rot_
    jmp rot_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61550:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61550_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61635
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab61634
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61634:
    jmp lab61636

lab61635:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab61636:
    ; substitute (a !-> a)(p1 !-> p1)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61637:

Fun_Vec_Fun_Vec_List_Vec4_61637_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61640
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61638
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61638:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61639
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61639:
    jmp lab61641

lab61640:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61641:
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61642:

Fun_Vec_List_Vec4_61642_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab61645
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab61643
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61643:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab61644
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61644:
    jmp lab61646

lab61645:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab61646:
    ; substitute (a !-> a)(a3 !-> a3)(b !-> b)(c !-> c)(p1 !-> p1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    ; new x4: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (p1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61658
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab61659

lab61658:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61656
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61649
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61647
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61648

lab61647:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61648:

lab61649:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61652
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61650
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61651

lab61650:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61651:

lab61652:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61655
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61653
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61654

lab61653:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61654:

lab61655:
    jmp lab61657

lab61656:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61657:

lab61659:
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61660]
    ; substitute (x4 !-> x4)(a !-> a)(b !-> b)(c !-> c)(a3 !-> a3);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump rot_
    jmp rot_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61660:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61660_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61662
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab61661
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61661:
    jmp lab61663

lab61662:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab61663:
    ; substitute (a19 !-> a19)(p1 !-> p1)(a4 !-> a4);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch a4 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61664:

Fun_Vec_Fun_Vec_List_Vec4_61664_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61667
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61665
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61665:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61666
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61666:
    jmp lab61668

lab61667:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61668:
    ; switch a5 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61669:

Fun_Vec_List_Vec4_61669_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab61672
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab61670
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61670:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab61671
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61671:
    jmp lab61673

lab61672:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab61673:
    ; substitute (a19 !-> a19)(a6 !-> a6)(b0 !-> b0)(c0 !-> c0)(p1 !-> p1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    ; new x5: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (p1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab61685
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab61686

lab61685:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab61683
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab61676
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61674
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61675

lab61674:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61675:

lab61676:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab61679
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61677
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61678

lab61677:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61678:

lab61679:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab61682
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab61680
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab61681

lab61680:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab61681:

lab61682:
    jmp lab61684

lab61683:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab61684:

lab61686:
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61687]
    ; substitute (x5 !-> x5)(a19 !-> a19)(b0 !-> b0)(c0 !-> c0)(a6 !-> a6);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump rot_
    jmp rot_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61687:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61687_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61689
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab61688
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61688:
    jmp lab61690

lab61689:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab61690:
    ; substitute (a20 !-> a20)(p1 !-> p1)(a7 !-> a7);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch a7 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61691:

Fun_Vec_Fun_Vec_List_Vec4_61691_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61694
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61692
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61692:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61693
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61693:
    jmp lab61695

lab61694:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61695:
    ; switch a8 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61696:

Fun_Vec_List_Vec4_61696_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab61699
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab61697
    ; ####increment refcount
    add qword [r12 + 0], 1

lab61697:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab61698
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61698:
    jmp lab61700

lab61699:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab61700:
    ; substitute (p1 !-> p1)(a20 !-> a20)(b1 !-> b1)(c1 !-> c1)(a9 !-> a9);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump rot_
    jmp rot_

u_:
    ; new x0: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61701]
    ; substitute (x0 !-> x0)(arg !-> arg)(p2 !-> p2)(p3 !-> p3)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump cycle__
    jmp cycle__

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61701:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61701_Ap:
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61702:

Fun_Vec_Fun_Vec_List_Vec4_61702_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61705
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61703
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61703:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61704
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61704:
    jmp lab61706

lab61705:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61706:
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61707:

Fun_Vec_List_Vec4_61707_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61710
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61708
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61708:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61709
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61709:
    jmp lab61711

lab61710:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61711:
    ; new x1: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61712]
    ; substitute (x1 !-> x1)(a !-> a)(b !-> b)(c !-> c)(a3 !-> a3);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump rot_
    jmp rot_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61712:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61712_Ap:
    ; switch a4 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61713:

Fun_Vec_Fun_Vec_List_Vec4_61713_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61716
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61714
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61714:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61715
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61715:
    jmp lab61717

lab61716:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61717:
    ; switch a5 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61718:

Fun_Vec_List_Vec4_61718_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61721
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61719
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61719:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61720
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61720:
    jmp lab61722

lab61721:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61722:
    ; jump q_
    jmp q_

side1_:
    ; new x0: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61723]
    ; new x1: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    lea r15, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61724]
    ; new x2: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61725]
    mov [rsp + 2024], rcx
    ; new x3: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2016], 0
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61726]
    mov [rsp + 2008], rcx
    ; substitute (x0 !-> x0)(x1 !-> x1)(x2 !-> x2)(x3 !-> x3)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r14
    mov r14, rsi
    mov rsi, rcx
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], r8
    mov r8, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r9
    mov r9, rcx
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], r10
    mov r10, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r11
    mov r11, rcx
    ; jump quartet_
    jmp quartet_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61726:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61726_Ap:
    ; switch a13 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61727:

Fun_Vec_Fun_Vec_List_Vec4_61727_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61730
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61728
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61728:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61729
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61729:
    jmp lab61731

lab61730:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61731:
    ; switch a14 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61732:

Fun_Vec_List_Vec4_61732_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61735
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61733
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61733:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61734
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61734:
    jmp lab61736

lab61735:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61736:
    ; jump t_
    jmp t_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61725:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61725_Ap:
    ; switch a7 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61737:

Fun_Vec_Fun_Vec_List_Vec4_61737_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61740
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61738
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61738:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61739
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61739:
    jmp lab61741

lab61740:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61741:
    ; switch a8 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61742:

Fun_Vec_List_Vec4_61742_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61745
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61743
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61743:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61744
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61744:
    jmp lab61746

lab61745:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61746:
    ; new x4: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61747]
    ; substitute (x4 !-> x4)(a17 !-> a17)(b1 !-> b1)(c1 !-> c1)(a9 !-> a9);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump rot_
    jmp rot_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61747:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61747_Ap:
    ; switch a10 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61748:

Fun_Vec_Fun_Vec_List_Vec4_61748_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61751
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61749
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61749:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61750
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61750:
    jmp lab61752

lab61751:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61752:
    ; switch a11 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61753:

Fun_Vec_List_Vec4_61753_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61756
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61754
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61754:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61755
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61755:
    jmp lab61757

lab61756:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61757:
    ; jump t_
    jmp t_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61724:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61724_Ap:
    ; switch a4 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61758:

Fun_Vec_Fun_Vec_List_Vec4_61758_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61761
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61759
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61759:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61760
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61760:
    jmp lab61762

lab61761:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61762:
    ; switch a5 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61763:

Fun_Vec_List_Vec4_61763_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61766
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61764
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61764:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61765
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61765:
    jmp lab61767

lab61766:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61767:
    ; jump nil_
    jmp nil_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61723:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61723_Ap:
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61768:

Fun_Vec_Fun_Vec_List_Vec4_61768_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61771
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61769
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61769:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61770
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61770:
    jmp lab61772

lab61771:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61772:
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61773:

Fun_Vec_List_Vec4_61773_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61776
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61774
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61774:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61775
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61775:
    jmp lab61777

lab61776:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61777:
    ; jump nil_
    jmp nil_

side2_:
    ; new x0: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61778]
    ; new x1: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    lea r15, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61779]
    ; new x2: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61780]
    mov [rsp + 2024], rcx
    ; new x3: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2016], 0
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61781]
    mov [rsp + 2008], rcx
    ; substitute (x0 !-> x0)(x1 !-> x1)(x2 !-> x2)(x3 !-> x3)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r14
    mov r14, rsi
    mov rsi, rcx
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], r8
    mov r8, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r9
    mov r9, rcx
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], r10
    mov r10, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r11
    mov r11, rcx
    ; jump quartet_
    jmp quartet_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61781:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61781_Ap:
    ; switch a13 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61782:

Fun_Vec_Fun_Vec_List_Vec4_61782_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61785
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61783
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61783:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61784
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61784:
    jmp lab61786

lab61785:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61786:
    ; switch a14 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61787:

Fun_Vec_List_Vec4_61787_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61790
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61788
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61788:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61789
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61789:
    jmp lab61791

lab61790:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61791:
    ; jump t_
    jmp t_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61780:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61780_Ap:
    ; switch a7 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61792:

Fun_Vec_Fun_Vec_List_Vec4_61792_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61795
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61793
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61793:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61794
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61794:
    jmp lab61796

lab61795:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61796:
    ; switch a8 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61797:

Fun_Vec_List_Vec4_61797_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61800
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61798
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61798:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61799
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61799:
    jmp lab61801

lab61800:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61801:
    ; new x4: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61802]
    ; substitute (x4 !-> x4)(a17 !-> a17)(b1 !-> b1)(c1 !-> c1)(a9 !-> a9);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump rot_
    jmp rot_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61802:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61802_Ap:
    ; switch a10 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61803:

Fun_Vec_Fun_Vec_List_Vec4_61803_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61806
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61804
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61804:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61805
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61805:
    jmp lab61807

lab61806:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61807:
    ; switch a11 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61808:

Fun_Vec_List_Vec4_61808_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61811
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61809
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61809:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61810
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61810:
    jmp lab61812

lab61811:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61812:
    ; jump t_
    jmp t_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61779:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61779_Ap:
    ; switch a4 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61813:

Fun_Vec_Fun_Vec_List_Vec4_61813_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61816
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61814
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61814:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61815
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61815:
    jmp lab61817

lab61816:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61817:
    ; switch a5 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61818:

Fun_Vec_List_Vec4_61818_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61821
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61819
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61819:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61820
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61820:
    jmp lab61822

lab61821:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61822:
    ; jump side1_
    jmp side1_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61778:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61778_Ap:
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61823:

Fun_Vec_Fun_Vec_List_Vec4_61823_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61826
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61824
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61824:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61825
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61825:
    jmp lab61827

lab61826:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61827:
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61828:

Fun_Vec_List_Vec4_61828_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61831
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61829
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61829:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61830
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61830:
    jmp lab61832

lab61831:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61832:
    ; jump side1_
    jmp side1_

corner1_:
    ; new x0: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61833]
    ; new x1: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    lea r15, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61834]
    ; new x2: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61835]
    mov [rsp + 2024], rcx
    ; new x3: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2016], 0
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61836]
    mov [rsp + 2008], rcx
    ; substitute (x0 !-> x0)(x1 !-> x1)(x2 !-> x2)(x3 !-> x3)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r14
    mov r14, rsi
    mov rsi, rcx
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], r8
    mov r8, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r9
    mov r9, rcx
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], r10
    mov r10, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r11
    mov r11, rcx
    ; jump quartet_
    jmp quartet_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61836:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61836_Ap:
    ; switch a10 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61837:

Fun_Vec_Fun_Vec_List_Vec4_61837_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61840
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61838
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61838:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61839
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61839:
    jmp lab61841

lab61840:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61841:
    ; switch a11 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61842:

Fun_Vec_List_Vec4_61842_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61845
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61843
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61843:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61844
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61844:
    jmp lab61846

lab61845:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61846:
    ; jump u_
    jmp u_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61835:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61835_Ap:
    ; switch a7 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61847:

Fun_Vec_Fun_Vec_List_Vec4_61847_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61850
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61848
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61848:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61849
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61849:
    jmp lab61851

lab61850:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61851:
    ; switch a8 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61852:

Fun_Vec_List_Vec4_61852_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61855
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61853
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61853:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61854
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61854:
    jmp lab61856

lab61855:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61856:
    ; jump nil_
    jmp nil_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61834:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61834_Ap:
    ; switch a4 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61857:

Fun_Vec_Fun_Vec_List_Vec4_61857_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61860
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61858
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61858:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61859
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61859:
    jmp lab61861

lab61860:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61861:
    ; switch a5 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61862:

Fun_Vec_List_Vec4_61862_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61865
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61863
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61863:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61864
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61864:
    jmp lab61866

lab61865:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61866:
    ; jump nil_
    jmp nil_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61833:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61833_Ap:
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61867:

Fun_Vec_Fun_Vec_List_Vec4_61867_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61870
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61868
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61868:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61869
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61869:
    jmp lab61871

lab61870:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61871:
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61872:

Fun_Vec_List_Vec4_61872_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61875
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61873
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61873:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61874
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61874:
    jmp lab61876

lab61875:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61876:
    ; jump nil_
    jmp nil_

corner2_:
    ; new x0: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61877]
    ; new x1: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    lea r15, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61878]
    ; new x2: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61879]
    mov [rsp + 2024], rcx
    ; new x3: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2016], 0
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61880]
    mov [rsp + 2008], rcx
    ; substitute (x0 !-> x0)(x1 !-> x1)(x2 !-> x2)(x3 !-> x3)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r14
    mov r14, rsi
    mov rsi, rcx
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], r8
    mov r8, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r9
    mov r9, rcx
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], r10
    mov r10, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r11
    mov r11, rcx
    ; jump quartet_
    jmp quartet_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61880:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61880_Ap:
    ; switch a13 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61881:

Fun_Vec_Fun_Vec_List_Vec4_61881_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61884
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61882
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61882:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61883
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61883:
    jmp lab61885

lab61884:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61885:
    ; switch a14 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61886:

Fun_Vec_List_Vec4_61886_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61889
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61887
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61887:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61888
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61888:
    jmp lab61890

lab61889:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61890:
    ; jump u_
    jmp u_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61879:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61879_Ap:
    ; switch a7 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61891:

Fun_Vec_Fun_Vec_List_Vec4_61891_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61894
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61892
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61892:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61893
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61893:
    jmp lab61895

lab61894:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61895:
    ; switch a8 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61896:

Fun_Vec_List_Vec4_61896_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61899
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61897
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61897:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61898
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61898:
    jmp lab61900

lab61899:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61900:
    ; new x4: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61901]
    ; substitute (x4 !-> x4)(a17 !-> a17)(b1 !-> b1)(c1 !-> c1)(a9 !-> a9);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump rot_
    jmp rot_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61901:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61901_Ap:
    ; switch a10 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61902:

Fun_Vec_Fun_Vec_List_Vec4_61902_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61905
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61903
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61903:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61904
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61904:
    jmp lab61906

lab61905:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61906:
    ; switch a11 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61907:

Fun_Vec_List_Vec4_61907_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61910
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61908
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61908:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61909
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61909:
    jmp lab61911

lab61910:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61911:
    ; jump side1_
    jmp side1_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61878:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61878_Ap:
    ; switch a4 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61912:

Fun_Vec_Fun_Vec_List_Vec4_61912_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61915
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61913
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61913:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61914
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61914:
    jmp lab61916

lab61915:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61916:
    ; switch a5 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61917:

Fun_Vec_List_Vec4_61917_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61920
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61918
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61918:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61919
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61919:
    jmp lab61921

lab61920:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61921:
    ; jump side1_
    jmp side1_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61877:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61877_Ap:
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61922:

Fun_Vec_Fun_Vec_List_Vec4_61922_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61925
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61923
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61923:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61924
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61924:
    jmp lab61926

lab61925:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61926:
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61927:

Fun_Vec_List_Vec4_61927_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61930
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61928
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61928:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61929
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61929:
    jmp lab61931

lab61930:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61931:
    ; jump corner1_
    jmp corner1_

pseudocorner_:
    ; new x0: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61932]
    ; new x1: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    lea r15, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61933]
    ; new x2: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61934]
    mov [rsp + 2024], rcx
    ; new x3: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2016], 0
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61935]
    mov [rsp + 2008], rcx
    ; substitute (x0 !-> x0)(x1 !-> x1)(x2 !-> x2)(x3 !-> x3)(arg !-> arg)(q6 !-> q6)(q7 !-> q7)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r14
    mov r14, rsi
    mov rsi, rcx
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], r8
    mov r8, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r9
    mov r9, rcx
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], r10
    mov r10, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r11
    mov r11, rcx
    ; jump quartet_
    jmp quartet_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61935:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61935_Ap:
    ; switch a13 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61936:

Fun_Vec_Fun_Vec_List_Vec4_61936_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61939
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61937
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61937:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61938
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61938:
    jmp lab61940

lab61939:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61940:
    ; switch a14 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61941:

Fun_Vec_List_Vec4_61941_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61944
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61942
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61942:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61943
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61943:
    jmp lab61945

lab61944:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61945:
    ; new x4: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61946]
    ; substitute (x4 !-> x4)(a22 !-> a22)(b3 !-> b3)(c3 !-> c3)(a15 !-> a15);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump rot_
    jmp rot_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61946:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61946_Ap:
    ; switch a16 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61947:

Fun_Vec_Fun_Vec_List_Vec4_61947_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61950
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61948
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61948:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61949
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61949:
    jmp lab61951

lab61950:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61951:
    ; switch a17 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61952:

Fun_Vec_List_Vec4_61952_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61955
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61953
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61953:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61954
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61954:
    jmp lab61956

lab61955:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61956:
    ; jump t_
    jmp t_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61934:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61934_Ap:
    ; switch a7 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61957:

Fun_Vec_Fun_Vec_List_Vec4_61957_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61960
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61958
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61958:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61959
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61959:
    jmp lab61961

lab61960:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61961:
    ; switch a8 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61962:

Fun_Vec_List_Vec4_61962_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61965
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61963
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61963:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61964
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61964:
    jmp lab61966

lab61965:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61966:
    ; new x5: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61967]
    ; substitute (x5 !-> x5)(a20 !-> a20)(b1 !-> b1)(c1 !-> c1)(a9 !-> a9);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump rot_
    jmp rot_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61967:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61967_Ap:
    ; switch a10 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61968:

Fun_Vec_Fun_Vec_List_Vec4_61968_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61971
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61969
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61969:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61970
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61970:
    jmp lab61972

lab61971:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61972:
    ; switch a11 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61973:

Fun_Vec_List_Vec4_61973_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61976
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61974
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61974:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61975
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61975:
    jmp lab61977

lab61976:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61977:
    ; jump side2_
    jmp side2_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61933:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61933_Ap:
    ; switch a4 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61978:

Fun_Vec_Fun_Vec_List_Vec4_61978_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61981
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61979
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61979:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61980
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61980:
    jmp lab61982

lab61981:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61982:
    ; switch a5 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61983:

Fun_Vec_List_Vec4_61983_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61986
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61984
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61984:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61985
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61985:
    jmp lab61987

lab61986:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61987:
    ; jump side2_
    jmp side2_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61932:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61932_Ap:
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61988:

Fun_Vec_Fun_Vec_List_Vec4_61988_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab61991
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab61989
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61989:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab61990
    ; ####increment refcount
    add qword [rsi + 0], 1

lab61990:
    jmp lab61992

lab61991:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab61992:
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_61993:

Fun_Vec_List_Vec4_61993_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab61996
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab61994
    ; ####increment refcount
    add qword [r10 + 0], 1

lab61994:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab61995
    ; ####increment refcount
    add qword [r8 + 0], 1

lab61995:
    jmp lab61997

lab61996:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab61997:
    ; jump corner2_
    jmp corner2_

pseudolimit_:
    ; new x0: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61998]
    ; substitute (x0 !-> x0)(arg !-> arg)(p2 !-> p2)(p3 !-> p3)(a0 !-> a0);
    ; #move variables
    mov rcx, r12
    mov r12, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump cycle__
    jmp cycle__

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61998:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_61998_Ap:
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_61999:

Fun_Vec_Fun_Vec_List_Vec4_61999_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab62002
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab62000
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62000:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab62001
    ; ####increment refcount
    add qword [rsi + 0], 1

lab62001:
    jmp lab62003

lab62002:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab62003:
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_62004:

Fun_Vec_List_Vec4_62004_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab62007
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab62005
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62005:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab62006
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62006:
    jmp lab62008

lab62007:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab62008:
    ; jump pseudocorner_
    jmp pseudocorner_

nonet_:
    ; switch a0 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_62009:

Fun_Vec_List_Vec4_62009_Ap:
    ; #load from memory
    mov rcx, [rsp + 1952]
    ; ##check refcount
    cmp qword [rcx + 0], 0
    je lab62012
    ; ##either decrement refcount and share children...
    add qword [rcx + 0], -1
    mov [rsp + 2040], rax
    mov rax, [rsp + 1952]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1928], rcx
    mov rcx, [rax + 48]
    mov [rsp + 1936], rcx
    cmp rcx, 0
    je lab62010
    ; ####increment refcount
    add qword [rcx + 0], 1

lab62010:
    mov rcx, [rax + 40]
    mov [rsp + 1944], rcx
    mov rcx, [rax + 32]
    mov [rsp + 1952], rcx
    cmp rcx, 0
    je lab62011
    ; ####increment refcount
    add qword [rcx + 0], 1

lab62011:
    mov rax, [rsp + 2040]
    jmp lab62013

lab62012:
    ; ##... or release blocks onto linear free list when loading
    mov [rsp + 2040], rax
    mov rax, [rsp + 1952]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1928], rcx
    mov rcx, [rax + 48]
    mov [rsp + 1936], rcx
    mov rcx, [rax + 40]
    mov [rsp + 1944], rcx
    mov rcx, [rax + 32]
    mov [rsp + 1952], rcx
    mov rax, [rsp + 2040]

lab62013:
    ; lit x0 <- 1;
    mov qword [rsp + 1912], 1
    ; lit x1 <- 2;
    mov qword [rsp + 1896], 2
    ; substitute (x1 !-> x1)(x0 !-> x0)(a4 !-> a4)(p4 !-> p4)(p5 !-> p5)(p6 !-> p6)(p7 !-> p7)(p8 !-> p8)(p9 !-> p9)(arg1 !-> arg1)(arg2 !-> arg2)(v !-> v)(p3 !-> p3)(p2 !-> p2)(p1 !-> p1);
    ; #move variables
    mov [rsp + 1904], rax
    mov rcx, [rsp + 1896]
    mov [rsp + 1896], rdx
    mov rdx, rcx
    mov [rsp + 1920], rsi
    mov rcx, [rsp + 1912]
    mov [rsp + 1912], rdi
    mov rdi, rcx
    mov rcx, [rsp + 1936]
    mov [rsp + 1936], r8
    mov r8, rcx
    mov rcx, [rsp + 1928]
    mov [rsp + 1928], r9
    mov r9, rcx
    ; new x2: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (p3, p2, p1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1896]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1904]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1912]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1920]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 1928]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 1936]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1936], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62025
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab62026

lab62025:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62023
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62016
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62014
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62015

lab62014:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62015:

lab62016:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62019
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62017
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62018

lab62017:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62018:

lab62019:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62022
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62020
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62021

lab62020:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62021:

lab62022:
    jmp lab62024

lab62023:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62024:

lab62026:
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62027]
    mov [rsp + 1928], rcx
    ; substitute (x1 !-> x1)(x0 !-> x0)(a4 !-> a4)(x2 !-> x2)(v !-> v)(arg2 !-> arg2)(arg1 !-> arg1)(p8 !-> p8)(p9 !-> p9)(p7 !-> p7)(p6 !-> p6)(p5 !-> p5)(p4 !-> p4);
    ; #move variables
    mov rcx, [rsp + 1936]
    mov [rsp + 1936], r10
    mov r10, rcx
    mov rcx, [rsp + 1928]
    mov [rsp + 1928], r11
    mov r11, rcx
    mov rcx, [rsp + 1952]
    mov [rsp + 1952], r12
    mov r12, rcx
    mov rcx, [rsp + 1944]
    mov [rsp + 1944], r13
    mov r13, rcx
    mov rcx, [rsp + 1968]
    mov [rsp + 1968], r14
    mov r14, rcx
    mov rcx, [rsp + 1960]
    mov [rsp + 1960], r15
    mov r15, rcx
    mov rcx, [rsp + 1984]
    mov [rsp + 2040], rcx
    mov rcx, [rsp + 2032]
    mov [rsp + 1984], rcx
    mov rcx, [rsp + 2040]
    mov [rsp + 2032], rcx
    mov rcx, [rsp + 1976]
    mov [rsp + 2040], rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 1976], rcx
    mov rcx, [rsp + 2040]
    mov [rsp + 2024], rcx
    ; new x3: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (p8, p9, p7, p6, p5, p4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1928]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1936]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1944]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1952]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 1960]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1968], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62039
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab62040

lab62039:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62037
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62030
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62028
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62029

lab62028:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62029:

lab62030:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62033
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62031
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62032

lab62031:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62032:

lab62033:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62036
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62034
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62035

lab62034:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62035:

lab62036:
    jmp lab62038

lab62037:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62038:

lab62040:
    ; ##store link to previous block
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 1992]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62052
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab62053

lab62052:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62050
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62043
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62041
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62042

lab62041:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62042:

lab62043:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62046
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62044
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62045

lab62044:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62045:

lab62046:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62049
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62047
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62048

lab62047:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62048:

lab62049:
    jmp lab62051

lab62050:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62051:

lab62053:
    ; ##store link to previous block
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62065
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab62066

lab62065:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62063
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62056
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62054
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62055

lab62054:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62055:

lab62056:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62059
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62057
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62058

lab62057:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62058:

lab62059:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62062
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62060
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62061

lab62060:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62061:

lab62062:
    jmp lab62064

lab62063:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62064:

lab62066:
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62067]
    mov [rsp + 2008], rcx
    ; substitute (x0 !-> x0)(x1 !-> x1)(x2 !-> x2)(x3 !-> x3)(arg1 !-> arg1)(arg2 !-> arg2)(v !-> v)(a4 !-> a4);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, [rsp + 2016]
    mov [rsp + 2016], r8
    mov r8, rcx
    mov rcx, r11
    mov r11, [rsp + 2008]
    mov [rsp + 2008], r9
    mov r9, rcx
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], r12
    mov r12, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r13
    mov r13, rcx
    ; jump above_
    jmp above_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62067:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62067_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab62074
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab62068
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62068:
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab62069
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62069:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab62070
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62070:
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab62071
    ; ####increment refcount
    add qword [rcx + 0], 1

lab62071:
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab62072
    ; ####increment refcount
    add qword [rcx + 0], 1

lab62072:
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]
    cmp r14, 0
    je lab62073
    ; ####increment refcount
    add qword [r14 + 0], 1

lab62073:
    jmp lab62075

lab62074:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]

lab62075:
    ; substitute (a1 !-> a1)(p4 !-> p4)(p8 !-> p8)(p9 !-> p9)(p7 !-> p7)(p6 !-> p6)(p5 !-> p5)(a11 !-> a11);
    ; #move variables
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], rsi
    mov rsi, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], rdi
    mov rdi, rcx
    ; switch a11 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_62076:

Fun_Vec_Fun_Vec_List_Vec4_62076_Ap:
    ; #load from memory
    mov rcx, [rsp + 2016]
    ; ##check refcount
    cmp qword [rcx + 0], 0
    je lab62079
    ; ##either decrement refcount and share children...
    add qword [rcx + 0], -1
    mov [rsp + 2040], rax
    mov rax, [rsp + 2016]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1992], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2000], rcx
    cmp rcx, 0
    je lab62077
    ; ####increment refcount
    add qword [rcx + 0], 1

lab62077:
    mov rcx, [rax + 40]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 32]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab62078
    ; ####increment refcount
    add qword [rcx + 0], 1

lab62078:
    mov rax, [rsp + 2040]
    jmp lab62080

lab62079:
    ; ##... or release blocks onto linear free list when loading
    mov [rsp + 2040], rax
    mov rax, [rsp + 2016]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1992], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2000], rcx
    mov rcx, [rax + 40]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 32]
    mov [rsp + 2016], rcx
    mov rax, [rsp + 2040]

lab62080:
    ; switch a12 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_62081:

Fun_Vec_List_Vec4_62081_Ap:
    ; #load from memory
    mov rcx, [rsp + 2000]
    ; ##check refcount
    cmp qword [rcx + 0], 0
    je lab62084
    ; ##either decrement refcount and share children...
    add qword [rcx + 0], -1
    mov [rsp + 2040], rax
    mov rax, [rsp + 2000]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1976], rcx
    mov rcx, [rax + 48]
    mov [rsp + 1984], rcx
    cmp rcx, 0
    je lab62082
    ; ####increment refcount
    add qword [rcx + 0], 1

lab62082:
    mov rcx, [rax + 40]
    mov [rsp + 1992], rcx
    mov rcx, [rax + 32]
    mov [rsp + 2000], rcx
    cmp rcx, 0
    je lab62083
    ; ####increment refcount
    add qword [rcx + 0], 1

lab62083:
    mov rax, [rsp + 2040]
    jmp lab62085

lab62084:
    ; ##... or release blocks onto linear free list when loading
    mov [rsp + 2040], rax
    mov rax, [rsp + 2000]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 1976], rcx
    mov rcx, [rax + 48]
    mov [rsp + 1984], rcx
    mov rcx, [rax + 40]
    mov [rsp + 1992], rcx
    mov rcx, [rax + 32]
    mov [rsp + 2000], rcx
    mov rax, [rsp + 2040]

lab62085:
    ; lit x4 <- 1;
    mov qword [rsp + 1960], 1
    ; lit x5 <- 1;
    mov qword [rsp + 1944], 1
    ; substitute (a1 !-> a1)(x5 !-> x5)(p8 !-> p8)(p9 !-> p9)(p7 !-> p7)(x4 !-> x4)(a13 !-> a13)(a2 !-> a2)(a3 !-> a3)(p5 !-> p5)(p6 !-> p6)(p4 !-> p4);
    ; #move variables
    mov [rsp + 1952], rsi
    mov rcx, [rsp + 1944]
    mov [rsp + 1944], rdi
    mov rdi, rcx
    mov [rsp + 1968], r14
    mov rcx, [rsp + 1960]
    mov [rsp + 1960], r15
    mov r15, rcx
    mov rcx, [rsp + 1984]
    mov [rsp + 2040], rcx
    mov rcx, [rsp + 2032]
    mov [rsp + 1984], rcx
    mov rcx, [rsp + 2040]
    mov [rsp + 2032], rcx
    mov rcx, [rsp + 1976]
    mov [rsp + 2040], rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 1976], rcx
    mov rcx, [rsp + 2040]
    mov [rsp + 2024], rcx
    ; new x6: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (p5, p6, p4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1944]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1952]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1960]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 1976]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 1984], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62097
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab62098

lab62097:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62095
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62088
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62086
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62087

lab62086:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62087:

lab62088:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62091
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62089
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62090

lab62089:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62090:

lab62091:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62094
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62092
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62093

lab62092:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62093:

lab62094:
    jmp lab62096

lab62095:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62096:

lab62098:
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62099]
    mov [rsp + 1976], rcx
    ; substitute (a1 !-> a1)(x5 !-> x5)(x6 !-> x6)(a3 !-> a3)(a2 !-> a2)(x4 !-> x4)(a13 !-> a13)(p7 !-> p7)(p9 !-> p9)(p8 !-> p8);
    ; #move variables
    mov rcx, [rsp + 1984]
    mov [rsp + 1984], r8
    mov r8, rcx
    mov rcx, [rsp + 1976]
    mov [rsp + 1976], r9
    mov r9, rcx
    mov rcx, [rsp + 2000]
    mov [rsp + 2000], r10
    mov r10, rcx
    mov rcx, [rsp + 1992]
    mov [rsp + 1992], r11
    mov r11, rcx
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], r12
    mov r12, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r13
    mov r13, rcx
    ; new x7: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (p7, p9, p8)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1976]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1992]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62111
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab62112

lab62111:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62109
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62102
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62100
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62101

lab62100:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62101:

lab62102:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62105
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62103
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62104

lab62103:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62104:

lab62105:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62108
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62106
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62107

lab62106:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62107:

lab62108:
    jmp lab62110

lab62109:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62110:

lab62112:
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62113]
    mov [rsp + 2008], rcx
    ; substitute (x4 !-> x4)(x5 !-> x5)(x6 !-> x6)(x7 !-> x7)(a1 !-> a1)(a2 !-> a2)(a3 !-> a3)(a13 !-> a13);
    ; #move variables
    mov r14, r12
    mov r12, rax
    mov rcx, r15
    mov r15, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, [rsp + 2016]
    mov [rsp + 2040], rcx
    mov rcx, [rsp + 2032]
    mov [rsp + 2016], rcx
    mov [rsp + 2032], r10
    mov r10, [rsp + 2040]
    mov rcx, [rsp + 2008]
    mov [rsp + 2040], rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2008], rcx
    mov [rsp + 2024], r11
    mov r11, [rsp + 2040]
    ; jump above_
    jmp above_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62113:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62113_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab62117
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab62114
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62114:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab62115
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62115:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab62116
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62116:
    jmp lab62118

lab62117:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab62118:
    ; substitute (b53 !-> b53)(p8 !-> p8)(p7 !-> p7)(p9 !-> p9)(a20 !-> a20);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    ; switch a20 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_62119:

Fun_Vec_Fun_Vec_List_Vec4_62119_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab62122
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab62120
    ; ####increment refcount
    add qword [r14 + 0], 1

lab62120:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab62121
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62121:
    jmp lab62123

lab62122:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab62123:
    ; switch a21 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_62124:

Fun_Vec_List_Vec4_62124_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r14 + 0], 0
    je lab62127
    ; ##either decrement refcount and share children...
    add qword [r14 + 0], -1
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab62125
    ; ####increment refcount
    add qword [rcx + 0], 1

lab62125:
    mov r15, [r14 + 40]
    mov r14, [r14 + 32]
    cmp r14, 0
    je lab62126
    ; ####increment refcount
    add qword [r14 + 0], 1

lab62126:
    jmp lab62128

lab62127:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r14 + 40]
    mov r14, [r14 + 32]

lab62128:
    ; lit x8 <- 1;
    mov qword [rsp + 2008], 1
    ; lit x9 <- 2;
    mov qword [rsp + 1992], 2
    ; substitute (b53 !-> b53)(x9 !-> x9)(p7 !-> p7)(x8 !-> x8)(b63 !-> b63)(b73 !-> b73)(a22 !-> a22)(p9 !-> p9)(p8 !-> p8);
    ; #move variables
    mov [rsp + 2000], rsi
    mov rcx, [rsp + 1992]
    mov [rsp + 1992], rdi
    mov rdi, rcx
    mov [rsp + 2016], r10
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r11
    mov r11, rcx
    ; new x10: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (p9, p8)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62140
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab62141

lab62140:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62138
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62131
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62129
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62130

lab62129:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62130:

lab62131:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62134
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62132
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62133

lab62132:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62133:

lab62134:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62137
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62135
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62136

lab62135:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62136:

lab62137:
    jmp lab62139

lab62138:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62139:

lab62141:
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62142]
    mov [rsp + 2008], rcx
    ; substitute (x8 !-> x8)(x9 !-> x9)(p7 !-> p7)(x10 !-> x10)(b53 !-> b53)(b63 !-> b63)(b73 !-> b73)(a22 !-> a22);
    ; #move variables
    mov r10, [rsp + 2016]
    mov rcx, [rsp + 2032]
    mov [rsp + 2016], rcx
    mov [rsp + 2032], r14
    mov r14, r12
    mov r12, rax
    mov [rsp + 2040], r11
    mov r11, [rsp + 2008]
    mov rcx, [rsp + 2024]
    mov [rsp + 2008], rcx
    mov [rsp + 2024], r15
    mov r15, r13
    mov r13, rdx
    mov rdx, [rsp + 2040]
    ; jump beside_
    jmp beside_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62142:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62142_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab62145
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab62143
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62143:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab62144
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62144:
    jmp lab62146

lab62145:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab62146:
    ; substitute (b54 !-> b54)(p8 !-> p8)(p9 !-> p9)(a23 !-> a23);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch a23 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_62147:

Fun_Vec_Fun_Vec_List_Vec4_62147_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab62150
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab62148
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62148:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab62149
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62149:
    jmp lab62151

lab62150:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab62151:
    ; switch a24 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_62152:

Fun_Vec_List_Vec4_62152_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab62155
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab62153
    ; ####increment refcount
    add qword [r14 + 0], 1

lab62153:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab62154
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62154:
    jmp lab62156

lab62155:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab62156:
    ; lit x11 <- 1;
    mov qword [rsp + 2024], 1
    ; lit x12 <- 1;
    mov qword [rsp + 2008], 1
    ; substitute (x11 !-> x11)(x12 !-> x12)(p8 !-> p8)(p9 !-> p9)(b54 !-> b54)(b64 !-> b64)(b74 !-> b74)(a25 !-> a25);
    ; #move variables
    mov [rsp + 2032], r12
    mov r12, rax
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r13
    mov r13, rdx
    mov rdx, rcx
    mov [rsp + 2016], r14
    mov r14, r10
    mov r10, r8
    mov r8, rsi
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r15
    mov r15, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump beside_
    jmp beside_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62099:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62099_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab62160
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab62157
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62157:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab62158
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62158:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab62159
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62159:
    jmp lab62161

lab62160:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab62161:
    ; substitute (b51 !-> b51)(p4 !-> p4)(p5 !-> p5)(p6 !-> p6)(a14 !-> a14);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    ; switch a14 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_62162:

Fun_Vec_Fun_Vec_List_Vec4_62162_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab62165
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab62163
    ; ####increment refcount
    add qword [r14 + 0], 1

lab62163:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab62164
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62164:
    jmp lab62166

lab62165:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab62166:
    ; switch a15 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_62167:

Fun_Vec_List_Vec4_62167_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r14 + 0], 0
    je lab62170
    ; ##either decrement refcount and share children...
    add qword [r14 + 0], -1
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab62168
    ; ####increment refcount
    add qword [rcx + 0], 1

lab62168:
    mov r15, [r14 + 40]
    mov r14, [r14 + 32]
    cmp r14, 0
    je lab62169
    ; ####increment refcount
    add qword [r14 + 0], 1

lab62169:
    jmp lab62171

lab62170:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r14 + 40]
    mov r14, [r14 + 32]

lab62171:
    ; lit x13 <- 1;
    mov qword [rsp + 2008], 1
    ; lit x14 <- 2;
    mov qword [rsp + 1992], 2
    ; substitute (b51 !-> b51)(p4 !-> p4)(x14 !-> x14)(x13 !-> x13)(b61 !-> b61)(b71 !-> b71)(a16 !-> a16)(p6 !-> p6)(p5 !-> p5);
    ; #move variables
    mov [rsp + 2000], r8
    mov rcx, [rsp + 1992]
    mov [rsp + 1992], r9
    mov r9, rcx
    mov [rsp + 2016], r10
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r11
    mov r11, rcx
    ; new x15: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (p6, p5)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62183
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab62184

lab62183:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62181
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62174
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62172
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62173

lab62172:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62173:

lab62174:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62177
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62175
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62176

lab62175:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62176:

lab62177:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62180
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62178
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62179

lab62178:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62179:

lab62180:
    jmp lab62182

lab62181:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62182:

lab62184:
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62185]
    mov [rsp + 2008], rcx
    ; substitute (x13 !-> x13)(x14 !-> x14)(p4 !-> p4)(x15 !-> x15)(b51 !-> b51)(b61 !-> b61)(b71 !-> b71)(a16 !-> a16);
    ; #move variables
    mov r10, [rsp + 2016]
    mov rcx, [rsp + 2032]
    mov [rsp + 2016], rcx
    mov [rsp + 2032], r14
    mov r14, r12
    mov r12, rax
    mov [rsp + 2040], r11
    mov r11, [rsp + 2008]
    mov rcx, [rsp + 2024]
    mov [rsp + 2008], rcx
    mov [rsp + 2024], r15
    mov r15, r13
    mov r13, rdx
    mov rdx, [rsp + 2040]
    mov r8, rsi
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump beside_
    jmp beside_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62185:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62185_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab62188
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab62186
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62186:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab62187
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62187:
    jmp lab62189

lab62188:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab62189:
    ; substitute (b52 !-> b52)(p5 !-> p5)(p6 !-> p6)(a17 !-> a17);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch a17 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_62190:

Fun_Vec_Fun_Vec_List_Vec4_62190_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab62193
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab62191
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62191:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab62192
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62192:
    jmp lab62194

lab62193:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab62194:
    ; switch a18 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_62195:

Fun_Vec_List_Vec4_62195_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab62198
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab62196
    ; ####increment refcount
    add qword [r14 + 0], 1

lab62196:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab62197
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62197:
    jmp lab62199

lab62198:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab62199:
    ; lit x16 <- 1;
    mov qword [rsp + 2024], 1
    ; lit x17 <- 1;
    mov qword [rsp + 2008], 1
    ; substitute (x16 !-> x16)(x17 !-> x17)(p5 !-> p5)(p6 !-> p6)(b52 !-> b52)(b62 !-> b62)(b72 !-> b72)(a19 !-> a19);
    ; #move variables
    mov [rsp + 2032], r12
    mov r12, rax
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r13
    mov r13, rdx
    mov rdx, rcx
    mov [rsp + 2016], r14
    mov r14, r10
    mov r10, r8
    mov r8, rsi
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r15
    mov r15, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump beside_
    jmp beside_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62027:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62027_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab62203
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab62200
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62200:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab62201
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62201:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab62202
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62202:
    jmp lab62204

lab62203:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab62204:
    ; substitute (b5 !-> b5)(p1 !-> p1)(p3 !-> p3)(p2 !-> p2)(a5 !-> a5);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    ; switch a5 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_62205:

Fun_Vec_Fun_Vec_List_Vec4_62205_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab62208
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab62206
    ; ####increment refcount
    add qword [r14 + 0], 1

lab62206:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab62207
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62207:
    jmp lab62209

lab62208:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab62209:
    ; switch a6 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_62210:

Fun_Vec_List_Vec4_62210_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r14 + 0], 0
    je lab62213
    ; ##either decrement refcount and share children...
    add qword [r14 + 0], -1
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab62211
    ; ####increment refcount
    add qword [rcx + 0], 1

lab62211:
    mov r15, [r14 + 40]
    mov r14, [r14 + 32]
    cmp r14, 0
    je lab62212
    ; ####increment refcount
    add qword [r14 + 0], 1

lab62212:
    jmp lab62214

lab62213:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r14 + 40]
    mov r14, [r14 + 32]

lab62214:
    ; lit x18 <- 1;
    mov qword [rsp + 2008], 1
    ; lit x19 <- 2;
    mov qword [rsp + 1992], 2
    ; substitute (b5 !-> b5)(p1 !-> p1)(x19 !-> x19)(x18 !-> x18)(b6 !-> b6)(b7 !-> b7)(a7 !-> a7)(p2 !-> p2)(p3 !-> p3);
    ; #move variables
    mov [rsp + 2000], r8
    mov rcx, [rsp + 1992]
    mov [rsp + 1992], r9
    mov r9, rcx
    mov [rsp + 2016], r10
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r11
    mov r11, rcx
    ; new x20: Fun[Vec, Fun[Vec, Fun[Vec, List[Vec4]]]] = (p2, p3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62226
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab62227

lab62226:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62224
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62217
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62215
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62216

lab62215:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62216:

lab62217:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62220
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62218
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62219

lab62218:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62219:

lab62220:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62223
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62221
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62222

lab62221:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62222:

lab62223:
    jmp lab62225

lab62224:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62225:

lab62227:
    ; #load tag
    lea rcx, [rel Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62228]
    mov [rsp + 2008], rcx
    ; substitute (x18 !-> x18)(x19 !-> x19)(p1 !-> p1)(x20 !-> x20)(b5 !-> b5)(b6 !-> b6)(b7 !-> b7)(a7 !-> a7);
    ; #move variables
    mov r10, [rsp + 2016]
    mov rcx, [rsp + 2032]
    mov [rsp + 2016], rcx
    mov [rsp + 2032], r14
    mov r14, r12
    mov r12, rax
    mov [rsp + 2040], r11
    mov r11, [rsp + 2008]
    mov rcx, [rsp + 2024]
    mov [rsp + 2008], rcx
    mov [rsp + 2024], r15
    mov r15, r13
    mov r13, rdx
    mov rdx, [rsp + 2040]
    mov r8, rsi
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump beside_
    jmp beside_

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62228:

Fun_Vec_Fun_Vec_Fun_Vec_List_Vec4_62228_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab62231
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab62229
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62229:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab62230
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62230:
    jmp lab62232

lab62231:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab62232:
    ; substitute (b50 !-> b50)(p3 !-> p3)(p2 !-> p2)(a8 !-> a8);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch a8 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_Fun_Vec_List_Vec4_62233:

Fun_Vec_Fun_Vec_List_Vec4_62233_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab62236
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab62234
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62234:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab62235
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62235:
    jmp lab62237

lab62236:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab62237:
    ; switch a9 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Vec_List_Vec4_62238:

Fun_Vec_List_Vec4_62238_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab62241
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab62239
    ; ####increment refcount
    add qword [r14 + 0], 1

lab62239:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab62240
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62240:
    jmp lab62242

lab62241:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab62242:
    ; lit x21 <- 1;
    mov qword [rsp + 2024], 1
    ; lit x22 <- 1;
    mov qword [rsp + 2008], 1
    ; substitute (x21 !-> x21)(x22 !-> x22)(p2 !-> p2)(p3 !-> p3)(b50 !-> b50)(b60 !-> b60)(b70 !-> b70)(a10 !-> a10);
    ; #move variables
    mov [rsp + 2032], r12
    mov r12, rax
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r13
    mov r13, rdx
    mov rdx, rcx
    mov [rsp + 2016], r14
    mov r14, r10
    mov r10, rsi
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], r15
    mov r15, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump beside_
    jmp beside_

enum_from_to_:
    ; if from <= t \{ ... \}
    cmp rdx, rdi
    jle lab62243
    ; substitute (a0 !-> a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

lab62243:
    ; substitute (from0 !-> from)(t !-> t)(a0 !-> a0)(from !-> from);
    ; #move variables
    mov r11, rdx
    ; new a1: List[i64] = (a0, from)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62255
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab62256

lab62255:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62253
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62246
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62244
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62245

lab62244:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62245:

lab62246:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62249
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62247
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62248

lab62247:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62248:

lab62249:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62252
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62250
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62251

lab62250:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62251:

lab62252:
    jmp lab62254

lab62253:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62254:

lab62256:
    ; #load tag
    lea r9, [rel List_i64_62257]
    ; lit x1 <- 1;
    mov r11, 1
    ; x2 <- from0 + x1;
    mov r13, rdx
    add r13, r11
    ; substitute (x2 !-> x2)(t !-> t)(a1 !-> a1);
    ; #move variables
    mov rdx, r13
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_62257:
    jmp near List_i64_62257_Nil
    jmp near List_i64_62257_Cons

List_i64_62257_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab62259
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab62258
    ; ####increment refcount
    add qword [rax + 0], 1

lab62258:
    jmp lab62260

lab62259:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab62260:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (from !-> from)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_62257_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab62262
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab62261
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62261:
    jmp lab62263

lab62262:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab62263:
    ; substitute (from !-> from)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov r10, rsi
    mov rsi, r8
    ; let x0: List[i64] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62275
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab62276

lab62275:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62273
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62266
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62264
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62265

lab62264:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62265:

lab62266:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62269
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62267
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62268

lab62267:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62268:

lab62269:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62272
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62270
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62271

lab62270:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62271:

lab62272:
    jmp lab62274

lab62273:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62274:

lab62276:
    ; #load tag
    mov r9, 5
    ; substitute (from !-> from)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

min_:
    ; if i1 < i2 \{ ... \}
    cmp rdx, rdi
    jl lab62277
    ; substitute (i2 !-> i2)(a0 !-> a0);
    ; #move variables
    mov rdx, rdi
    mov rsi, r8
    mov rdi, r9
    ; invoke a0 Ret
    jmp rdi

lab62277:
    ; substitute (i1 !-> i1)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; invoke a0 Ret
    jmp rdi

map_:
    ; substitute (f !-> f)(a0 !-> a0)(l !-> l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_i64_62278]
    add rcx, r9
    jmp rcx

List_i64_62278:
    jmp near List_i64_62278_Nil
    jmp near List_i64_62278_Cons

List_i64_62278_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab62281
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab62279
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab62280

lab62279:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab62280:

lab62281:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_62278_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab62283
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab62282
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62282:
    mov r9, [r8 + 40]
    jmp lab62284

lab62283:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab62284:
    ; substitute (f0 !-> f)(i !-> i)(a0 !-> a0)(is !-> is)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab62285
    ; ####increment refcount
    add qword [rax + 0], 1

lab62285:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r8, rsi
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: List[Vec4] = (a0, is, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62297
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab62298

lab62297:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62295
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62288
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62286
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62287

lab62286:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62287:

lab62288:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62291
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62289
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62290

lab62289:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62290:

lab62291:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62294
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62292
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62293

lab62292:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62293:

lab62294:
    jmp lab62296

lab62295:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62296:

lab62298:
    ; #load tag
    lea r9, [rel List_Vec4_62299]
    ; substitute (i !-> i)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

List_Vec4_62299:
    jmp near List_Vec4_62299_Nil
    jmp near List_Vec4_62299_Cons

List_Vec4_62299_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab62303
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab62300
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62300:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab62301
    ; ####increment refcount
    add qword [rsi + 0], 1

lab62301:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab62302
    ; ####increment refcount
    add qword [rax + 0], 1

lab62302:
    jmp lab62304

lab62303:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab62304:
    ; let x0: List[Vec4] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 !-> a0)(f !-> f)(is !-> is)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_map_0_
    jmp lift_map_0_

List_Vec4_62299_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab62308
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab62305
    ; ####increment refcount
    add qword [r12 + 0], 1

lab62305:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab62306
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62306:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab62307
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62307:
    jmp lab62309

lab62308:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab62309:
    ; substitute (f !-> f)(is !-> is)(a0 !-> a0)(a4 !-> a4)(as1 !-> as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Vec4] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62321
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab62322

lab62321:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62319
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62312
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62310
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62311

lab62310:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62311:

lab62312:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62315
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62313
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62314

lab62313:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62314:

lab62315:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62318
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62316
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62317

lab62316:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62317:

lab62318:
    jmp lab62320

lab62319:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62320:

lab62322:
    ; #load tag
    mov r11, 5
    ; substitute (a0 !-> a0)(f !-> f)(is !-> is)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_map_0_
    jmp lift_map_0_

lift_map_0_:
    ; substitute (is !-> is)(f !-> f)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a2: List[List[Vec4]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62334
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab62335

lab62334:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62332
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62325
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62323
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62324

lab62323:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62324:

lab62325:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62328
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62326
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62327

lab62326:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62327:

lab62328:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62331
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62329
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62330

lab62329:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62330:

lab62331:
    jmp lab62333

lab62332:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62333:

lab62335:
    ; #load tag
    lea r9, [rel List_List_Vec4_62336]
    ; substitute (f !-> f)(is !-> is)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump map_
    jmp map_

List_List_Vec4_62336:
    jmp near List_List_Vec4_62336_Nil
    jmp near List_List_Vec4_62336_Cons

List_List_Vec4_62336_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab62339
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab62337
    ; ####increment refcount
    add qword [rsi + 0], 1

lab62337:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab62338
    ; ####increment refcount
    add qword [rax + 0], 1

lab62338:
    jmp lab62340

lab62339:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab62340:
    ; let x1: List[List[Vec4]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Vec4_62336_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab62343
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab62341
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62341:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab62342
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62342:
    jmp lab62344

lab62343:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab62344:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[Vec4]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62356
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab62357

lab62356:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62354
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62347
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62345
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62346

lab62345:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62346:

lab62347:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62350
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62348
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62349

lab62348:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62349:

lab62350:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62353
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62351
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62352

lab62351:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62352:

lab62353:
    jmp lab62355

lab62354:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62355:

lab62357:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

test_fish_nofib_:
    ; new x0: Fun[i64, List[Vec4]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_i64_List_Vec4_62358]
    ; new a4: List[i64] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62370
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab62371

lab62370:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62368
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62361
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62359
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62360

lab62359:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62360:

lab62361:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62364
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62362
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62363

lab62362:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62363:

lab62364:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62367
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62365
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62366

lab62365:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62366:

lab62367:
    jmp lab62369

lab62368:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62369:

lab62371:
    ; #load tag
    lea rdi, [rel List_i64_62372]
    ; lit x2 <- 0;
    mov r9, 0
    ; substitute (x2 !-> x2)(n !-> n)(a4 !-> a4);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_62372:
    jmp near List_i64_62372_Nil
    jmp near List_i64_62372_Cons

List_i64_62372_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab62375
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab62373
    ; ####increment refcount
    add qword [rsi + 0], 1

lab62373:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab62374
    ; ####increment refcount
    add qword [rax + 0], 1

lab62374:
    jmp lab62376

lab62375:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab62376:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump map_
    jmp map_

List_i64_62372_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab62379
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab62377
    ; ####increment refcount
    add qword [r10 + 0], 1

lab62377:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab62378
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62378:
    jmp lab62380

lab62379:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab62380:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a6 !-> a6)(as0 !-> as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x1: List[i64] = Cons(a6, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62392
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab62393

lab62392:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62390
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62383
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62381
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62382

lab62381:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62382:

lab62383:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62386
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62384
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62385

lab62384:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62385:

lab62386:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62389
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62387
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62388

lab62387:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62388:

lab62389:
    jmp lab62391

lab62390:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62391:

lab62393:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump map_
    jmp map_

Fun_i64_List_Vec4_62358:

Fun_i64_List_Vec4_62358_Ap:
    ; lit x3 <- 0;
    mov r9, 0
    ; substitute (i !-> i)(x3 !-> x3)(a1 !-> a1);
    ; #move variables
    mov r8, rsi
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a5: _Cont = (a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62405
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab62406

lab62405:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62403
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62396
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62394
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62395

lab62394:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62395:

lab62396:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62399
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62397
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62398

lab62397:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62398:

lab62399:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62402
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62400
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62401

lab62400:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62401:

lab62402:
    jmp lab62404

lab62403:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62404:

lab62406:
    ; #load tag
    lea r9, [rel _Cont_62407]
    ; substitute (x3 !-> x3)(i !-> i)(a5 !-> a5);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump min_
    jmp min_

_Cont_62407:

_Cont_62407_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab62409
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab62408
    ; ####increment refcount
    add qword [rsi + 0], 1

lab62408:
    jmp lab62410

lab62409:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab62410:
    ; lit x5 <- 0;
    mov r9, 0
    ; lit x6 <- 0;
    mov r11, 0
    ; let x4: Vec = Vec(x5, x6);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62422
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab62423

lab62422:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62420
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62413
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62411
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62412

lab62411:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62412:

lab62413:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62416
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62414
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62415

lab62414:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62415:

lab62416:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62419
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62417
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62418

lab62417:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62418:

lab62419:
    jmp lab62421

lab62420:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62421:

lab62423:
    ; #load tag
    mov r9, 0
    ; lit x8 <- 640;
    mov r11, 640
    ; x9 <- x8 + n0;
    mov r13, r11
    add r13, rdx
    ; substitute (n0 !-> n0)(a1 !-> a1)(x4 !-> x4)(x9 !-> x9);
    ; #move variables
    mov r11, r13
    ; lit x10 <- 0;
    mov r13, 0
    ; let x7: Vec = Vec(x9, x10);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62435
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab62436

lab62435:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62433
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62426
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62424
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62425

lab62424:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62425:

lab62426:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62429
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62427
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62428

lab62427:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62428:

lab62429:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62432
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62430
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62431

lab62430:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62431:

lab62432:
    jmp lab62434

lab62433:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62434:

lab62436:
    ; #load tag
    mov r11, 0
    ; lit x12 <- 0;
    mov r13, 0
    ; lit x13 <- 640;
    mov r15, 640
    ; x14 <- x13 + n0;
    mov rcx, r15
    add rcx, rdx
    mov [rsp + 2024], rcx
    ; substitute (x7 !-> x7)(a1 !-> a1)(x4 !-> x4)(x12 !-> x12)(x14 !-> x14);
    ; #move variables
    mov rax, r10
    mov rdx, r11
    mov r11, r13
    mov r13, [rsp + 2024]
    ; let x11: Vec = Vec(x12, x14);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62448
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab62449

lab62448:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62446
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62439
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62437
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62438

lab62437:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62438:

lab62439:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62442
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62440
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62441

lab62440:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62441:

lab62442:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62445
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62443
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62444

lab62443:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62444:

lab62445:
    jmp lab62447

lab62446:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62447:

lab62449:
    ; #load tag
    mov r11, 0
    ; substitute (x4 !-> x4)(x7 !-> x7)(x11 !-> x11)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump pseudolimit_
    jmp pseudolimit_

length_:
    ; substitute (a0 !-> a0)(l !-> l);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_List_Vec4_62450]
    add rcx, rdi
    jmp rcx

List_List_Vec4_62450:
    jmp near List_List_Vec4_62450_Nil
    jmp near List_List_Vec4_62450_Cons

List_List_Vec4_62450_Nil:
    ; lit x2 <- 0;
    mov rdi, 0
    ; substitute (x2 !-> x2)(a0 !-> a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    jmp rdi

List_List_Vec4_62450_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab62453
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab62451
    ; ####increment refcount
    add qword [r8 + 0], 1

lab62451:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab62452
    ; ####increment refcount
    add qword [rsi + 0], 1

lab62452:
    jmp lab62454

lab62453:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab62454:
    ; substitute (a0 !-> a0)(xs !-> xs);
    ; #erase x
    cmp rsi, 0
    je lab62457
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab62455
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab62456

lab62455:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab62456:

lab62457:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; lit x0 <- 1;
    mov r9, 1
    ; substitute (xs !-> xs)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; new a1: _Cont = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov qword [rbx + 48], 0
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab62469
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab62470

lab62469:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab62467
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab62460
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62458
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62459

lab62458:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62459:

lab62460:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab62463
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62461
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62462

lab62461:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62462:

lab62463:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab62466
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab62464
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab62465

lab62464:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab62465:

lab62466:
    jmp lab62468

lab62467:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab62468:

lab62470:
    ; #load tag
    lea rdi, [rel _Cont_62471]
    ; jump length_
    jmp length_

_Cont_62471:

_Cont_62471_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab62473
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab62472
    ; ####increment refcount
    add qword [rsi + 0], 1

lab62472:
    jmp lab62474

lab62473:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab62474:
    ; x3 <- x0 + x1;
    mov r11, r9
    add r11, rdx
    ; substitute (x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov rdx, r11
    ; invoke a0 Ret
    jmp rdi
    ; cleanup

cleanup:
    ; free space for register spills
    add rsp, 2048
    ; restore registers
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbp
    pop rbx
    ret