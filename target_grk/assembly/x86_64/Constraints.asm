    ; asmsyntax=nasm
section .note.GNU-stack noalloc noexec nowrite progbits
section .text
extern print_i64
extern println_i64
global asm_main

asm_main:
    ; setup
    ; save registers
    push rbx
    push rbp
    push r12
    push r13
    push r14
    push r15
    ; reserve space for register spills
    sub rsp, 2048
    ; initialize heap pointer
    mov rbx, rdi
    ; initialize free pointer
    mov rbp, rbx
    add rbp, 64
    ; move parameters into place
    mov rdi, rdx
    ; move parameters into place
    mov rdx, rsi
    ; actual code

main_:
    ; new a0: _Cont = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel _Cont_65889]
    ; jump main_loop_
    jmp main_loop_

_Cont_65889:

_Cont_65889_Ret:
    ; return x0
    mov rax, rdx
    jmp cleanup

abs_i_:
    ; lit x0 <- 0;
    mov r9, 0
    ; if i < x0 \{ ... \}
    cmp rdx, r9
    jl lab65890
    ; substitute (i !-> i)(a0 !-> a0);
    ; invoke a0 Ret
    jmp rdi

lab65890:
    ; substitute (i !-> i)(a0 !-> a0);
    ; lit x1 <- -1;
    mov r9, -1
    ; x2 <- x1 * i;
    mov r11, r9
    imul r11, rdx
    ; substitute (x2 !-> x2)(a0 !-> a0);
    ; #move variables
    mov rdx, r11
    ; invoke a0 Ret
    jmp rdi

eq_:
    ; if i1 == i2 \{ ... \}
    cmp rdx, rdi
    je lab65891
    ; substitute (a0 !-> a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; invoke a0 False
    add rdx, 5
    jmp rdx

lab65891:
    ; substitute (a0 !-> a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; invoke a0 True
    add rdx, 0
    jmp rdx

and_:
    ; substitute (a0 !-> a0)(b2 !-> b2)(b1 !-> b1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch b1 \{ ... \};
    lea rcx, [rel Bool_65892]
    add rcx, r9
    jmp rcx

Bool_65892:
    jmp near Bool_65892_True
    jmp near Bool_65892_False

Bool_65892_True:
    ; switch b2 \{ ... \};
    lea rcx, [rel Bool_65893]
    add rcx, rdi
    jmp rcx

Bool_65893:
    jmp near Bool_65893_True
    jmp near Bool_65893_False

Bool_65893_True:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

Bool_65893_False:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

Bool_65892_False:
    ; substitute (a0 !-> a0);
    ; #erase b2
    cmp rsi, 0
    je lab65896
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab65894
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab65895

lab65894:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab65895:

lab65896:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

not_:
    ; substitute (a0 !-> a0)(b !-> b);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch b \{ ... \};
    lea rcx, [rel Bool_65897]
    add rcx, rdi
    jmp rcx

Bool_65897:
    jmp near Bool_65897_True
    jmp near Bool_65897_False

Bool_65897_True:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

Bool_65897_False:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

reverse_loop_:
    ; substitute (a0 !-> a0)(acc !-> acc)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_65898]
    add rcx, r9
    jmp rcx

List_Assign_65898:
    jmp near List_Assign_65898_Nil
    jmp near List_Assign_65898_Cons

List_Assign_65898_Nil:
    ; switch acc \{ ... \};
    lea rcx, [rel List_Assign_65899]
    add rcx, rdi
    jmp rcx

List_Assign_65899:
    jmp near List_Assign_65899_Nil
    jmp near List_Assign_65899_Cons

List_Assign_65899_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Assign_65899_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab65902
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab65900
    ; ####increment refcount
    add qword [r8 + 0], 1

lab65900:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab65901
    ; ####increment refcount
    add qword [rsi + 0], 1

lab65901:
    jmp lab65903

lab65902:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab65903:
    ; substitute (a1 !-> a1)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Assign_65898_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab65906
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab65904
    ; ####increment refcount
    add qword [r10 + 0], 1

lab65904:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab65905
    ; ####increment refcount
    add qword [r8 + 0], 1

lab65905:
    jmp lab65907

lab65906:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab65907:
    ; substitute (a0 !-> a0)(as !-> as)(a !-> a)(acc !-> acc);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; let x0: List[Assign] = Cons(a, acc);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab65919
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab65920

lab65919:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab65917
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab65910
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab65908
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab65909

lab65908:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab65909:

lab65910:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab65913
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab65911
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab65912

lab65911:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab65912:

lab65913:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab65916
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab65914
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab65915

lab65914:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab65915:

lab65916:
    jmp lab65918

lab65917:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab65918:

lab65920:
    ; #load tag
    mov r9, 5
    ; substitute (as !-> as)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump reverse_loop_
    jmp reverse_loop_

reverse_:
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (ls !-> ls)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump reverse_loop_
    jmp reverse_loop_

null__:
    ; substitute (a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Pair_i64_Assign_65921]
    add rcx, rdi
    jmp rcx

List_Pair_i64_Assign_65921:
    jmp near List_Pair_i64_Assign_65921_Nil
    jmp near List_Pair_i64_Assign_65921_Cons

List_Pair_i64_Assign_65921_Nil:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

List_Pair_i64_Assign_65921_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab65924
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab65922
    ; ####increment refcount
    add qword [r8 + 0], 1

lab65922:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab65923
    ; ####increment refcount
    add qword [rsi + 0], 1

lab65923:
    jmp lab65925

lab65924:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab65925:
    ; substitute (a0 !-> a0);
    ; #erase a
    cmp rsi, 0
    je lab65928
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab65926
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab65927

lab65926:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab65927:

lab65928:
    ; #erase as
    cmp r8, 0
    je lab65931
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab65929
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab65930

lab65929:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab65930:

lab65931:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

gr_assign_:
    ; substitute (a0 !-> a0)(a2 !-> a2)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Assign_65932:

Assign_65932_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab65933
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    jmp lab65934

lab65933:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]

lab65934:
    ; substitute (a0 !-> a0)(val1 !-> val1)(var1 !-> var1)(a2 !-> a2);
    ; #move variables
    mov r10, rsi
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Assign_65935:

Assign_65935_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab65936
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]
    jmp lab65937

lab65936:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]

lab65937:
    ; if var2 < var1 \{ ... \}
    cmp r11, r9
    jl lab65938
    ; if val2 < val1 \{ ... \}
    cmp r13, rdi
    jl lab65939
    ; substitute (a0 !-> a0);
    ; invoke a0 False
    add rdx, 5
    jmp rdx

lab65939:
    ; substitute (a0 !-> a0);
    ; invoke a0 True
    add rdx, 0
    jmp rdx

lab65938:
    ; substitute (a0 !-> a0);
    ; invoke a0 True
    add rdx, 0
    jmp rdx

qsort_:
    ; substitute (le !-> le)(a0 !-> a0)(r !-> r)(ls !-> ls);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_65940]
    add rcx, r11
    jmp rcx

List_i64_65940:
    jmp near List_i64_65940_Nil
    jmp near List_i64_65940_Cons

List_i64_65940_Nil:
    ; substitute (a0 !-> a0)(r !-> r);
    ; #erase le
    cmp rax, 0
    je lab65943
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab65941
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab65942

lab65941:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab65942:

lab65943:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    mov rsi, r8
    mov rdi, r9
    ; switch r \{ ... \};
    lea rcx, [rel List_i64_65944]
    add rcx, rdi
    jmp rcx

List_i64_65944:
    jmp near List_i64_65944_Nil
    jmp near List_i64_65944_Cons

List_i64_65944_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_65944_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab65946
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab65945
    ; ####increment refcount
    add qword [r8 + 0], 1

lab65945:
    mov rdi, [rsi + 40]
    jmp lab65947

lab65946:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab65947:
    ; substitute (a1 !-> a1)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_65940_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab65949
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab65948
    ; ####increment refcount
    add qword [r12 + 0], 1

lab65948:
    mov r11, [r10 + 40]
    jmp lab65950

lab65949:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]

lab65950:
    ; switch xs \{ ... \};
    lea rcx, [rel List_i64_65951]
    add rcx, r13
    jmp rcx

List_i64_65951:
    jmp near List_i64_65951_Nil
    jmp near List_i64_65951_Cons

List_i64_65951_Nil:
    ; substitute (x !-> x)(r !-> r)(a0 !-> a0);
    ; #erase le
    cmp rax, 0
    je lab65954
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab65952
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab65953

lab65952:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab65953:

lab65954:
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rdx, r11
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_65951_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab65956
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab65955
    ; ####increment refcount
    add qword [r14 + 0], 1

lab65955:
    mov r13, [r12 + 40]
    jmp lab65957

lab65956:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]

lab65957:
    ; substitute (le !-> le)(a0 !-> a0)(r !-> r)(xs0 !-> xs0)(x0 !-> x0);
    ; #move variables
    mov r10, r14
    mov r11, r15
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    mov r15, 0
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    mov qword [rsp + 2024], 0
    ; substitute (le !-> le)(x0 !-> x0)(xs0 !-> xs0)(x1 !-> x1)(x2 !-> x2)(r !-> r)(a0 !-> a0);
    ; #move variables
    mov r12, [rsp + 2032]
    mov [rsp + 2032], rsi
    mov rcx, r13
    mov r13, [rsp + 2024]
    mov [rsp + 2024], rdi
    mov rdi, rcx
    mov rcx, r10
    mov r10, r14
    mov r14, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r15
    mov r15, r9
    mov r9, rcx
    ; jump qpart_
    jmp qpart_

qpart_:
    ; substitute (le !-> le)(x !-> x)(a0 !-> a0)(rlt !-> rlt)(rge !-> rge)(r !-> r)(ls !-> ls);
    ; #move variables
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], r8
    mov r8, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r9
    mov r9, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_65958]
    add rcx, [rsp + 2024]
    jmp rcx

List_i64_65958:
    jmp near List_i64_65958_Nil
    jmp near List_i64_65958_Cons

List_i64_65958_Nil:
    ; substitute (le0 !-> le)(r !-> r)(rge !-> rge)(rlt !-> rlt)(a0 !-> a0)(x !-> x)(le !-> le);
    ; #share le
    cmp rax, 0
    je lab65959
    ; ####increment refcount
    add qword [rax + 0], 1

lab65959:
    ; #move variables
    mov [rsp + 2032], rax
    mov [rsp + 2024], rdx
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    mov rcx, r12
    mov r12, r8
    mov r8, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    mov rsi, r14
    ; new a1: List[i64] = (rlt, a0, x, le)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov qword [rbx + 32], 0
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab65971
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab65972

lab65971:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab65969
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab65962
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab65960
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab65961

lab65960:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab65961:

lab65962:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab65965
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab65963
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab65964

lab65963:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab65964:

lab65965:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab65968
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab65966
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab65967

lab65966:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab65967:

lab65968:
    jmp lab65970

lab65969:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab65970:

lab65972:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab65984
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab65985

lab65984:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab65982
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab65975
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab65973
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab65974

lab65973:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab65974:

lab65975:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab65978
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab65976
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab65977

lab65976:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab65977:

lab65978:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab65981
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab65979
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab65980

lab65979:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab65980:

lab65981:
    jmp lab65983

lab65982:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab65983:

lab65985:
    ; #load tag
    lea r11, [rel List_i64_65986]
    ; substitute (le0 !-> le0)(rge !-> rge)(r !-> r)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump rqsort_
    jmp rqsort_

List_i64_65986:
    jmp near List_i64_65986_Nil
    jmp near List_i64_65986_Cons

List_i64_65986_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab65990
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab65987
    ; ####increment refcount
    add qword [rax + 0], 1

lab65987:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab65988
    ; ####increment refcount
    add qword [r10 + 0], 1

lab65988:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab65989
    ; ####increment refcount
    add qword [rsi + 0], 1

lab65989:
    jmp lab65991

lab65990:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab65991:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 0
    ; substitute (a0 !-> a0)(le !-> le)(rlt !-> rlt)(x !-> x)(x1 !-> x1);
    ; #move variables
    mov r8, rax
    mov rcx, rdi
    mov rdi, r11
    mov r11, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, rsi
    mov rsi, r10
    ; jump lift_qpart_0_
    jmp lift_qpart_0_

List_i64_65986_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab65995
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab65992
    ; ####increment refcount
    add qword [r8 + 0], 1

lab65992:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab65993
    ; ####increment refcount
    add qword [r14 + 0], 1

lab65993:
    mov r13, [r10 + 40]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab65994
    ; ####increment refcount
    add qword [r10 + 0], 1

lab65994:
    jmp lab65996

lab65995:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab65996:
    ; substitute (le !-> le)(x !-> x)(rlt !-> rlt)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    mov rax, r14
    mov r14, rsi
    ; let x1: List[i64] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66008
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab66009

lab66008:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66006
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab65999
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab65997
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab65998

lab65997:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab65998:

lab65999:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66002
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66000
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66001

lab66000:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66001:

lab66002:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66005
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66003
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66004

lab66003:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66004:

lab66005:
    jmp lab66007

lab66006:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66007:

lab66009:
    ; #load tag
    mov r13, 5
    ; substitute (a0 !-> a0)(le !-> le)(rlt !-> rlt)(x !-> x)(x1 !-> x1);
    ; #move variables
    mov rsi, rax
    mov rcx, r11
    mov r11, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r10
    ; jump lift_qpart_0_
    jmp lift_qpart_0_

List_i64_65958_Cons:
    ; #load from memory
    mov rcx, [rsp + 2032]
    ; ##check refcount
    cmp qword [rcx + 0], 0
    je lab66011
    ; ##either decrement refcount and share children...
    add qword [rcx + 0], -1
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab66010
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66010:
    mov rcx, [rax + 40]
    mov [rsp + 2024], rcx
    mov rax, [rsp + 2040]
    jmp lab66012

lab66011:
    ; ##... or release blocks onto linear free list when loading
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2016], rcx
    mov rcx, [rax + 40]
    mov [rsp + 2024], rcx
    mov rax, [rsp + 2040]

lab66012:
    ; substitute (le1 !-> le)(x4 !-> x)(y0 !-> y)(rlt !-> rlt)(rge !-> rge)(r !-> r)(y !-> y)(ys !-> ys)(le !-> le)(x !-> x)(a0 !-> a0);
    ; #share le
    cmp rax, 0
    je lab66013
    ; ####increment refcount
    add qword [rax + 0], 1

lab66013:
    ; #move variables
    mov [rsp + 2000], rax
    mov [rsp + 1992], rdx
    mov [rsp + 1976], rdi
    mov [rsp + 1968], r8
    mov [rsp + 1960], r9
    mov r9, [rsp + 2024]
    ; new a3: Bool = (rlt, rge, r, y, ys, le, x, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66025
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66026

lab66025:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66023
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66016
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66014
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66015

lab66014:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66015:

lab66016:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66019
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66017
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66018

lab66017:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66018:

lab66019:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66022
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66020
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66021

lab66020:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66021:

lab66022:
    jmp lab66024

lab66023:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66024:

lab66026:
    ; ##store link to previous block
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66038
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66039

lab66038:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66036
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66029
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66027
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66028

lab66027:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66028:

lab66029:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66032
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66030
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66031

lab66030:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66031:

lab66032:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66035
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66033
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66034

lab66033:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66034:

lab66035:
    jmp lab66037

lab66036:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66037:

lab66039:
    ; ##store link to previous block
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    ; ##store values
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66051
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab66052

lab66051:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66049
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66042
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66040
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66041

lab66040:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66041:

lab66042:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66045
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66043
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66044

lab66043:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66044:

lab66045:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66048
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66046
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66047

lab66046:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66047:

lab66048:
    jmp lab66050

lab66049:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66050:

lab66052:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66064
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab66065

lab66064:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66062
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66055
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66053
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66054

lab66053:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66054:

lab66055:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66058
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66056
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66057

lab66056:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66057:

lab66058:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66061
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66059
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66060

lab66059:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66060:

lab66061:
    jmp lab66063

lab66062:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66063:

lab66065:
    ; #load tag
    lea r11, [rel Bool_66066]
    ; let a2: Fun[i64, Bool] = Ap(y0, a3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66078
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab66079

lab66078:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66076
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66069
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66067
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66068

lab66067:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66068:

lab66069:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66072
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66070
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66071

lab66070:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66071:

lab66072:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66075
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66073
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66074

lab66073:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66074:

lab66075:
    jmp lab66077

lab66076:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66077:

lab66079:
    ; #load tag
    mov r9, 0
    ; substitute (x4 !-> x4)(a2 !-> a2)(le1 !-> le1);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke le1 Ap
    jmp r9

Bool_66066:
    jmp near Bool_66066_True
    jmp near Bool_66066_False

Bool_66066_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66086
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab66080
    ; ####increment refcount
    add qword [rax + 0], 1

lab66080:
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab66081
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66081:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab66082
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66082:
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab66083
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66083:
    mov r11, [r10 + 24]
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab66084
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66084:
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]
    cmp r14, 0
    je lab66085
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66085:
    jmp lab66087

lab66086:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]

lab66087:
    ; substitute (rlt !-> rlt)(a0 !-> a0)(r !-> r)(x !-> x)(ys !-> ys)(le !-> le)(y !-> y)(rge !-> rge);
    ; #move variables
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], rsi
    mov rsi, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], rdi
    mov rdi, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r11
    mov r11, rcx
    ; let x2: List[i64] = Cons(y, rge);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66099
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66100

lab66099:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66097
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66090
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66088
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66089

lab66088:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66089:

lab66090:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66093
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66091
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66092

lab66091:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66092:

lab66093:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66096
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66094
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66095

lab66094:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66095:

lab66096:
    jmp lab66098

lab66097:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66098:

lab66100:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; substitute (le !-> le)(x !-> x)(ys !-> ys)(rlt !-> rlt)(x2 !-> x2)(r !-> r)(a0 !-> a0);
    ; #move variables
    mov r10, rax
    mov rcx, r15
    mov r15, r9
    mov r9, r13
    mov r13, [rsp + 2024]
    mov [rsp + 2024], rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r14
    mov r14, r8
    mov r8, r12
    mov r12, [rsp + 2032]
    mov [rsp + 2032], rsi
    ; jump qpart_
    jmp qpart_

Bool_66066_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66107
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab66101
    ; ####increment refcount
    add qword [rax + 0], 1

lab66101:
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab66102
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66102:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab66103
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66103:
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab66104
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66104:
    mov r11, [r10 + 24]
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab66105
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66105:
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]
    cmp r14, 0
    je lab66106
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66106:
    jmp lab66108

lab66107:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]

lab66108:
    ; substitute (a0 !-> a0)(rge !-> rge)(r !-> r)(x !-> x)(ys !-> ys)(le !-> le)(y !-> y)(rlt !-> rlt);
    ; #move variables
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], rax
    mov rax, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], rdx
    mov rdx, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r11
    mov r11, rcx
    ; let x3: List[i64] = Cons(y, rlt);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66120
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66121

lab66120:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66118
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66111
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66109
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66110

lab66109:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66110:

lab66111:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66114
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66112
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66113

lab66112:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66113:

lab66114:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66117
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66115
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66116

lab66115:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66116:

lab66117:
    jmp lab66119

lab66118:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66119:

lab66121:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; substitute (le !-> le)(x !-> x)(ys !-> ys)(x3 !-> x3)(rge !-> rge)(r !-> r)(a0 !-> a0);
    ; #move variables
    mov r10, [rsp + 2032]
    mov [rsp + 2032], rax
    mov rcx, r15
    mov r15, r9
    mov r9, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, [rsp + 2024]
    mov [rsp + 2024], rdx
    mov rdx, rcx
    mov rax, r14
    mov r14, r8
    mov r8, r12
    mov r12, rsi
    ; jump qpart_
    jmp qpart_

lift_qpart_0_:
    ; let x0: List[i64] = Cons(x, x1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66133
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab66134

lab66133:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66131
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66124
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66122
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66123

lab66122:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66123:

lab66124:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66127
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66125
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66126

lab66125:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66126:

lab66127:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66130
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66128
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66129

lab66128:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66129:

lab66130:
    jmp lab66132

lab66131:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66132:

lab66134:
    ; #load tag
    mov r11, 5
    ; substitute (le !-> le)(rlt !-> rlt)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; jump rqsort_
    jmp rqsort_

rqsort_:
    ; substitute (le !-> le)(a0 !-> a0)(r !-> r)(ls !-> ls);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_66135]
    add rcx, r11
    jmp rcx

List_i64_66135:
    jmp near List_i64_66135_Nil
    jmp near List_i64_66135_Cons

List_i64_66135_Nil:
    ; substitute (a0 !-> a0)(r !-> r);
    ; #erase le
    cmp rax, 0
    je lab66138
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab66136
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab66137

lab66136:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab66137:

lab66138:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    mov rsi, r8
    mov rdi, r9
    ; switch r \{ ... \};
    lea rcx, [rel List_i64_66139]
    add rcx, rdi
    jmp rcx

List_i64_66139:
    jmp near List_i64_66139_Nil
    jmp near List_i64_66139_Cons

List_i64_66139_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_66139_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab66141
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab66140
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66140:
    mov rdi, [rsi + 40]
    jmp lab66142

lab66141:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab66142:
    ; substitute (a1 !-> a1)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_66135_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab66144
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab66143
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66143:
    mov r11, [r10 + 40]
    jmp lab66145

lab66144:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]

lab66145:
    ; switch xs \{ ... \};
    lea rcx, [rel List_i64_66146]
    add rcx, r13
    jmp rcx

List_i64_66146:
    jmp near List_i64_66146_Nil
    jmp near List_i64_66146_Cons

List_i64_66146_Nil:
    ; substitute (x !-> x)(r !-> r)(a0 !-> a0);
    ; #erase le
    cmp rax, 0
    je lab66149
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab66147
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab66148

lab66147:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab66148:

lab66149:
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rdx, r11
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_66146_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab66151
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab66150
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66150:
    mov r13, [r12 + 40]
    jmp lab66152

lab66151:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]

lab66152:
    ; substitute (le !-> le)(a0 !-> a0)(r !-> r)(xs0 !-> xs0)(x0 !-> x0);
    ; #move variables
    mov r10, r14
    mov r11, r15
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    mov r15, 0
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    mov qword [rsp + 2024], 0
    ; substitute (le !-> le)(x0 !-> x0)(xs0 !-> xs0)(x1 !-> x1)(x2 !-> x2)(r !-> r)(a0 !-> a0);
    ; #move variables
    mov r12, [rsp + 2032]
    mov [rsp + 2032], rsi
    mov rcx, r13
    mov r13, [rsp + 2024]
    mov [rsp + 2024], rdi
    mov rdi, rcx
    mov rcx, r10
    mov r10, r14
    mov r14, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r15
    mov r15, r9
    mov r9, rcx
    ; jump rqpart_
    jmp rqpart_

rqpart_:
    ; substitute (le !-> le)(x !-> x)(a0 !-> a0)(rle !-> rle)(rgt !-> rgt)(r !-> r)(ls !-> ls);
    ; #move variables
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], r8
    mov r8, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r9
    mov r9, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_66153]
    add rcx, [rsp + 2024]
    jmp rcx

List_i64_66153:
    jmp near List_i64_66153_Nil
    jmp near List_i64_66153_Cons

List_i64_66153_Nil:
    ; substitute (le0 !-> le)(r !-> r)(rgt !-> rgt)(rle !-> rle)(a0 !-> a0)(x !-> x)(le !-> le);
    ; #share le
    cmp rax, 0
    je lab66154
    ; ####increment refcount
    add qword [rax + 0], 1

lab66154:
    ; #move variables
    mov [rsp + 2032], rax
    mov [rsp + 2024], rdx
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    mov rcx, r12
    mov r12, r8
    mov r8, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    mov rsi, r14
    ; new a1: List[i64] = (rle, a0, x, le)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov qword [rbx + 32], 0
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66166
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab66167

lab66166:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66164
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66157
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66155
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66156

lab66155:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66156:

lab66157:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66160
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66158
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66159

lab66158:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66159:

lab66160:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66163
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66161
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66162

lab66161:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66162:

lab66163:
    jmp lab66165

lab66164:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66165:

lab66167:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66179
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab66180

lab66179:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66177
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66170
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66168
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66169

lab66168:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66169:

lab66170:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66173
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66171
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66172

lab66171:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66172:

lab66173:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66176
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66174
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66175

lab66174:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66175:

lab66176:
    jmp lab66178

lab66177:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66178:

lab66180:
    ; #load tag
    lea r11, [rel List_i64_66181]
    ; substitute (le0 !-> le0)(rgt !-> rgt)(r !-> r)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump qsort_
    jmp qsort_

List_i64_66181:
    jmp near List_i64_66181_Nil
    jmp near List_i64_66181_Cons

List_i64_66181_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66185
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab66182
    ; ####increment refcount
    add qword [rax + 0], 1

lab66182:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab66183
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66183:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab66184
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66184:
    jmp lab66186

lab66185:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab66186:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 0
    ; substitute (a0 !-> a0)(le !-> le)(rle !-> rle)(x !-> x)(x1 !-> x1);
    ; #move variables
    mov r8, rax
    mov rcx, rdi
    mov rdi, r11
    mov r11, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, rsi
    mov rsi, r10
    ; jump lift_rqpart_0_
    jmp lift_rqpart_0_

List_i64_66181_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab66190
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab66187
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66187:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab66188
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66188:
    mov r13, [r10 + 40]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab66189
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66189:
    jmp lab66191

lab66190:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab66191:
    ; substitute (le !-> le)(x !-> x)(rle !-> rle)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    mov rax, r14
    mov r14, rsi
    ; let x1: List[i64] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66203
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab66204

lab66203:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66201
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66194
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66192
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66193

lab66192:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66193:

lab66194:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66197
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66195
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66196

lab66195:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66196:

lab66197:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66200
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66198
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66199

lab66198:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66199:

lab66200:
    jmp lab66202

lab66201:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66202:

lab66204:
    ; #load tag
    mov r13, 5
    ; substitute (a0 !-> a0)(le !-> le)(rle !-> rle)(x !-> x)(x1 !-> x1);
    ; #move variables
    mov rsi, rax
    mov rcx, r11
    mov r11, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r10
    ; jump lift_rqpart_0_
    jmp lift_rqpart_0_

List_i64_66153_Cons:
    ; #load from memory
    mov rcx, [rsp + 2032]
    ; ##check refcount
    cmp qword [rcx + 0], 0
    je lab66206
    ; ##either decrement refcount and share children...
    add qword [rcx + 0], -1
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab66205
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66205:
    mov rcx, [rax + 40]
    mov [rsp + 2024], rcx
    mov rax, [rsp + 2040]
    jmp lab66207

lab66206:
    ; ##... or release blocks onto linear free list when loading
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2016], rcx
    mov rcx, [rax + 40]
    mov [rsp + 2024], rcx
    mov rax, [rsp + 2040]

lab66207:
    ; substitute (le1 !-> le)(x4 !-> x)(y0 !-> y)(rle !-> rle)(rgt !-> rgt)(r !-> r)(y !-> y)(ys !-> ys)(le !-> le)(x !-> x)(a0 !-> a0);
    ; #share le
    cmp rax, 0
    je lab66208
    ; ####increment refcount
    add qword [rax + 0], 1

lab66208:
    ; #move variables
    mov [rsp + 2000], rax
    mov [rsp + 1992], rdx
    mov [rsp + 1976], rdi
    mov [rsp + 1968], r8
    mov [rsp + 1960], r9
    mov r9, [rsp + 2024]
    ; new a3: Bool = (rle, rgt, r, y, ys, le, x, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov rcx, [rsp + 1992]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66220
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66221

lab66220:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66218
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66211
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66209
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66210

lab66209:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66210:

lab66211:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66214
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66212
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66213

lab66212:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66213:

lab66214:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66217
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66215
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66216

lab66215:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66216:

lab66217:
    jmp lab66219

lab66218:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66219:

lab66221:
    ; ##store link to previous block
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66233
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66234

lab66233:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66231
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66224
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66222
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66223

lab66222:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66223:

lab66224:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66227
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66225
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66226

lab66225:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66226:

lab66227:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66230
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66228
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66229

lab66228:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66229:

lab66230:
    jmp lab66232

lab66231:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66232:

lab66234:
    ; ##store link to previous block
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    ; ##store values
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66246
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab66247

lab66246:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66244
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66237
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66235
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66236

lab66235:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66236:

lab66237:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66240
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66238
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66239

lab66238:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66239:

lab66240:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66243
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66241
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66242

lab66241:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66242:

lab66243:
    jmp lab66245

lab66244:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66245:

lab66247:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66259
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab66260

lab66259:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66257
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66250
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66248
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66249

lab66248:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66249:

lab66250:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66253
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66251
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66252

lab66251:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66252:

lab66253:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66256
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66254
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66255

lab66254:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66255:

lab66256:
    jmp lab66258

lab66257:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66258:

lab66260:
    ; #load tag
    lea r11, [rel Bool_66261]
    ; substitute (le1 !-> le1)(y0 !-> y0)(x4 !-> x4)(a3 !-> a3);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; let a2: Fun[i64, Bool] = Ap(x4, a3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66273
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab66274

lab66273:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66271
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66264
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66262
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66263

lab66262:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66263:

lab66264:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66267
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66265
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66266

lab66265:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66266:

lab66267:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66270
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66268
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66269

lab66268:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66269:

lab66270:
    jmp lab66272

lab66271:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66272:

lab66274:
    ; #load tag
    mov r9, 0
    ; substitute (y0 !-> y0)(a2 !-> a2)(le1 !-> le1);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke le1 Ap
    jmp r9

Bool_66261:
    jmp near Bool_66261_True
    jmp near Bool_66261_False

Bool_66261_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66281
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab66275
    ; ####increment refcount
    add qword [rax + 0], 1

lab66275:
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab66276
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66276:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab66277
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66277:
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab66278
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66278:
    mov r11, [r10 + 24]
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab66279
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66279:
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]
    cmp r14, 0
    je lab66280
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66280:
    jmp lab66282

lab66281:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]

lab66282:
    ; substitute (a0 !-> a0)(rgt !-> rgt)(r !-> r)(x !-> x)(ys !-> ys)(le !-> le)(y !-> y)(rle !-> rle);
    ; #move variables
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], rax
    mov rax, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], rdx
    mov rdx, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r11
    mov r11, rcx
    ; let x2: List[i64] = Cons(y, rle);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66294
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66295

lab66294:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66292
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66285
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66283
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66284

lab66283:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66284:

lab66285:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66288
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66286
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66287

lab66286:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66287:

lab66288:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66291
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66289
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66290

lab66289:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66290:

lab66291:
    jmp lab66293

lab66292:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66293:

lab66295:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; substitute (le !-> le)(x !-> x)(ys !-> ys)(x2 !-> x2)(rgt !-> rgt)(r !-> r)(a0 !-> a0);
    ; #move variables
    mov r10, [rsp + 2032]
    mov [rsp + 2032], rax
    mov rcx, r15
    mov r15, r9
    mov r9, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, [rsp + 2024]
    mov [rsp + 2024], rdx
    mov rdx, rcx
    mov rax, r14
    mov r14, r8
    mov r8, r12
    mov r12, rsi
    ; jump rqpart_
    jmp rqpart_

Bool_66261_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66302
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab66296
    ; ####increment refcount
    add qword [rax + 0], 1

lab66296:
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab66297
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66297:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab66298
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66298:
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab66299
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66299:
    mov r11, [r10 + 24]
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab66300
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66300:
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]
    cmp r14, 0
    je lab66301
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66301:
    jmp lab66303

lab66302:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]

lab66303:
    ; substitute (rle !-> rle)(a0 !-> a0)(r !-> r)(x !-> x)(ys !-> ys)(le !-> le)(y !-> y)(rgt !-> rgt);
    ; #move variables
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], rsi
    mov rsi, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], rdi
    mov rdi, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], r11
    mov r11, rcx
    ; let x3: List[i64] = Cons(y, rgt);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66315
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66316

lab66315:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66313
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66306
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66304
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66305

lab66304:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66305:

lab66306:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66309
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66307
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66308

lab66307:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66308:

lab66309:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66312
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66310
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66311

lab66310:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66311:

lab66312:
    jmp lab66314

lab66313:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66314:

lab66316:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; substitute (le !-> le)(x !-> x)(ys !-> ys)(rle !-> rle)(x3 !-> x3)(r !-> r)(a0 !-> a0);
    ; #move variables
    mov r10, rax
    mov rcx, r15
    mov r15, r9
    mov r9, r13
    mov r13, [rsp + 2024]
    mov [rsp + 2024], rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r14
    mov r14, r8
    mov r8, r12
    mov r12, [rsp + 2032]
    mov [rsp + 2032], rsi
    ; jump rqpart_
    jmp rqpart_

lift_rqpart_0_:
    ; let x0: List[i64] = Cons(x, x1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66328
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab66329

lab66328:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66326
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66319
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66317
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66318

lab66317:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66318:

lab66319:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66322
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66320
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66321

lab66320:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66321:

lab66322:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66325
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66323
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66324

lab66323:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66324:

lab66325:
    jmp lab66327

lab66326:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66327:

lab66329:
    ; #load tag
    mov r11, 5
    ; substitute (le !-> le)(rle !-> rle)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; jump rqsort_
    jmp rqsort_

level_:
    ; substitute (a0 !-> a0)(a !-> a);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch a \{ ... \};
    ; #if there is only one clause, we can just fall through

Assign_66330:

Assign_66330_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab66331
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    jmp lab66332

lab66331:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]

lab66332:
    ; substitute (v !-> v)(a0 !-> a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    jmp rdi

value_:
    ; substitute (a0 !-> a0)(a !-> a);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch a \{ ... \};
    ; #if there is only one clause, we can just fall through

Assign_66333:

Assign_66333_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab66334
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    jmp lab66335

lab66334:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]

lab66335:
    ; substitute (v !-> v)(a0 !-> a0);
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rdx, r9
    ; invoke a0 Ret
    jmp rdi

max_level_:
    ; substitute (a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_66336]
    add rcx, rdi
    jmp rcx

List_Assign_66336:
    jmp near List_Assign_66336_Nil
    jmp near List_Assign_66336_Cons

List_Assign_66336_Nil:
    ; lit x0 <- 0;
    mov rdi, 0
    ; substitute (x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    jmp rdi

List_Assign_66336_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab66339
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab66337
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66337:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab66338
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66338:
    jmp lab66340

lab66339:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab66340:
    ; substitute (a0 !-> a0)(a !-> a);
    ; #erase t
    cmp r8, 0
    je lab66343
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab66341
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab66342

lab66341:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab66342:

lab66343:
    ; switch a \{ ... \};
    ; #if there is only one clause, we can just fall through

Assign_66344:

Assign_66344_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab66345
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    jmp lab66346

lab66345:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]

lab66346:
    ; substitute (v !-> v)(a0 !-> a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    jmp rdi

complete_:
    ; substitute (a0 !-> a0)(s !-> s)(csp !-> csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #if there is only one clause, we can just fall through

CSP_66347:

CSP_66347_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab66349
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab66348
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66348:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    jmp lab66350

lab66349:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]

lab66350:
    ; substitute (s !-> s)(a0 !-> a0)(v !-> v);
    ; #erase rel
    cmp r12, 0
    je lab66353
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab66351
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab66352

lab66351:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab66352:

lab66353:
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; new a1: _Cont = (a0, v)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov qword [rbx + 48], 0
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66365
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab66366

lab66365:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66363
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66356
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66354
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66355

lab66354:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66355:

lab66356:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66359
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66357
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66358

lab66357:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66358:

lab66359:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66362
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66360
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66361

lab66360:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66361:

lab66362:
    jmp lab66364

lab66363:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66364:

lab66366:
    ; #load tag
    lea rdi, [rel _Cont_66367]
    ; jump max_level_
    jmp max_level_

_Cont_66367:

_Cont_66367_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab66369
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab66368
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66368:
    jmp lab66370

lab66369:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab66370:
    ; substitute (x0 !-> x0)(v !-> v)(a0 !-> a0);
    ; #move variables
    mov r8, rsi
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump eq_
    jmp eq_

gen_lscomp2_:
    ; substitute (a0 !-> a0)(t1 !-> t1)(vals !-> vals)(var_ !-> var_)(val_ !-> val_)(ls !-> ls);
    ; #move variables
    mov rcx, r14
    mov r14, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_Assign_66371]
    add rcx, r15
    jmp rcx

List_List_Assign_66371:
    jmp near List_List_Assign_66371_Nil
    jmp near List_List_Assign_66371_Cons

List_List_Assign_66371_Nil:
    ; substitute (t1 !-> t1)(vals !-> vals)(var_ !-> var_)(a0 !-> a0);
    ; #move variables
    mov r10, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump gen_lscomp1_
    jmp gen_lscomp1_

List_List_Assign_66371_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r14 + 0], 0
    je lab66374
    ; ##either decrement refcount and share children...
    add qword [r14 + 0], -1
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab66372
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66372:
    mov r15, [r14 + 40]
    mov r14, [r14 + 32]
    cmp r14, 0
    je lab66373
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66373:
    jmp lab66375

lab66374:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r14 + 40]
    mov r14, [r14 + 32]

lab66375:
    ; substitute (a0 !-> a0)(t1 !-> t1)(vals !-> vals)(var_ !-> var_)(val_ !-> val_)(st !-> st)(t2 !-> t2)(var_0 !-> var_)(val_0 !-> val_);
    ; #move variables
    mov [rsp + 2008], r11
    mov [rsp + 1992], r13
    ; let x1: Assign = Assign(var_0, val_0);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2016], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66387
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66388

lab66387:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66385
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66378
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66376
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66377

lab66376:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66377:

lab66378:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66381
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66379
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66380

lab66379:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66380:

lab66381:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66384
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66382
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66383

lab66382:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66383:

lab66384:
    jmp lab66386

lab66385:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66386:

lab66388:
    ; #load tag
    mov qword [rsp + 2008], 0
    ; substitute (a0 !-> a0)(t1 !-> t1)(vals !-> vals)(var_ !-> var_)(val_ !-> val_)(t2 !-> t2)(x1 !-> x1)(st !-> st);
    ; #move variables
    mov rcx, [rsp + 2032]
    mov [rsp + 2040], rcx
    mov rcx, [rsp + 2016]
    mov [rsp + 2032], rcx
    mov [rsp + 2016], r14
    mov r14, [rsp + 2040]
    mov rcx, [rsp + 2024]
    mov [rsp + 2040], rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2024], rcx
    mov [rsp + 2008], r15
    mov r15, [rsp + 2040]
    ; let x0: List[Assign] = Cons(x1, st);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66400
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66401

lab66400:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66398
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66391
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66389
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66390

lab66389:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66390:

lab66391:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66394
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66392
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66393

lab66392:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66393:

lab66394:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66397
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66395
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66396

lab66395:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66396:

lab66397:
    jmp lab66399

lab66398:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66399:

lab66401:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; substitute (t2 !-> t2)(t1 !-> t1)(vals !-> vals)(var_ !-> var_)(val_ !-> val_)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, r14
    mov r14, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdx
    mov rdx, rcx
    ; new a1: List[List[Assign]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66413
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab66414

lab66413:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66411
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66404
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66402
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66403

lab66402:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66403:

lab66404:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66407
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66405
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66406

lab66405:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66406:

lab66407:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66410
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66408
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66409

lab66408:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66409:

lab66410:
    jmp lab66412

lab66411:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66412:

lab66414:
    ; #load tag
    lea r15, [rel List_List_Assign_66415]
    ; jump gen_lscomp2_
    jmp gen_lscomp2_

List_List_Assign_66415:
    jmp near List_List_Assign_66415_Nil
    jmp near List_List_Assign_66415_Cons

List_List_Assign_66415_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66418
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab66416
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66416:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab66417
    ; ####increment refcount
    add qword [rax + 0], 1

lab66417:
    jmp lab66419

lab66418:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab66419:
    ; let x2: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x2 !-> x2)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Assign_66415_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab66422
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab66420
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66420:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab66421
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66421:
    jmp lab66423

lab66422:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab66423:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x2: List[List[Assign]] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66435
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab66436

lab66435:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66433
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66426
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66424
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66425

lab66424:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66425:

lab66426:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66429
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66427
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66428

lab66427:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66428:

lab66429:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66432
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66430
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66431

lab66430:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66431:

lab66432:
    jmp lab66434

lab66433:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66434:

lab66436:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x2 !-> x2)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

gen_lscomp1_:
    ; substitute (a0 !-> a0)(vals !-> vals)(var_ !-> var_)(ls !-> ls);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_66437]
    add rcx, r11
    jmp rcx

List_i64_66437:
    jmp near List_i64_66437_Nil
    jmp near List_i64_66437_Cons

List_i64_66437_Nil:
    ; substitute (a0 !-> a0);
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_66437_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab66439
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab66438
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66438:
    mov r11, [r10 + 40]
    jmp lab66440

lab66439:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]

lab66440:
    ; substitute (var_0 !-> var_)(vals0 !-> vals)(var_ !-> var_)(val_ !-> val_)(t1 !-> t1)(a0 !-> a0)(vals !-> vals);
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov [rsp + 2024], rdi
    mov rdx, r9
    ; new a1: List[List[Assign]] = (var_, val_, t1, a0, vals)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66452
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab66453

lab66452:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66450
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66443
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66441
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66442

lab66441:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66442:

lab66443:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66446
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66444
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66445

lab66444:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66445:

lab66446:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66449
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66447
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66448

lab66447:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66448:

lab66449:
    jmp lab66451

lab66450:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66451:

lab66453:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66465
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab66466

lab66465:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66463
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66456
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66454
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66455

lab66454:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66455:

lab66456:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66459
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66457
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66458

lab66457:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66458:

lab66459:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66462
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66460
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66461

lab66460:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66461:

lab66462:
    jmp lab66464

lab66463:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66464:

lab66466:
    ; #load tag
    lea r9, [rel List_List_Assign_66467]
    ; lit x1 <- 1;
    mov r11, 1
    ; x2 <- var_0 - x1;
    mov r13, rdx
    sub r13, r11
    ; substitute (vals0 !-> vals0)(x2 !-> x2)(a1 !-> a1);
    ; #move variables
    mov rdx, rdi
    mov rdi, r13
    ; jump gen_g_
    jmp gen_g_

List_List_Assign_66467:
    jmp near List_List_Assign_66467_Nil
    jmp near List_List_Assign_66467_Cons

List_List_Assign_66467_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66470
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rdx, [rax + 24]
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab66468
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66468:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab66469
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66469:
    jmp lab66471

lab66470:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rdx, [rax + 24]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab66471:
    ; let x0: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    mov r15, 0
    ; substitute (x0 !-> x0)(t1 !-> t1)(vals !-> vals)(var_ !-> var_)(val_ !-> val_)(a0 !-> a0);
    ; #move variables
    mov rcx, r15
    mov r15, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r9
    mov r9, r13
    mov r13, rdi
    mov rdi, rcx
    mov rsi, r8
    mov rax, r14
    mov r14, r10
    ; jump gen_lscomp2_
    jmp gen_lscomp2_

List_List_Assign_66467_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab66474
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    cmp r14, 0
    je lab66472
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66472:
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]
    cmp r12, 0
    je lab66473
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66473:
    jmp lab66475

lab66474:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]

lab66475:
    ; substitute (vals !-> vals)(a0 !-> a0)(var_ !-> var_)(val_ !-> val_)(t1 !-> t1)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov [rsp + 2032], rsi
    mov rsi, r14
    mov r14, rax
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], rdi
    mov rdi, r15
    mov r15, rdx
    mov rdx, rcx
    ; let x0: List[List[Assign]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66487
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab66488

lab66487:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66485
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66478
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66476
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66477

lab66476:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66477:

lab66478:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66481
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66479
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66480

lab66479:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66480:

lab66481:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66484
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66482
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66483

lab66482:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66483:

lab66484:
    jmp lab66486

lab66485:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66486:

lab66488:
    ; #load tag
    mov r15, 5
    ; substitute (x0 !-> x0)(t1 !-> t1)(vals !-> vals)(var_ !-> var_)(val_ !-> val_)(a0 !-> a0);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, r11
    mov r11, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r14
    mov r14, rsi
    mov rsi, r12
    ; jump gen_lscomp2_
    jmp gen_lscomp2_

gen_g_:
    ; if var_ == 0 \{ ... \}
    cmp rdi, 0
    je lab66489
    ; substitute (vals0 !-> vals)(var_ !-> var_)(a0 !-> a0)(vals !-> vals);
    ; #move variables
    mov r11, rdx
    ; new a1: List[i64] = (var_, a0, vals)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66501
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab66502

lab66501:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66499
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66492
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66490
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66491

lab66490:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66491:

lab66492:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66495
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66493
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66494

lab66493:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66494:

lab66495:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66498
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66496
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66497

lab66496:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66497:

lab66498:
    jmp lab66500

lab66499:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66500:

lab66502:
    ; #load tag
    lea rdi, [rel List_i64_66503]
    ; lit x3 <- 1;
    mov r9, 1
    ; substitute (x3 !-> x3)(vals0 !-> vals0)(a1 !-> a1);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_66503:
    jmp near List_i64_66503_Nil
    jmp near List_i64_66503_Cons

List_i64_66503_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66505
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab66504
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66504:
    mov rdx, [rax + 24]
    jmp lab66506

lab66505:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]

lab66506:
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (x2 !-> x2)(vals !-> vals)(var_ !-> var_)(a0 !-> a0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; jump gen_lscomp1_
    jmp gen_lscomp1_

List_i64_66503_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab66508
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab66507
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66507:
    mov r9, [r8 + 24]
    jmp lab66509

lab66508:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab66509:
    ; substitute (vals !-> vals)(a0 !-> a0)(var_ !-> var_)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov r12, rsi
    mov rsi, r10
    ; let x2: List[i64] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66521
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab66522

lab66521:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66519
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66512
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66510
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66511

lab66510:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66511:

lab66512:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66515
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66513
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66514

lab66513:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66514:

lab66515:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66518
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66516
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66517

lab66516:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66517:

lab66518:
    jmp lab66520

lab66519:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66520:

lab66522:
    ; #load tag
    mov r11, 5
    ; substitute (x2 !-> x2)(vals !-> vals)(var_ !-> var_)(a0 !-> a0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; jump gen_lscomp1_
    jmp gen_lscomp1_

lab66489:
    ; substitute (a0 !-> a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; let x1: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

generate_:
    ; substitute (a0 !-> a0)(csp !-> csp);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #if there is only one clause, we can just fall through

CSP_66523:

CSP_66523_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab66525
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab66524
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66524:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab66526

lab66525:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab66526:
    ; substitute (vals !-> vals)(vars !-> vars)(a0 !-> a0);
    ; #erase rel
    cmp r10, 0
    je lab66529
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab66527
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab66528

lab66527:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab66528:

lab66529:
    ; #move variables
    mov r8, rax
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump gen_g_
    jmp gen_g_

enum_from_to_:
    ; if from <= to_ \{ ... \}
    cmp rdx, rdi
    jle lab66530
    ; substitute (a0 !-> a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

lab66530:
    ; substitute (from0 !-> from)(to_ !-> to_)(a0 !-> a0)(from !-> from);
    ; #move variables
    mov r11, rdx
    ; new a1: List[i64] = (a0, from)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66542
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab66543

lab66542:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66540
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66533
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66531
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66532

lab66531:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66532:

lab66533:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66536
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66534
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66535

lab66534:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66535:

lab66536:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66539
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66537
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66538

lab66537:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66538:

lab66539:
    jmp lab66541

lab66540:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66541:

lab66543:
    ; #load tag
    lea r9, [rel List_i64_66544]
    ; lit x1 <- 1;
    mov r11, 1
    ; x2 <- from0 + x1;
    mov r13, rdx
    add r13, r11
    ; substitute (x2 !-> x2)(to_ !-> to_)(a1 !-> a1);
    ; #move variables
    mov rdx, r13
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_66544:
    jmp near List_i64_66544_Nil
    jmp near List_i64_66544_Cons

List_i64_66544_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66546
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab66545
    ; ####increment refcount
    add qword [rax + 0], 1

lab66545:
    jmp lab66547

lab66546:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab66547:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (from !-> from)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_66544_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab66549
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab66548
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66548:
    jmp lab66550

lab66549:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab66550:
    ; substitute (from !-> from)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov r10, rsi
    mov rsi, r8
    ; let x0: List[i64] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66562
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab66563

lab66562:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66560
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66553
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66551
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66552

lab66551:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66552:

lab66553:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66556
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66554
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66555

lab66554:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66555:

lab66556:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66559
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66557
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66558

lab66557:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66558:

lab66559:
    jmp lab66561

lab66560:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66561:

lab66563:
    ; #load tag
    mov r9, 5
    ; substitute (from !-> from)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

inc_lscomp2_:
    ; substitute (a0 !-> a0)(t1 !-> t1)(a !-> a)(rel !-> rel)(as_ !-> as_)(ls !-> ls);
    ; #move variables
    mov rcx, r14
    mov r14, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_66564]
    add rcx, r15
    jmp rcx

List_Assign_66564:
    jmp near List_Assign_66564_Nil
    jmp near List_Assign_66564_Cons

List_Assign_66564_Nil:
    ; substitute (t1 !-> t1)(rel !-> rel)(as_ !-> as_)(a0 !-> a0);
    ; #erase a
    cmp r8, 0
    je lab66567
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab66565
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab66566

lab66565:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab66566:

lab66567:
    ; #move variables
    mov rcx, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov r8, r12
    mov r9, r13
    ; jump inc_lscomp1_
    jmp inc_lscomp1_

List_Assign_66564_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r14 + 0], 0
    je lab66570
    ; ##either decrement refcount and share children...
    add qword [r14 + 0], -1
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab66568
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66568:
    mov r15, [r14 + 40]
    mov r14, [r14 + 32]
    cmp r14, 0
    je lab66569
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66569:
    jmp lab66571

lab66570:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r14 + 40]
    mov r14, [r14 + 32]

lab66571:
    ; substitute (b0 !-> b)(a9 !-> a)(a !-> a)(rel !-> rel)(as_ !-> as_)(b !-> b)(t2 !-> t2)(a0 !-> a0)(t1 !-> t1);
    ; #share a
    cmp r8, 0
    je lab66572
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66572:
    ; #share b
    cmp r14, 0
    je lab66573
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66573:
    ; #move variables
    mov [rsp + 2016], rax
    mov [rsp + 2008], rdx
    mov [rsp + 2000], rsi
    mov [rsp + 1992], rdi
    mov rsi, r8
    mov rdi, r9
    mov rax, r14
    mov rdx, r15
    ; new a3: Bool = (a, rel, as_, b, t2, a0, t1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66585
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66586

lab66585:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66583
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66576
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66574
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66575

lab66574:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66575:

lab66576:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66579
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66577
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66578

lab66577:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66578:

lab66579:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66582
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66580
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66581

lab66580:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66581:

lab66582:
    jmp lab66584

lab66583:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66584:

lab66586:
    ; ##store link to previous block
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    ; ##store values
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66598
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab66599

lab66598:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66596
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66589
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66587
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66588

lab66587:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66588:

lab66589:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66592
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66590
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66591

lab66590:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66591:

lab66592:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66595
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66593
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66594

lab66593:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66594:

lab66595:
    jmp lab66597

lab66596:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66597:

lab66599:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66611
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab66612

lab66611:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66609
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66602
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66600
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66601

lab66600:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66601:

lab66602:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66605
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66603
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66604

lab66603:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66604:

lab66605:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66608
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66606
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66607

lab66606:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66607:

lab66608:
    jmp lab66610

lab66609:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66610:

lab66612:
    ; #load tag
    lea r9, [rel Bool_66613]
    ; substitute (a9 !-> a9)(b0 !-> b0)(a3 !-> a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump gr_assign_
    jmp gr_assign_

Bool_66613:
    jmp near Bool_66613_True
    jmp near Bool_66613_False

Bool_66613_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66621
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab66614
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66614:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab66615
    ; ####increment refcount
    add qword [rax + 0], 1

lab66615:
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab66616
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66616:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab66617
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66617:
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab66618
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66618:
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    cmp r14, 0
    je lab66619
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66619:
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]
    cmp r12, 0
    je lab66620
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66620:
    jmp lab66622

lab66621:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]

lab66622:
    ; let x0: Bool = True();
    ; #mark no allocation
    mov qword [rsp + 2016], 0
    ; #load tag
    mov qword [rsp + 2008], 0
    ; substitute (a !-> a)(a0 !-> a0)(as_ !-> as_)(b !-> b)(rel !-> rel)(t1 !-> t1)(t2 !-> t2)(x0 !-> x0);
    ; #move variables
    mov rcx, r14
    mov r14, [rsp + 2032]
    mov [rsp + 2032], r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r15
    mov r15, [rsp + 2024]
    mov [rsp + 2024], r13
    mov r13, rdi
    mov rdi, rcx
    ; jump lift_inc_lscomp2_0_
    jmp lift_inc_lscomp2_0_

Bool_66613_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66630
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab66623
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66623:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab66624
    ; ####increment refcount
    add qword [rax + 0], 1

lab66624:
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab66625
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66625:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab66626
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66626:
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab66627
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66627:
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    cmp r14, 0
    je lab66628
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66628:
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]
    cmp r12, 0
    je lab66629
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66629:
    jmp lab66631

lab66630:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]

lab66631:
    ; let x0: Bool = False();
    ; #mark no allocation
    mov qword [rsp + 2016], 0
    ; #load tag
    mov qword [rsp + 2008], 5
    ; substitute (a !-> a)(a0 !-> a0)(as_ !-> as_)(b !-> b)(rel !-> rel)(t1 !-> t1)(t2 !-> t2)(x0 !-> x0);
    ; #move variables
    mov rcx, r14
    mov r14, [rsp + 2032]
    mov [rsp + 2032], r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r15
    mov r15, [rsp + 2024]
    mov [rsp + 2024], r13
    mov r13, rdi
    mov rdi, rcx
    ; jump lift_inc_lscomp2_0_
    jmp lift_inc_lscomp2_0_

lift_inc_lscomp2_0_:
    ; substitute (a9 !-> a)(rel0 !-> rel)(b0 !-> b)(b !-> b)(rel !-> rel)(t1 !-> t1)(t2 !-> t2)(x0 !-> x0)(a !-> a)(a0 !-> a0)(as_ !-> as_);
    ; #share a
    cmp rax, 0
    je lab66632
    ; ####increment refcount
    add qword [rax + 0], 1

lab66632:
    ; #share b
    cmp r10, 0
    je lab66633
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66633:
    ; #share rel
    cmp r12, 0
    je lab66634
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66634:
    ; #move variables
    mov [rsp + 2000], rax
    mov [rsp + 1992], rdx
    mov [rsp + 1984], rsi
    mov [rsp + 1976], rdi
    mov [rsp + 1968], r8
    mov [rsp + 1960], r9
    mov r8, r10
    mov r9, r11
    mov rsi, r12
    mov rdi, r13
    ; new a4: Bool = (b, rel, t1, t2, x0, a, a0, as_)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1960]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 1968]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 1976]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 1984]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 1992]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2000], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66646
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66647

lab66646:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66644
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66637
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66635
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66636

lab66635:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66636:

lab66637:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66640
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66638
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66639

lab66638:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66639:

lab66640:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66643
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66641
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66642

lab66641:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66642:

lab66643:
    jmp lab66645

lab66644:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66645:

lab66647:
    ; ##store link to previous block
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66659
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66660

lab66659:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66657
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66650
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66648
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66649

lab66648:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66649:

lab66650:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66653
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66651
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66652

lab66651:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66652:

lab66653:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66656
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66654
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66655

lab66654:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66655:

lab66656:
    jmp lab66658

lab66657:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66658:

lab66660:
    ; ##store link to previous block
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    ; ##store values
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66672
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab66673

lab66672:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66670
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66663
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66661
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66662

lab66661:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66662:

lab66663:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66666
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66664
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66665

lab66664:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66665:

lab66666:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66669
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66667
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66668

lab66667:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66668:

lab66669:
    jmp lab66671

lab66670:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66671:

lab66673:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66685
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab66686

lab66685:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66683
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66676
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66674
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66675

lab66674:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66675:

lab66676:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66679
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66677
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66678

lab66677:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66678:

lab66679:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66682
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66680
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66681

lab66680:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66681:

lab66682:
    jmp lab66684

lab66683:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66684:

lab66686:
    ; #load tag
    lea r11, [rel Bool_66687]
    ; new a5: Bool = (a4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66699
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab66700

lab66699:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66697
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66690
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66688
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66689

lab66688:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66689:

lab66690:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66693
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66691
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66692

lab66691:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66692:

lab66693:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66696
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66694
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66695

lab66694:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66695:

lab66696:
    jmp lab66698

lab66697:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66698:

lab66700:
    ; #load tag
    lea r11, [rel Bool_66701]
    ; let a6: Fun[Assign, Bool] = Ap(b0, a5);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66713
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab66714

lab66713:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66711
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66704
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66702
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66703

lab66702:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66703:

lab66704:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66707
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66705
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66706

lab66705:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66706:

lab66707:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66710
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66708
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66709

lab66708:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66709:

lab66710:
    jmp lab66712

lab66711:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66712:

lab66714:
    ; #load tag
    mov r9, 0
    ; substitute (a9 !-> a9)(a6 !-> a6)(rel0 !-> rel0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke rel0 Ap
    jmp r9

Bool_66701:
    jmp near Bool_66701_True
    jmp near Bool_66701_False

Bool_66701_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66716
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab66715
    ; ####increment refcount
    add qword [rax + 0], 1

lab66715:
    jmp lab66717

lab66716:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab66717:
    ; let x2: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x2 !-> x2)(a4 !-> a4);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_66701_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66719
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab66718
    ; ####increment refcount
    add qword [rax + 0], 1

lab66718:
    jmp lab66720

lab66719:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab66720:
    ; let x2: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x2 !-> x2)(a4 !-> a4);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_66687:
    jmp near Bool_66687_True
    jmp near Bool_66687_False

Bool_66687_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66729
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab66721
    ; ####increment refcount
    add qword [rax + 0], 1

lab66721:
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab66722
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66722:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab66723
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66723:
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab66724
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66724:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab66725
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66725:
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab66726
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66726:
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab66727
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66727:
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]
    cmp r14, 0
    je lab66728
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66728:
    jmp lab66730

lab66729:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]

lab66730:
    ; let x1: Bool = True();
    ; #mark no allocation
    mov qword [rsp + 2000], 0
    ; #load tag
    mov qword [rsp + 1992], 0
    ; substitute (a !-> a)(a0 !-> a0)(as_ !-> as_)(b !-> b)(rel !-> rel)(t1 !-> t1)(t2 !-> t2)(x0 !-> x0)(x1 !-> x1);
    ; #move variables
    mov rcx, r14
    mov r14, r8
    mov r8, [rsp + 2016]
    mov [rsp + 2016], r12
    mov r12, rsi
    mov rsi, [rsp + 2032]
    mov [rsp + 2032], r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, r9
    mov r9, [rsp + 2008]
    mov [rsp + 2008], r13
    mov r13, rdi
    mov rdi, [rsp + 2024]
    mov [rsp + 2024], r11
    mov r11, rdx
    mov rdx, rcx
    ; jump lift_inc_lscomp2_1_
    jmp lift_inc_lscomp2_1_

Bool_66687_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66739
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab66731
    ; ####increment refcount
    add qword [rax + 0], 1

lab66731:
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab66732
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66732:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab66733
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66733:
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab66734
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66734:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab66735
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66735:
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab66736
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66736:
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab66737
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66737:
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]
    cmp r14, 0
    je lab66738
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66738:
    jmp lab66740

lab66739:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]

lab66740:
    ; let x1: Bool = False();
    ; #mark no allocation
    mov qword [rsp + 2000], 0
    ; #load tag
    mov qword [rsp + 1992], 5
    ; substitute (a !-> a)(a0 !-> a0)(as_ !-> as_)(b !-> b)(rel !-> rel)(t1 !-> t1)(t2 !-> t2)(x0 !-> x0)(x1 !-> x1);
    ; #move variables
    mov rcx, r14
    mov r14, r8
    mov r8, [rsp + 2016]
    mov [rsp + 2016], r12
    mov r12, rsi
    mov rsi, [rsp + 2032]
    mov [rsp + 2032], r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, r9
    mov r9, [rsp + 2008]
    mov [rsp + 2008], r13
    mov r13, rdi
    mov rdi, [rsp + 2024]
    mov [rsp + 2024], r11
    mov r11, rdx
    mov rdx, rcx
    ; jump lift_inc_lscomp2_1_
    jmp lift_inc_lscomp2_1_

lift_inc_lscomp2_1_:
    ; substitute (x1 !-> x1)(x0 !-> x0)(as_ !-> as_)(b !-> b)(rel !-> rel)(t1 !-> t1)(t2 !-> t2)(a0 !-> a0)(a !-> a);
    ; #move variables
    mov rcx, [rsp + 2000]
    mov [rsp + 2000], rax
    mov rax, rcx
    mov rcx, [rsp + 1992]
    mov [rsp + 1992], rdx
    mov rdx, rcx
    mov rcx, [rsp + 2016]
    mov [rsp + 2016], rsi
    mov rsi, rcx
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], rdi
    mov rdi, rcx
    ; new a7: Bool = (as_, b, rel, t1, t2, a0, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2000]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66752
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66753

lab66752:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66750
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66743
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66741
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66742

lab66741:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66742:

lab66743:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66746
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66744
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66745

lab66744:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66745:

lab66746:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66749
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66747
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66748

lab66747:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66748:

lab66749:
    jmp lab66751

lab66750:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66751:

lab66753:
    ; ##store link to previous block
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    ; ##store values
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66765
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab66766

lab66765:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66763
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66756
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66754
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66755

lab66754:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66755:

lab66756:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66759
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66757
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66758

lab66757:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66758:

lab66759:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66762
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66760
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66761

lab66760:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66761:

lab66762:
    jmp lab66764

lab66763:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66764:

lab66766:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66778
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab66779

lab66778:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66776
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66769
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66767
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66768

lab66767:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66768:

lab66769:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66772
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66770
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66771

lab66770:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66771:

lab66772:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66775
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66773
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66774

lab66773:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66774:

lab66775:
    jmp lab66777

lab66776:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66777:

lab66779:
    ; #load tag
    lea r9, [rel Bool_66780]
    ; substitute (x0 !-> x0)(x1 !-> x1)(a7 !-> a7);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump and_
    jmp and_

Bool_66780:
    jmp near Bool_66780_True
    jmp near Bool_66780_False

Bool_66780_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66788
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab66781
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66781:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab66782
    ; ####increment refcount
    add qword [rax + 0], 1

lab66782:
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab66783
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66783:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab66784
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66784:
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab66785
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66785:
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    cmp r14, 0
    je lab66786
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66786:
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]
    cmp r12, 0
    je lab66787
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66787:
    jmp lab66789

lab66788:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]

lab66789:
    ; substitute (a9 !-> a)(b !-> b)(rel !-> rel)(t1 !-> t1)(t2 !-> t2)(a0 !-> a0)(a !-> a)(as_ !-> as_);
    ; #share a
    cmp qword [rsp + 2032], 0
    je lab66790
    mov rcx, [rsp + 2032]
    add qword [rcx + 0], 1

lab66790:
    ; #move variables
    mov [rsp + 2016], rax
    mov [rsp + 2008], rdx
    mov rax, [rsp + 2032]
    mov rdx, [rsp + 2024]
    ; new a1: _Cont = (b, rel, t1, t2, a0, a, as_)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    mov [rbx + 24], r15
    mov [rbx + 16], r14
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66802
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab66803

lab66802:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66800
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66793
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66791
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66792

lab66791:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66792:

lab66793:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66796
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66794
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66795

lab66794:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66795:

lab66796:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66799
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66797
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66798

lab66797:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66798:

lab66799:
    jmp lab66801

lab66800:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66801:

lab66803:
    ; ##store link to previous block
    mov [rbx + 48], r14
    ; ##store values
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66815
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab66816

lab66815:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66813
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66806
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66804
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66805

lab66804:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66805:

lab66806:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66809
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66807
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66808

lab66807:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66808:

lab66809:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66812
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66810
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66811

lab66810:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66811:

lab66812:
    jmp lab66814

lab66813:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66814:

lab66816:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66828
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab66829

lab66828:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66826
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66819
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66817
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66818

lab66817:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66818:

lab66819:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66822
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66820
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66821

lab66820:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66821:

lab66822:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66825
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66823
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66824

lab66823:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66824:

lab66825:
    jmp lab66827

lab66826:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66827:

lab66829:
    ; #load tag
    lea rdi, [rel _Cont_66830]
    ; jump level_
    jmp level_

_Cont_66830:

_Cont_66830_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab66838
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab66831
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66831:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab66832
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66832:
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab66833
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66833:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab66834
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66834:
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab66835
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66835:
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab66836
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66836:
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]
    cmp r14, 0
    je lab66837
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66837:
    jmp lab66839

lab66838:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 48]
    mov [rsp + 2016], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]

lab66839:
    ; substitute (as_ !-> as_)(a !-> a)(rel !-> rel)(t1 !-> t1)(t2 !-> t2)(a0 !-> a0)(x4 !-> x4)(b !-> b);
    ; #move variables
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], rdi
    mov rdi, [rsp + 2024]
    mov [rsp + 2024], rdx
    mov rdx, rcx
    mov rax, [rsp + 2016]
    mov [rsp + 2016], rsi
    mov rsi, [rsp + 2032]
    ; let x3: Pair[i64, Assign] = Tup(x4, b);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66851
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab66852

lab66851:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66849
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66842
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66840
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66841

lab66840:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66841:

lab66842:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66845
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66843
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66844

lab66843:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66844:

lab66845:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66848
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66846
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66847

lab66846:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66847:

lab66848:
    jmp lab66850

lab66849:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66850:

lab66852:
    ; #load tag
    mov qword [rsp + 2024], 0
    ; new a2: List[Pair[i64, Assign]] = (a0, x3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66864
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab66865

lab66864:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66862
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66855
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66853
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66854

lab66853:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66854:

lab66855:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66858
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66856
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66857

lab66856:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66857:

lab66858:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66861
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66859
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66860

lab66859:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66860:

lab66861:
    jmp lab66863

lab66862:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66863:

lab66865:
    ; #load tag
    lea r15, [rel List_Pair_i64_Assign_66866]
    ; substitute (t2 !-> t2)(t1 !-> t1)(a !-> a)(rel !-> rel)(as_ !-> as_)(a2 !-> a2);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump inc_lscomp2_
    jmp inc_lscomp2_

List_Pair_i64_Assign_66866:
    jmp near List_Pair_i64_Assign_66866_Nil
    jmp near List_Pair_i64_Assign_66866_Cons

List_Pair_i64_Assign_66866_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66869
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab66867
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66867:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab66868
    ; ####increment refcount
    add qword [rax + 0], 1

lab66868:
    jmp lab66870

lab66869:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab66870:
    ; let x5: List[Pair[i64, Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x3 !-> x3)(x5 !-> x5)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_i64_Assign_66866_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab66873
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab66871
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66871:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab66872
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66872:
    jmp lab66874

lab66873:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab66874:
    ; substitute (x3 !-> x3)(a0 !-> a0)(a8 !-> a8)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x5: List[Pair[i64, Assign]] = Cons(a8, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66886
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab66887

lab66886:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66884
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66877
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66875
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66876

lab66875:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66876:

lab66877:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66880
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66878
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66879

lab66878:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66879:

lab66880:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66883
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66881
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66882

lab66881:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66882:

lab66883:
    jmp lab66885

lab66884:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66885:

lab66887:
    ; #load tag
    mov r9, 5
    ; substitute (x3 !-> x3)(x5 !-> x5)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_66780_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66895
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab66888
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66888:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab66889
    ; ####increment refcount
    add qword [rax + 0], 1

lab66889:
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab66890
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66890:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab66891
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66891:
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab66892
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66892:
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    cmp r14, 0
    je lab66893
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66893:
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]
    cmp r12, 0
    je lab66894
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66894:
    jmp lab66896

lab66895:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]

lab66896:
    ; substitute (t2 !-> t2)(t1 !-> t1)(a !-> a)(rel !-> rel)(as_ !-> as_)(a0 !-> a0);
    ; #erase b
    cmp rsi, 0
    je lab66899
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab66897
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab66898

lab66897:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab66898:

lab66899:
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rsi, r10
    mov r10, r8
    mov rdi, r11
    mov r11, r9
    mov r8, [rsp + 2032]
    mov r9, [rsp + 2024]
    ; jump inc_lscomp2_
    jmp inc_lscomp2_

inc_lscomp1_:
    ; substitute (a0 !-> a0)(rel !-> rel)(as_ !-> as_)(ls !-> ls);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_66900]
    add rcx, r11
    jmp rcx

List_Assign_66900:
    jmp near List_Assign_66900_Nil
    jmp near List_Assign_66900_Cons

List_Assign_66900_Nil:
    ; substitute (a0 !-> a0);
    ; #erase as_
    cmp r8, 0
    je lab66903
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab66901
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab66902

lab66901:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab66902:

lab66903:
    ; #erase rel
    cmp rsi, 0
    je lab66906
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab66904
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab66905

lab66904:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab66905:

lab66906:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Assign_66900_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab66909
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab66907
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66907:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab66908
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66908:
    jmp lab66910

lab66909:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab66910:
    ; substitute (as_0 !-> as_)(rel !-> rel)(as_ !-> as_)(a !-> a)(t1 !-> t1)(a0 !-> a0);
    ; #share as_
    cmp r8, 0
    je lab66911
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66911:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov rax, r8
    mov rdx, r9
    ; new a1: List[Assign] = (rel, as_, a, t1, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66923
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab66924

lab66923:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66921
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66914
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66912
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66913

lab66912:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66913:

lab66914:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66917
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66915
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66916

lab66915:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66916:

lab66917:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66920
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66918
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66919

lab66918:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66919:

lab66920:
    jmp lab66922

lab66921:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66922:

lab66924:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66936
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab66937

lab66936:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66934
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66927
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66925
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66926

lab66925:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66926:

lab66927:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66930
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66928
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66929

lab66928:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66929:

lab66930:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66933
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66931
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66932

lab66931:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66932:

lab66933:
    jmp lab66935

lab66934:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66935:

lab66937:
    ; #load tag
    lea rdi, [rel List_Assign_66938]
    ; jump reverse_
    jmp reverse_

List_Assign_66938:
    jmp near List_Assign_66938_Nil
    jmp near List_Assign_66938_Cons

List_Assign_66938_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66944
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab66939
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66939:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab66940
    ; ####increment refcount
    add qword [rax + 0], 1

lab66940:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab66941
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66941:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab66942
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66942:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab66943
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66943:
    jmp lab66945

lab66944:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab66945:
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    mov r15, 0
    ; substitute (x0 !-> x0)(t1 !-> t1)(a !-> a)(rel !-> rel)(as_ !-> as_)(a0 !-> a0);
    ; #move variables
    mov rcx, r14
    mov r14, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; jump inc_lscomp2_
    jmp inc_lscomp2_

List_Assign_66938_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab66951
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab66946
    ; ####increment refcount
    add qword [r10 + 0], 1

lab66946:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab66947
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66947:
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab66948
    ; ####increment refcount
    add qword [rcx + 0], 1

lab66948:
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    cmp r14, 0
    je lab66949
    ; ####increment refcount
    add qword [r14 + 0], 1

lab66949:
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]
    cmp r12, 0
    je lab66950
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66950:
    jmp lab66952

lab66951:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r12, [r8 + 48]
    ; ###load values
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r12 + 40]
    mov r14, [r12 + 32]
    mov r13, [r12 + 24]
    mov r12, [r12 + 16]

lab66952:
    ; substitute (a0 !-> a0)(t1 !-> t1)(rel !-> rel)(as_ !-> as_)(a !-> a)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], rsi
    mov rsi, r14
    mov r14, rax
    mov rax, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], rdi
    mov rdi, r15
    mov r15, rdx
    mov rdx, rcx
    ; let x0: List[Assign] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66964
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab66965

lab66964:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66962
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66955
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66953
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66954

lab66953:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66954:

lab66955:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66958
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66956
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66957

lab66956:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66957:

lab66958:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66961
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66959
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66960

lab66959:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66960:

lab66961:
    jmp lab66963

lab66962:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66963:

lab66965:
    ; #load tag
    mov r15, 5
    ; substitute (x0 !-> x0)(t1 !-> t1)(a !-> a)(rel !-> rel)(as_ !-> as_)(a0 !-> a0);
    ; #move variables
    mov rcx, r14
    mov r14, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdx
    mov rdx, rcx
    mov rcx, r12
    mov r12, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, r9
    mov r9, rcx
    ; jump inc_lscomp2_
    jmp inc_lscomp2_

inconsistencies_:
    ; substitute (a0 !-> a0)(as_ !-> as_)(csp !-> csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #if there is only one clause, we can just fall through

CSP_66966:

CSP_66966_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab66968
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab66967
    ; ####increment refcount
    add qword [r12 + 0], 1

lab66967:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    jmp lab66969

lab66968:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]

lab66969:
    ; substitute (as_ !-> as_)(rel !-> rel)(as_0 !-> as_)(a0 !-> a0);
    ; #share as_
    cmp rsi, 0
    je lab66970
    ; ####increment refcount
    add qword [rsi + 0], 1

lab66970:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rax, rsi
    mov r8, rsi
    mov rdx, rdi
    mov r9, rdi
    mov rsi, r12
    mov rdi, r13
    ; jump inc_lscomp1_
    jmp inc_lscomp1_

consistent_:
    ; new a1: List[Pair[i64, Assign]] = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab66982
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab66983

lab66982:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab66980
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66973
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66971
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66972

lab66971:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66972:

lab66973:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66976
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66974
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66975

lab66974:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66975:

lab66976:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66979
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66977
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66978

lab66977:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66978:

lab66979:
    jmp lab66981

lab66980:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab66981:

lab66983:
    ; #load tag
    lea r9, [rel List_Pair_i64_Assign_66984]
    ; jump inconsistencies_
    jmp inconsistencies_

List_Pair_i64_Assign_66984:
    jmp near List_Pair_i64_Assign_66984_Nil
    jmp near List_Pair_i64_Assign_66984_Cons

List_Pair_i64_Assign_66984_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab66986
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab66985
    ; ####increment refcount
    add qword [rax + 0], 1

lab66985:
    jmp lab66987

lab66986:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab66987:
    ; let x0: List[Pair[i64, Assign]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump null__
    jmp null__

List_Pair_i64_Assign_66984_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab66989
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab66988
    ; ####increment refcount
    add qword [r8 + 0], 1

lab66988:
    jmp lab66990

lab66989:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab66990:
    ; substitute (a0 !-> a0)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x0: List[Pair[i64, Assign]] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67002
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab67003

lab67002:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67000
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab66993
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66991
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66992

lab66991:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66992:

lab66993:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab66996
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66994
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66995

lab66994:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66995:

lab66996:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab66999
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab66997
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab66998

lab66997:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab66998:

lab66999:
    jmp lab67001

lab67000:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67001:

lab67003:
    ; #load tag
    mov rdi, 5
    ; substitute (x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump null__
    jmp null__

test_filter_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_Assign_67004]
    add rcx, r9
    jmp rcx

List_List_Assign_67004:
    jmp near List_List_Assign_67004_Nil
    jmp near List_List_Assign_67004_Cons

List_List_Assign_67004_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab67007
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab67005
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab67006

lab67005:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab67006:

lab67007:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_Assign_67004_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67010
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67008
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67008:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67009
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67009:
    jmp lab67011

lab67010:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67011:
    ; substitute (f0 !-> f)(l0 !-> l)(l !-> l)(ls0 !-> ls0)(f !-> f)(a0 !-> a0);
    ; #share f
    cmp rax, 0
    je lab67012
    ; ####increment refcount
    add qword [rax + 0], 1

lab67012:
    ; #share l
    cmp r8, 0
    je lab67013
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67013:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rsi, r8
    mov rdi, r9
    ; new a2: Bool = (l, ls0, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67025
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab67026

lab67025:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67023
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67016
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67014
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67015

lab67014:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67015:

lab67016:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67019
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67017
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67018

lab67017:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67018:

lab67019:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67022
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67020
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67021

lab67020:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67021:

lab67022:
    jmp lab67024

lab67023:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67024:

lab67026:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67038
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67039

lab67038:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67036
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67029
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67027
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67028

lab67027:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67028:

lab67029:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67032
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67030
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67031

lab67030:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67031:

lab67032:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67035
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67033
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67034

lab67033:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67034:

lab67035:
    jmp lab67037

lab67036:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67037:

lab67039:
    ; #load tag
    lea r9, [rel Bool_67040]
    ; substitute (l0 !-> l0)(a2 !-> a2)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Bool_67040:
    jmp near Bool_67040_True
    jmp near Bool_67040_False

Bool_67040_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67045
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67041
    ; ####increment refcount
    add qword [rax + 0], 1

lab67041:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab67042
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67042:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab67043
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67043:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab67044
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67044:
    jmp lab67046

lab67045:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab67046:
    ; substitute (f !-> f)(ls0 !-> ls0)(l !-> l)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a1: List[List[Assign]] = (l, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67058
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67059

lab67058:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67056
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67049
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67047
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67048

lab67047:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67048:

lab67049:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67052
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67050
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67051

lab67050:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67051:

lab67052:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67055
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67053
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67054

lab67053:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67054:

lab67055:
    jmp lab67057

lab67056:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67057:

lab67059:
    ; #load tag
    lea r9, [rel List_List_Assign_67060]
    ; jump test_filter_
    jmp test_filter_

List_List_Assign_67060:
    jmp near List_List_Assign_67060_Nil
    jmp near List_List_Assign_67060_Cons

List_List_Assign_67060_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67063
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab67061
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67061:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67062
    ; ####increment refcount
    add qword [rax + 0], 1

lab67062:
    jmp lab67064

lab67063:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab67064:
    ; let x0: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (l !-> l)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Assign_67060_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67067
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67065
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67065:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67066
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67066:
    jmp lab67068

lab67067:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67068:
    ; substitute (a0 !-> a0)(l !-> l)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[List[Assign]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67080
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67081

lab67080:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67078
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67071
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67069
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67070

lab67069:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67070:

lab67071:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67074
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67072
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67073

lab67072:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67073:

lab67074:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67077
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67075
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67076

lab67075:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67076:

lab67077:
    jmp lab67079

lab67078:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67079:

lab67081:
    ; #load tag
    mov r9, 5
    ; substitute (l !-> l)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_67040_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67086
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67082
    ; ####increment refcount
    add qword [rax + 0], 1

lab67082:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab67083
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67083:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab67084
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67084:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab67085
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67085:
    jmp lab67087

lab67086:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab67087:
    ; substitute (f !-> f)(ls0 !-> ls0)(a0 !-> a0);
    ; #erase l
    cmp rax, 0
    je lab67090
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab67088
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab67089

lab67088:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab67089:

lab67090:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump test_filter_
    jmp test_filter_

test_:
    ; substitute (a0 !-> a0)(x !-> x)(csp !-> csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new x1: Fun[List[Assign], Bool] = (csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67102
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67103

lab67102:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67100
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67093
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67091
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67092

lab67091:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67092:

lab67093:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67096
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67094
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67095

lab67094:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67095:

lab67096:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67099
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67097
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67098

lab67097:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67098:

lab67099:
    jmp lab67101

lab67100:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67101:

lab67103:
    ; #load tag
    lea r9, [rel Fun_List_Assign_Bool_67104]
    ; substitute (x1 !-> x1)(x !-> x)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump test_filter_
    jmp test_filter_

Fun_List_Assign_Bool_67104:

Fun_List_Assign_Bool_67104_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67106
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab67105
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67105:
    jmp lab67107

lab67106:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab67107:
    ; substitute (csp !-> csp)(x0 !-> x0)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump consistent_
    jmp consistent_

solver_:
    ; substitute (csp0 !-> csp)(a0 !-> a0)(csp !-> csp);
    ; #share csp
    cmp rax, 0
    je lab67108
    ; ####increment refcount
    add qword [rax + 0], 1

lab67108:
    ; #move variables
    mov r8, rax
    mov r9, rdx
    ; new a1: List[List[Assign]] = (a0, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67120
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab67121

lab67120:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67118
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67111
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67109
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67110

lab67109:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67110:

lab67111:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67114
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67112
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67113

lab67112:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67113:

lab67114:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67117
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67115
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67116

lab67115:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67116:

lab67117:
    jmp lab67119

lab67118:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67119:

lab67121:
    ; #load tag
    lea rdi, [rel List_List_Assign_67122]
    ; jump generate_
    jmp generate_

List_List_Assign_67122:
    jmp near List_List_Assign_67122_Nil
    jmp near List_List_Assign_67122_Cons

List_List_Assign_67122_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67125
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab67123
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67123:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67124
    ; ####increment refcount
    add qword [rax + 0], 1

lab67124:
    jmp lab67126

lab67125:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab67126:
    ; let x0: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (csp !-> csp)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump test_
    jmp test_

List_List_Assign_67122_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67129
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67127
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67127:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67128
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67128:
    jmp lab67130

lab67129:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67130:
    ; substitute (csp !-> csp)(a0 !-> a0)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[List[Assign]] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67142
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67143

lab67142:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67140
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67133
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67131
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67132

lab67131:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67132:

lab67133:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67136
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67134
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67135

lab67134:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67135:

lab67136:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67139
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67137
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67138

lab67137:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67138:

lab67139:
    jmp lab67141

lab67140:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67141:

lab67143:
    ; #load tag
    mov r9, 5
    ; substitute (csp !-> csp)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump test_
    jmp test_

safe_:
    ; substitute (a0 !-> a0)(as2 !-> as2)(as1 !-> as1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch as1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Assign_67144:

Assign_67144_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67145
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    jmp lab67146

lab67145:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]

lab67146:
    ; substitute (a0 !-> a0)(m !-> m)(i !-> i)(as2 !-> as2);
    ; #move variables
    mov r10, rsi
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch as2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Assign_67147:

Assign_67147_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab67148
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]
    jmp lab67149

lab67148:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]

lab67149:
    ; substitute (n0 !-> n)(m0 !-> m)(i !-> i)(j !-> j)(n !-> n)(a0 !-> a0)(m !-> m);
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov [rsp + 2024], rdi
    mov rdx, r13
    ; new a1: Bool = (i, j, n, a0, m)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67161
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab67162

lab67161:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67159
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67152
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67150
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67151

lab67150:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67151:

lab67152:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67155
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67153
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67154

lab67153:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67154:

lab67155:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67158
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67156
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67157

lab67156:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67157:

lab67158:
    jmp lab67160

lab67159:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67160:

lab67162:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67174
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67175

lab67174:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67172
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67165
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67163
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67164

lab67163:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67164:

lab67165:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67168
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67166
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67167

lab67166:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67167:

lab67168:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67171
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67169
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67170

lab67169:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67170:

lab67171:
    jmp lab67173

lab67172:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67173:

lab67175:
    ; #load tag
    lea r9, [rel Bool_67176]
    ; new a2: Bool = (a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67188
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67189

lab67188:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67186
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67179
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67177
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67178

lab67177:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67178:

lab67179:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67182
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67180
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67181

lab67180:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67181:

lab67182:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67185
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67183
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67184

lab67183:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67184:

lab67185:
    jmp lab67187

lab67186:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67187:

lab67189:
    ; #load tag
    lea r9, [rel Bool_67190]
    ; substitute (m0 !-> m0)(n0 !-> n0)(a2 !-> a2);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump eq_
    jmp eq_

Bool_67190:
    jmp near Bool_67190_True
    jmp near Bool_67190_False

Bool_67190_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67192
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab67191
    ; ####increment refcount
    add qword [rax + 0], 1

lab67191:
    jmp lab67193

lab67192:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab67193:
    ; let x1: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 !-> x1)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_67190_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67195
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab67194
    ; ####increment refcount
    add qword [rax + 0], 1

lab67194:
    jmp lab67196

lab67195:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab67196:
    ; let x1: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x1 !-> x1)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_67176:
    jmp near Bool_67176_True
    jmp near Bool_67176_False

Bool_67176_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67198
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rdx, [rax + 24]
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab67197
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67197:
    mov r9, [r8 + 24]
    jmp lab67199

lab67198:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rdx, [rax + 24]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab67199:
    ; let x0: Bool = True();
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    mov r15, 0
    ; substitute (a0 !-> a0)(i !-> i)(j !-> j)(m !-> m)(n !-> n)(x0 !-> x0);
    ; #move variables
    mov rcx, r11
    mov r11, r13
    mov r13, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r10
    ; jump lift_safe_0_
    jmp lift_safe_0_

Bool_67176_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67201
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rdx, [rax + 24]
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab67200
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67200:
    mov r9, [r8 + 24]
    jmp lab67202

lab67201:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rdx, [rax + 24]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab67202:
    ; let x0: Bool = False();
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    mov r15, 5
    ; substitute (a0 !-> a0)(i !-> i)(j !-> j)(m !-> m)(n !-> n)(x0 !-> x0);
    ; #move variables
    mov rcx, r11
    mov r11, r13
    mov r13, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r10
    ; jump lift_safe_0_
    jmp lift_safe_0_

lift_safe_0_:
    ; substitute (n !-> n)(i !-> i)(j !-> j)(m !-> m)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov r12, rax
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    ; new a3: Bool = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67214
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab67215

lab67214:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67212
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67205
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67203
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67204

lab67203:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67204:

lab67205:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67208
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67206
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67207

lab67206:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67207:

lab67208:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67211
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67209
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67210

lab67209:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67210:

lab67211:
    jmp lab67213

lab67212:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67213:

lab67215:
    ; #load tag
    lea r13, [rel Bool_67216]
    ; new a4: Bool = (a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67228
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab67229

lab67228:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67226
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67219
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67217
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67218

lab67217:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67218:

lab67219:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67222
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67220
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67221

lab67220:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67221:

lab67222:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67225
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67223
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67224

lab67223:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67224:

lab67225:
    jmp lab67227

lab67226:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67227:

lab67229:
    ; #load tag
    lea r13, [rel Bool_67230]
    ; substitute (j !-> j)(i !-> i)(n !-> n)(m !-> m)(a4 !-> a4);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a5: _Cont = (n, m, a4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67242
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67243

lab67242:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67240
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67233
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67231
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67232

lab67231:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67232:

lab67233:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67236
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67234
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67235

lab67234:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67235:

lab67236:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67239
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67237
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67238

lab67237:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67238:

lab67239:
    jmp lab67241

lab67240:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67241:

lab67243:
    ; #load tag
    lea r9, [rel _Cont_67244]
    ; x5 <- i - j;
    mov r11, rdi
    sub r11, rdx
    ; substitute (x5 !-> x5)(a5 !-> a5);
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    mov rdx, r11
    ; jump abs_i_
    jmp abs_i_

_Cont_67244:

_Cont_67244_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab67246
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab67245
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67245:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab67247

lab67246:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab67247:
    ; substitute (m !-> m)(n !-> n)(x4 !-> x4)(a4 !-> a4);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a7: _Cont = (x4, a4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67259
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67260

lab67259:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67257
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67250
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67248
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67249

lab67248:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67249:

lab67250:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67253
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67251
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67252

lab67251:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67252:

lab67253:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67256
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67254
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67255

lab67254:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67255:

lab67256:
    jmp lab67258

lab67257:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67258:

lab67260:
    ; #load tag
    lea r9, [rel _Cont_67261]
    ; x7 <- m - n;
    mov r11, rdx
    sub r11, rdi
    ; substitute (x7 !-> x7)(a7 !-> a7);
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    mov rdx, r11
    ; jump abs_i_
    jmp abs_i_

_Cont_67261:

_Cont_67261_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab67263
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab67262
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67262:
    mov rdi, [rsi + 40]
    jmp lab67264

lab67263:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab67264:
    ; substitute (x4 !-> x4)(x6 !-> x6)(a4 !-> a4);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump eq_
    jmp eq_

Bool_67230:
    jmp near Bool_67230_True
    jmp near Bool_67230_False

Bool_67230_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67266
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab67265
    ; ####increment refcount
    add qword [rax + 0], 1

lab67265:
    jmp lab67267

lab67266:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab67267:
    ; let x3: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x3 !-> x3)(a3 !-> a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_67230_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67269
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab67268
    ; ####increment refcount
    add qword [rax + 0], 1

lab67268:
    jmp lab67270

lab67269:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab67270:
    ; let x3: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x3 !-> x3)(a3 !-> a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_67216:
    jmp near Bool_67216_True
    jmp near Bool_67216_False

Bool_67216_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67273
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab67271
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67271:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67272
    ; ####increment refcount
    add qword [rax + 0], 1

lab67272:
    jmp lab67274

lab67273:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab67274:
    ; let x2: Bool = True();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x2 !-> x2)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump and_
    jmp and_

Bool_67216_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67277
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab67275
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67275:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67276
    ; ####increment refcount
    add qword [rax + 0], 1

lab67276:
    jmp lab67278

lab67277:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab67278:
    ; let x2: Bool = False();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x2 !-> x2)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump and_
    jmp and_

queens_:
    ; new x0: Fun[Assign, Fun[Assign, Bool]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Assign_Fun_Assign_Bool_67279]
    ; substitute (n !-> n)(n0 !-> n)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov r11, rdi
    mov rdi, rdx
    mov r10, rsi
    ; invoke a0 CSP
    jmp r11

Fun_Assign_Fun_Assign_Bool_67279:

Fun_Assign_Fun_Assign_Bool_67279_Ap:
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Assign_Bool_67280:

Fun_Assign_Bool_67280_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab67283
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab67281
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67281:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab67282
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67282:
    jmp lab67284

lab67283:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab67284:
    ; jump safe_
    jmp safe_

mk_map_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_Assign_67285]
    add rcx, r9
    jmp rcx

List_List_Assign_67285:
    jmp near List_List_Assign_67285_Nil
    jmp near List_List_Assign_67285_Cons

List_List_Assign_67285_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab67288
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab67286
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab67287

lab67286:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab67287:

lab67288:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_Assign_67285_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67291
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67289
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67289:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67290
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67290:
    jmp lab67292

lab67291:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67292:
    ; substitute (f0 !-> f)(l !-> l)(a0 !-> a0)(ls0 !-> ls0)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab67293
    ; ####increment refcount
    add qword [rax + 0], 1

lab67293:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Node[List[Assign]] = (a0, ls0, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67305
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67306

lab67305:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67303
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67296
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67294
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67295

lab67294:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67295:

lab67296:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67299
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67297
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67298

lab67297:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67298:

lab67299:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67302
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67300
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67301

lab67300:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67301:

lab67302:
    jmp lab67304

lab67303:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67304:

lab67306:
    ; #load tag
    lea r9, [rel Node_List_Assign_67307]
    ; substitute (l !-> l)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Node_List_Assign_67307:

Node_List_Assign_67307_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67311
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab67308
    ; ####increment refcount
    add qword [r12 + 0], 1

lab67308:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab67309
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67309:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab67310
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67310:
    jmp lab67312

lab67311:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab67312:
    ; substitute (f !-> f)(ls0 !-> ls0)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[List[Assign]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67324
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab67325

lab67324:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67322
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67315
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67313
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67314

lab67313:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67314:

lab67315:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67318
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67316
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67317

lab67316:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67317:

lab67318:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67321
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67319
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67320

lab67319:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67320:

lab67321:
    jmp lab67323

lab67322:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67323:

lab67325:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[List[Assign]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67337
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67338

lab67337:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67335
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67328
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67326
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67327

lab67326:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67327:

lab67328:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67331
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67329
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67330

lab67329:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67330:

lab67331:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67334
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67332
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67333

lab67332:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67333:

lab67334:
    jmp lab67336

lab67335:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67336:

lab67338:
    ; #load tag
    lea r9, [rel List_Node_List_Assign_67339]
    ; jump mk_map_
    jmp mk_map_

List_Node_List_Assign_67339:
    jmp near List_Node_List_Assign_67339_Nil
    jmp near List_Node_List_Assign_67339_Cons

List_Node_List_Assign_67339_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67342
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab67340
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67340:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67341
    ; ####increment refcount
    add qword [rax + 0], 1

lab67341:
    jmp lab67343

lab67342:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab67343:
    ; let x1: List[Node[List[Assign]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_List_Assign_67339_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67346
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67344
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67344:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67345
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67345:
    jmp lab67347

lab67346:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67347:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[List[Assign]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67359
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67360

lab67359:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67357
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67350
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67348
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67349

lab67348:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67349:

lab67350:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67353
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67351
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67352

lab67351:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67352:

lab67353:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67356
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67354
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67355

lab67354:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67355:

lab67356:
    jmp lab67358

lab67357:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67358:

lab67360:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

mk_init_tree_:
    ; substitute (f !-> f)(x3 !-> x)(a0 !-> a0)(x !-> x);
    ; #share x
    cmp rsi, 0
    je lab67361
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67361:
    ; #move variables
    mov r10, rsi
    mov r11, rdi
    ; new a1: List[Node[List[Assign]]] = (a0, x)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67373
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67374

lab67373:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67371
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67364
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67362
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67363

lab67362:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67363:

lab67364:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67367
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67365
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67366

lab67365:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67366:

lab67367:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67370
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67368
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67369

lab67368:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67369:

lab67370:
    jmp lab67372

lab67371:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67372:

lab67374:
    ; #load tag
    lea r9, [rel List_Node_List_Assign_67375]
    ; substitute (f0 !-> f)(x3 !-> x3)(a1 !-> a1)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab67376
    ; ####increment refcount
    add qword [rax + 0], 1

lab67376:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; new x1: Fun[List[Assign], Node[List[Assign]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67388
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab67389

lab67388:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67386
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67379
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67377
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67378

lab67377:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67378:

lab67379:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67382
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67380
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67381

lab67380:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67381:

lab67382:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67385
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67383
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67384

lab67383:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67384:

lab67385:
    jmp lab67387

lab67386:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67387:

lab67389:
    ; #load tag
    lea r11, [rel Fun_List_Assign_Node_List_Assign_67390]
    ; new a3: List[List[Assign]] = (a1, x1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67402
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67403

lab67402:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67400
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67393
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67391
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67392

lab67391:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67392:

lab67393:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67396
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67394
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67395

lab67394:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67395:

lab67396:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67399
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67397
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67398

lab67397:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67398:

lab67399:
    jmp lab67401

lab67400:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67401:

lab67403:
    ; #load tag
    lea r9, [rel List_List_Assign_67404]
    ; substitute (x3 !-> x3)(a3 !-> a3)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

List_List_Assign_67404:
    jmp near List_List_Assign_67404_Nil
    jmp near List_List_Assign_67404_Cons

List_List_Assign_67404_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67407
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab67405
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67405:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67406
    ; ####increment refcount
    add qword [rax + 0], 1

lab67406:
    jmp lab67408

lab67407:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab67408:
    ; let x2: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x1 !-> x1)(x2 !-> x2)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump mk_map_
    jmp mk_map_

List_List_Assign_67404_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67411
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67409
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67409:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67410
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67410:
    jmp lab67412

lab67411:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67412:
    ; substitute (x1 !-> x1)(a1 !-> a1)(a5 !-> a5)(as1 !-> as1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x2: List[List[Assign]] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67424
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67425

lab67424:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67422
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67415
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67413
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67414

lab67413:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67414:

lab67415:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67418
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67416
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67417

lab67416:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67417:

lab67418:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67421
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67419
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67420

lab67419:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67420:

lab67421:
    jmp lab67423

lab67422:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67423:

lab67425:
    ; #load tag
    mov r9, 5
    ; substitute (x1 !-> x1)(x2 !-> x2)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump mk_map_
    jmp mk_map_

Fun_List_Assign_Node_List_Assign_67390:

Fun_List_Assign_Node_List_Assign_67390_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67427
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab67426
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67426:
    jmp lab67428

lab67427:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab67428:
    ; substitute (f !-> f)(y !-> y)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump mk_init_tree_
    jmp mk_init_tree_

List_Node_List_Assign_67375:
    jmp near List_Node_List_Assign_67375_Nil
    jmp near List_Node_List_Assign_67375_Cons

List_Node_List_Assign_67375_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67431
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab67429
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67429:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67430
    ; ####increment refcount
    add qword [rax + 0], 1

lab67430:
    jmp lab67432

lab67431:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab67432:
    ; let x0: List[Node[List[Assign]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x !-> x)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    jmp r9

List_Node_List_Assign_67375_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67435
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67433
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67433:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67434
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67434:
    jmp lab67436

lab67435:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67436:
    ; substitute (x !-> x)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Node[List[Assign]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67448
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67449

lab67448:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67446
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67439
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67437
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67438

lab67437:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67438:

lab67439:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67442
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67440
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67441

lab67440:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67441:

lab67442:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67445
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67443
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67444

lab67443:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67444:

lab67445:
    jmp lab67447

lab67446:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67447:

lab67449:
    ; #load tag
    mov r9, 5
    ; substitute (x !-> x)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    jmp r9

mk_lscomp1_:
    ; substitute (a0 !-> a0)(ss !-> ss)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_67450]
    add rcx, r9
    jmp rcx

List_i64_67450:
    jmp near List_i64_67450_Nil
    jmp near List_i64_67450_Cons

List_i64_67450_Nil:
    ; substitute (a0 !-> a0);
    ; #erase ss
    cmp rsi, 0
    je lab67453
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab67451
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab67452

lab67451:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab67452:

lab67453:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_67450_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67455
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67454
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67454:
    mov r9, [r8 + 40]
    jmp lab67456

lab67455:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab67456:
    ; substitute (ss1 !-> ss)(ss !-> ss)(j !-> j)(t1 !-> t1)(a0 !-> a0);
    ; #share ss
    cmp rsi, 0
    je lab67457
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67457:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rax, rsi
    mov rdx, rdi
    ; new a2: _Cont = (ss, j, t1, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67469
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67470

lab67469:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67467
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67460
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67458
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67459

lab67458:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67459:

lab67460:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67463
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67461
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67462

lab67461:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67462:

lab67463:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67466
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67464
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67465

lab67464:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67465:

lab67466:
    jmp lab67468

lab67467:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67468:

lab67470:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67482
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab67483

lab67482:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67480
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67473
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67471
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67472

lab67471:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67472:

lab67473:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67476
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67474
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67475

lab67474:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67475:

lab67476:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67479
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67477
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67478

lab67477:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67478:

lab67479:
    jmp lab67481

lab67480:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67481:

lab67483:
    ; #load tag
    lea rdi, [rel _Cont_67484]
    ; jump max_level_
    jmp max_level_

_Cont_67484:

_Cont_67484_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab67488
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab67485
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67485:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab67486
    ; ####increment refcount
    add qword [r12 + 0], 1

lab67486:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab67487
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67487:
    mov r9, [r8 + 24]
    jmp lab67489

lab67488:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab67489:
    ; lit x3 <- 1;
    mov r15, 1
    ; x4 <- x2 + x3;
    mov rcx, rdx
    add rcx, r15
    mov [rsp + 2024], rcx
    ; substitute (a0 !-> a0)(ss !-> ss)(t1 !-> t1)(x4 !-> x4)(j !-> j);
    ; #move variables
    mov rdx, r13
    mov r13, r9
    mov r8, r10
    mov r9, r11
    mov rax, r12
    mov r11, [rsp + 2024]
    ; let x1: Assign = Assign(x4, j);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67501
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab67502

lab67501:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67499
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67492
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67490
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67491

lab67490:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67491:

lab67492:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67495
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67493
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67494

lab67493:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67494:

lab67495:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67498
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67496
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67497

lab67496:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67497:

lab67498:
    jmp lab67500

lab67499:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67500:

lab67502:
    ; #load tag
    mov r11, 0
    ; substitute (a0 !-> a0)(ss !-> ss)(t1 !-> t1)(x1 !-> x1)(ss0 !-> ss);
    ; #share ss
    cmp rsi, 0
    je lab67503
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67503:
    ; #move variables
    mov r12, rsi
    mov r13, rdi
    ; let x0: List[Assign] = Cons(x1, ss0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67515
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab67516

lab67515:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67513
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67506
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67504
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67505

lab67504:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67505:

lab67506:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67509
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67507
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67508

lab67507:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67508:

lab67509:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67512
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67510
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67511

lab67510:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67511:

lab67512:
    jmp lab67514

lab67513:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67514:

lab67516:
    ; #load tag
    mov r11, 5
    ; substitute (t1 !-> t1)(ss !-> ss)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a3: List[List[Assign]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67528
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67529

lab67528:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67526
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67519
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67517
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67518

lab67517:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67518:

lab67519:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67522
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67520
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67521

lab67520:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67521:

lab67522:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67525
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67523
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67524

lab67523:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67524:

lab67525:
    jmp lab67527

lab67526:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67527:

lab67529:
    ; #load tag
    lea r9, [rel List_List_Assign_67530]
    ; jump mk_lscomp1_
    jmp mk_lscomp1_

List_List_Assign_67530:
    jmp near List_List_Assign_67530_Nil
    jmp near List_List_Assign_67530_Cons

List_List_Assign_67530_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67533
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab67531
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67531:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67532
    ; ####increment refcount
    add qword [rax + 0], 1

lab67532:
    jmp lab67534

lab67533:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab67534:
    ; let x5: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x5 !-> x5)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Assign_67530_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67537
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67535
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67535:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67536
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67536:
    jmp lab67538

lab67537:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67538:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x5: List[List[Assign]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67550
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67551

lab67550:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67548
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67541
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67539
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67540

lab67539:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67540:

lab67541:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67544
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67542
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67543

lab67542:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67543:

lab67544:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67547
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67545
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67546

lab67545:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67546:

lab67547:
    jmp lab67549

lab67548:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67549:

lab67551:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x5 !-> x5)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

mk_tree_:
    ; substitute (a0 !-> a0)(csp !-> csp);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #if there is only one clause, we can just fall through

CSP_67552:

CSP_67552_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab67554
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab67553
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67553:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab67555

lab67554:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab67555:
    ; substitute (a0 !-> a0)(vars !-> vars)(vals !-> vals);
    ; #erase rel
    cmp r10, 0
    je lab67558
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab67556
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab67557

lab67556:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab67557:

lab67558:
    ; new next: Fun[List[Assign], List[List[Assign]]] = (vars, vals)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov qword [rbx + 48], 0
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67570
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab67571

lab67570:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67568
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67561
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67559
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67560

lab67559:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67560:

lab67561:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67564
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67562
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67563

lab67562:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67563:

lab67564:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67567
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67565
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67566

lab67565:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67566:

lab67567:
    jmp lab67569

lab67568:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67569:

lab67571:
    ; #load tag
    lea rdi, [rel Fun_List_Assign_List_List_Assign_67572]
    ; let x3: List[Assign] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (next !-> next)(x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump mk_init_tree_
    jmp mk_init_tree_

Fun_List_Assign_List_List_Assign_67572:

Fun_List_Assign_List_List_Assign_67572_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67573
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    jmp lab67574

lab67573:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]

lab67574:
    ; substitute (ss0 !-> ss)(a1 !-> a1)(vars !-> vars)(vals !-> vals)(ss !-> ss);
    ; #share ss
    cmp rax, 0
    je lab67575
    ; ####increment refcount
    add qword [rax + 0], 1

lab67575:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    ; new a2: _Cont = (a1, vars, vals, ss)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67587
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67588

lab67587:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67585
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67578
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67576
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67577

lab67576:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67577:

lab67578:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67581
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67579
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67580

lab67579:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67580:

lab67581:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67584
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67582
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67583

lab67582:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67583:

lab67584:
    jmp lab67586

lab67585:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67586:

lab67588:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67600
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab67601

lab67600:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67598
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67591
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67589
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67590

lab67589:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67590:

lab67591:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67594
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67592
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67593

lab67592:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67593:

lab67594:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67597
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67595
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67596

lab67595:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67596:

lab67597:
    jmp lab67599

lab67598:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67599:

lab67601:
    ; #load tag
    lea rdi, [rel _Cont_67602]
    ; jump max_level_
    jmp max_level_

_Cont_67602:

_Cont_67602_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab67605
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab67603
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67603:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab67604
    ; ####increment refcount
    add qword [r12 + 0], 1

lab67604:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    jmp lab67606

lab67605:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]

lab67606:
    ; if x0 < vars \{ ... \}
    cmp rdx, r9
    jl lab67607
    ; substitute (a1 !-> a1);
    ; #erase ss
    cmp r12, 0
    je lab67610
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab67608
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab67609

lab67608:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab67609:

lab67610:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a1 Nil
    add rdx, 0
    jmp rdx

lab67607:
    ; substitute (vals !-> vals)(a1 !-> a1)(ss !-> ss);
    ; #move variables
    mov rdx, r11
    mov r8, r12
    mov r9, r13
    ; new a3: List[i64] = (a1, ss)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67622
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab67623

lab67622:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67620
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67613
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67611
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67612

lab67611:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67612:

lab67613:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67616
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67614
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67615

lab67614:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67615:

lab67616:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67619
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67617
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67618

lab67617:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67618:

lab67619:
    jmp lab67621

lab67620:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67621:

lab67623:
    ; #load tag
    lea rdi, [rel List_i64_67624]
    ; lit x2 <- 1;
    mov r9, 1
    ; substitute (x2 !-> x2)(vals !-> vals)(a3 !-> a3);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_67624:
    jmp near List_i64_67624_Nil
    jmp near List_i64_67624_Cons

List_i64_67624_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67627
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab67625
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67625:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67626
    ; ####increment refcount
    add qword [rax + 0], 1

lab67626:
    jmp lab67628

lab67627:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab67628:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x1 !-> x1)(ss !-> ss)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump mk_lscomp1_
    jmp mk_lscomp1_

List_i64_67624_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67631
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67629
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67629:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67630
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67630:
    jmp lab67632

lab67631:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67632:
    ; substitute (ss !-> ss)(a1 !-> a1)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x1: List[i64] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67644
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67645

lab67644:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67642
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67635
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67633
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67634

lab67633:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67634:

lab67635:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67638
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67636
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67637

lab67636:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67637:

lab67638:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67641
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67639
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67640

lab67639:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67640:

lab67641:
    jmp lab67643

lab67642:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67643:

lab67645:
    ; #load tag
    mov r9, 5
    ; substitute (x1 !-> x1)(ss !-> ss)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump mk_lscomp1_
    jmp mk_lscomp1_

ear_inc_filter_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_67646]
    add rcx, r9
    jmp rcx

List_Assign_67646:
    jmp near List_Assign_67646_Nil
    jmp near List_Assign_67646_Cons

List_Assign_67646_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab67649
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab67647
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab67648

lab67647:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab67648:

lab67649:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Assign_67646_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67652
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67650
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67650:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67651
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67651:
    jmp lab67653

lab67652:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67653:
    ; substitute (f0 !-> f)(a4 !-> a)(a !-> a)(as !-> as)(f !-> f)(a0 !-> a0);
    ; #share a
    cmp r8, 0
    je lab67654
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67654:
    ; #share f
    cmp rax, 0
    je lab67655
    ; ####increment refcount
    add qword [rax + 0], 1

lab67655:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rsi, r8
    mov rdi, r9
    ; new a2: Bool = (a, as, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67667
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab67668

lab67667:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67665
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67658
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67656
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67657

lab67656:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67657:

lab67658:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67661
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67659
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67660

lab67659:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67660:

lab67661:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67664
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67662
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67663

lab67662:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67663:

lab67664:
    jmp lab67666

lab67665:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67666:

lab67668:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67680
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67681

lab67680:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67678
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67671
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67669
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67670

lab67669:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67670:

lab67671:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67674
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67672
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67673

lab67672:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67673:

lab67674:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67677
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67675
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67676

lab67675:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67676:

lab67677:
    jmp lab67679

lab67678:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67679:

lab67681:
    ; #load tag
    lea r9, [rel Bool_67682]
    ; substitute (a4 !-> a4)(a2 !-> a2)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Bool_67682:
    jmp near Bool_67682_True
    jmp near Bool_67682_False

Bool_67682_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67687
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67683
    ; ####increment refcount
    add qword [rax + 0], 1

lab67683:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab67684
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67684:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab67685
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67685:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab67686
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67686:
    jmp lab67688

lab67687:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab67688:
    ; substitute (f !-> f)(as !-> as)(a !-> a)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a1: List[Assign] = (a, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67700
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67701

lab67700:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67698
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67691
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67689
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67690

lab67689:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67690:

lab67691:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67694
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67692
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67693

lab67692:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67693:

lab67694:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67697
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67695
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67696

lab67695:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67696:

lab67697:
    jmp lab67699

lab67698:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67699:

lab67701:
    ; #load tag
    lea r9, [rel List_Assign_67702]
    ; jump ear_inc_filter_
    jmp ear_inc_filter_

List_Assign_67702:
    jmp near List_Assign_67702_Nil
    jmp near List_Assign_67702_Cons

List_Assign_67702_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67705
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab67703
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67703:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67704
    ; ####increment refcount
    add qword [rax + 0], 1

lab67704:
    jmp lab67706

lab67705:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab67706:
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (a !-> a)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Assign_67702_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67709
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67707
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67707:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67708
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67708:
    jmp lab67710

lab67709:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67710:
    ; substitute (a0 !-> a0)(a !-> a)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Assign] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67722
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67723

lab67722:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67720
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67713
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67711
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67712

lab67711:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67712:

lab67713:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67716
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67714
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67715

lab67714:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67715:

lab67716:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67719
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67717
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67718

lab67717:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67718:

lab67719:
    jmp lab67721

lab67720:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67721:

lab67723:
    ; #load tag
    mov r9, 5
    ; substitute (a !-> a)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_67682_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67728
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67724
    ; ####increment refcount
    add qword [rax + 0], 1

lab67724:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab67725
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67725:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab67726
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67726:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab67727
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67727:
    jmp lab67729

lab67728:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab67729:
    ; substitute (f !-> f)(as !-> as)(a0 !-> a0);
    ; #erase a
    cmp rax, 0
    je lab67732
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab67730
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab67731

lab67730:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab67731:

lab67732:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump ear_inc_filter_
    jmp ear_inc_filter_

earliest_inconsistency_:
    ; substitute (a0 !-> a0)(aas !-> aas)(csp !-> csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #if there is only one clause, we can just fall through

CSP_67733:

CSP_67733_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67735
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab67734
    ; ####increment refcount
    add qword [r12 + 0], 1

lab67734:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    jmp lab67736

lab67735:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]

lab67736:
    ; substitute (a0 !-> a0)(rel !-> rel)(aas !-> aas);
    ; #move variables
    mov r8, rsi
    mov r9, rdi
    mov rsi, r12
    mov rdi, r13
    ; switch aas \{ ... \};
    lea rcx, [rel List_Assign_67737]
    add rcx, r9
    jmp rcx

List_Assign_67737:
    jmp near List_Assign_67737_Nil
    jmp near List_Assign_67737_Cons

List_Assign_67737_Nil:
    ; substitute (a0 !-> a0);
    ; #erase rel
    cmp rsi, 0
    je lab67740
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab67738
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab67739

lab67738:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab67739:

lab67740:
    ; invoke a0 None
    add rdx, 0
    jmp rdx

List_Assign_67737_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67743
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67741
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67741:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67742
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67742:
    jmp lab67744

lab67743:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67744:
    ; substitute (a0 !-> a0)(as_ !-> as_)(a9 !-> a)(a !-> a)(rel !-> rel);
    ; #share a
    cmp r8, 0
    je lab67745
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67745:
    ; #move variables
    mov r12, rsi
    mov r13, rdi
    mov rsi, r10
    mov r10, r8
    mov rdi, r11
    mov r11, r9
    ; new x0: Fun[Assign, Bool] = (a, rel)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67757
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab67758

lab67757:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67755
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67748
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67746
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67747

lab67746:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67747:

lab67748:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67751
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67749
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67750

lab67749:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67750:

lab67751:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67754
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67752
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67753

lab67752:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67753:

lab67754:
    jmp lab67756

lab67755:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67756:

lab67758:
    ; #load tag
    lea r11, [rel Fun_Assign_Bool_67759]
    ; substitute (as_ !-> as_)(a0 !-> a0)(a9 !-> a9)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; new a5: List[Assign] = (a0, a9, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67771
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab67772

lab67771:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67769
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67762
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67760
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67761

lab67760:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67761:

lab67762:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67765
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67763
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67764

lab67763:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67764:

lab67765:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67768
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67766
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67767

lab67766:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67767:

lab67768:
    jmp lab67770

lab67769:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67770:

lab67772:
    ; #load tag
    lea rdi, [rel List_Assign_67773]
    ; jump reverse_
    jmp reverse_

List_Assign_67773:
    jmp near List_Assign_67773_Nil
    jmp near List_Assign_67773_Cons

List_Assign_67773_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67777
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab67774
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67774:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab67775
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67775:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab67776
    ; ####increment refcount
    add qword [rax + 0], 1

lab67776:
    jmp lab67778

lab67777:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab67778:
    ; let x1: List[Assign] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a9 !-> a9)(a0 !-> a0)(x0 !-> x0)(x1 !-> x1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_earliest_inconsistency_0_
    jmp lift_earliest_inconsistency_0_

List_Assign_67773_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67782
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab67779
    ; ####increment refcount
    add qword [r12 + 0], 1

lab67779:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab67780
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67780:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab67781
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67781:
    jmp lab67783

lab67782:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab67783:
    ; substitute (x0 !-> x0)(a9 !-> a9)(a0 !-> a0)(a8 !-> a8)(as0 !-> as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x1: List[Assign] = Cons(a8, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67795
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab67796

lab67795:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67793
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67786
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67784
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67785

lab67784:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67785:

lab67786:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67789
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67787
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67788

lab67787:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67788:

lab67789:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67792
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67790
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67791

lab67790:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67791:

lab67792:
    jmp lab67794

lab67793:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67794:

lab67796:
    ; #load tag
    mov r11, 5
    ; substitute (a9 !-> a9)(a0 !-> a0)(x0 !-> x0)(x1 !-> x1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_earliest_inconsistency_0_
    jmp lift_earliest_inconsistency_0_

Fun_Assign_Bool_67759:

Fun_Assign_Bool_67759_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67799
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67797
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67797:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67798
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67798:
    jmp lab67800

lab67799:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67800:
    ; substitute (x !-> x)(rel !-> rel)(a !-> a)(a3 !-> a3);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; new a4: Bool = (a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67812
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab67813

lab67812:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67810
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67803
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67801
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67802

lab67801:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67802:

lab67803:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67806
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67804
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67805

lab67804:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67805:

lab67806:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67809
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67807
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67808

lab67807:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67808:

lab67809:
    jmp lab67811

lab67810:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67811:

lab67813:
    ; #load tag
    lea r11, [rel Bool_67814]
    ; substitute (a !-> a)(rel !-> rel)(x !-> x)(a4 !-> a4);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; let a7: Fun[Assign, Bool] = Ap(x, a4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67826
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67827

lab67826:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67824
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67817
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67815
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67816

lab67815:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67816:

lab67817:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67820
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67818
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67819

lab67818:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67819:

lab67820:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67823
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67821
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67822

lab67821:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67822:

lab67823:
    jmp lab67825

lab67824:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67825:

lab67827:
    ; #load tag
    mov r9, 0
    ; substitute (a !-> a)(a7 !-> a7)(rel !-> rel);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke rel Ap
    jmp r9

Bool_67814:
    jmp near Bool_67814_True
    jmp near Bool_67814_False

Bool_67814_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67829
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab67828
    ; ####increment refcount
    add qword [rax + 0], 1

lab67828:
    jmp lab67830

lab67829:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab67830:
    ; let x5: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x5 !-> x5)(a3 !-> a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_67814_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67832
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab67831
    ; ####increment refcount
    add qword [rax + 0], 1

lab67831:
    jmp lab67833

lab67832:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab67833:
    ; let x5: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x5 !-> x5)(a3 !-> a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

lift_earliest_inconsistency_0_:
    ; substitute (x1 !-> x1)(x0 !-> x0)(a0 !-> a0)(a !-> a);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a6: List[Assign] = (a0, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67845
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67846

lab67845:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67843
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67836
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67834
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67835

lab67834:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67835:

lab67836:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67839
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67837
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67838

lab67837:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67838:

lab67839:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67842
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67840
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67841

lab67840:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67841:

lab67842:
    jmp lab67844

lab67843:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67844:

lab67846:
    ; #load tag
    lea r9, [rel List_Assign_67847]
    ; substitute (x0 !-> x0)(x1 !-> x1)(a6 !-> a6);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump ear_inc_filter_
    jmp ear_inc_filter_

List_Assign_67847:
    jmp near List_Assign_67847_Nil
    jmp near List_Assign_67847_Cons

List_Assign_67847_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67850
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab67848
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67848:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67849
    ; ####increment refcount
    add qword [rax + 0], 1

lab67849:
    jmp lab67851

lab67850:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab67851:
    ; substitute (a0 !-> a0);
    ; #erase a
    cmp rsi, 0
    je lab67854
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab67852
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab67853

lab67852:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab67853:

lab67854:
    ; invoke a0 None
    add rdx, 0
    jmp rdx

List_Assign_67847_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67857
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67855
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67855:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67856
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67856:
    jmp lab67858

lab67857:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67858:
    ; substitute (a !-> a)(b !-> b)(a0 !-> a0);
    ; #erase bs_
    cmp rsi, 0
    je lab67861
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab67859
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab67860

lab67859:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab67860:

lab67861:
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r10
    mov rdx, r11
    ; new a1: _Cont = (b, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67873
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab67874

lab67873:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67871
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67864
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67862
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67863

lab67862:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67863:

lab67864:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67867
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67865
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67866

lab67865:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67866:

lab67867:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67870
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67868
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67869

lab67868:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67869:

lab67870:
    jmp lab67872

lab67871:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67872:

lab67874:
    ; #load tag
    lea rdi, [rel _Cont_67875]
    ; jump level_
    jmp level_

_Cont_67875:

_Cont_67875_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab67878
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab67876
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67876:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab67877
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67877:
    jmp lab67879

lab67878:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab67879:
    ; substitute (b !-> b)(x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; new a2: _Cont = (x3, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67891
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab67892

lab67891:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67889
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67882
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67880
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67881

lab67880:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67881:

lab67882:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67885
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67883
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67884

lab67883:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67884:

lab67885:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67888
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67886
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67887

lab67886:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67887:

lab67888:
    jmp lab67890

lab67889:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67890:

lab67892:
    ; #load tag
    lea rdi, [rel _Cont_67893]
    ; jump level_
    jmp level_

_Cont_67893:

_Cont_67893_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab67895
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab67894
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67894:
    mov rdi, [rsi + 40]
    jmp lab67896

lab67895:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab67896:
    ; substitute (a0 !-> a0)(x3 !-> x3)(x4 !-> x4);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r8
    ; let x2: Pair[i64, i64] = Tup(x3, x4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov qword [rbx + 48], 0
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67908
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab67909

lab67908:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67906
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67899
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67897
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67898

lab67897:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67898:

lab67899:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67902
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67900
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67901

lab67900:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67901:

lab67902:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67905
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67903
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67904

lab67903:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67904:

lab67905:
    jmp lab67907

lab67906:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67907:

lab67909:
    ; #load tag
    mov rdi, 0
    ; substitute (x2 !-> x2)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Some
    add rdi, 5
    jmp rdi

label_map_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Node_List_Assign_67910]
    add rcx, r9
    jmp rcx

List_Node_List_Assign_67910:
    jmp near List_Node_List_Assign_67910_Nil
    jmp near List_Node_List_Assign_67910_Cons

List_Node_List_Assign_67910_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab67913
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab67911
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab67912

lab67911:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab67912:

lab67913:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_List_Assign_67910_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67916
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67914
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67914:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67915
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67915:
    jmp lab67917

lab67916:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67917:
    ; substitute (f0 !-> f)(l !-> l)(a0 !-> a0)(ls0 !-> ls0)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab67918
    ; ####increment refcount
    add qword [rax + 0], 1

lab67918:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Node[Pair[List[Assign], Option[Pair[i64, i64]]]] = (a0, ls0, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67930
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67931

lab67930:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67928
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67921
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67919
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67920

lab67919:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67920:

lab67921:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67924
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67922
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67923

lab67922:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67923:

lab67924:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67927
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67925
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67926

lab67925:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67926:

lab67927:
    jmp lab67929

lab67928:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67929:

lab67931:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_Option_Pair_i64_i64_67932]
    ; substitute (l !-> l)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Node_Pair_List_Assign_Option_Pair_i64_i64_67932:

Node_Pair_List_Assign_Option_Pair_i64_i64_67932_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67936
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab67933
    ; ####increment refcount
    add qword [r12 + 0], 1

lab67933:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab67934
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67934:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab67935
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67935:
    jmp lab67937

lab67936:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab67937:
    ; substitute (f !-> f)(ls0 !-> ls0)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], Option[Pair[i64, i64]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67949
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab67950

lab67949:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67947
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67940
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67938
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67939

lab67938:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67939:

lab67940:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67943
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67941
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67942

lab67941:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67942:

lab67943:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67946
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67944
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67945

lab67944:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67945:

lab67946:
    jmp lab67948

lab67947:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67948:

lab67950:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67962
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67963

lab67962:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67960
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67953
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67951
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67952

lab67951:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67952:

lab67953:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67956
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67954
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67955

lab67954:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67955:

lab67956:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67959
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67957
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67958

lab67957:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67958:

lab67959:
    jmp lab67961

lab67960:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67961:

lab67963:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_Option_Pair_i64_i64_67964]
    ; jump label_map_
    jmp label_map_

List_Node_Pair_List_Assign_Option_Pair_i64_i64_67964:
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_67964_Nil
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_67964_Cons

List_Node_Pair_List_Assign_Option_Pair_i64_i64_67964_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab67967
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab67965
    ; ####increment refcount
    add qword [rsi + 0], 1

lab67965:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab67966
    ; ####increment refcount
    add qword [rax + 0], 1

lab67966:
    jmp lab67968

lab67967:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab67968:
    ; let x1: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_Option_Pair_i64_i64_67964_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67971
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67969
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67969:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67970
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67970:
    jmp lab67972

lab67971:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67972:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab67984
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab67985

lab67984:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab67982
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67975
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67973
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67974

lab67973:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67974:

lab67975:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67978
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67976
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67977

lab67976:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67977:

lab67978:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab67981
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67979
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67980

lab67979:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67980:

lab67981:
    jmp lab67983

lab67982:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab67983:

lab67985:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

label_map_tree_:
    ; substitute (f !-> f)(a0 !-> a0)(n !-> n);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch n \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_List_Assign_67986:

Node_List_Assign_67986_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab67989
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab67987
    ; ####increment refcount
    add qword [r10 + 0], 1

lab67987:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab67988
    ; ####increment refcount
    add qword [r8 + 0], 1

lab67988:
    jmp lab67990

lab67989:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab67990:
    ; substitute (f0 !-> f)(l !-> l)(a0 !-> a0)(c !-> c)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab67991
    ; ####increment refcount
    add qword [rax + 0], 1

lab67991:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Pair[List[Assign], Option[Pair[i64, i64]]] = (a0, c, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68003
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68004

lab68003:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68001
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab67994
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67992
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67993

lab67992:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67993:

lab67994:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab67997
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67995
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67996

lab67995:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67996:

lab67997:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68000
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab67998
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab67999

lab67998:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab67999:

lab68000:
    jmp lab68002

lab68001:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68002:

lab68004:
    ; #load tag
    lea r9, [rel Pair_List_Assign_Option_Pair_i64_i64_68005]
    ; substitute (l !-> l)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Pair_List_Assign_Option_Pair_i64_i64_68005:

Pair_List_Assign_Option_Pair_i64_i64_68005_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68009
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab68006
    ; ####increment refcount
    add qword [r12 + 0], 1

lab68006:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab68007
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68007:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab68008
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68008:
    jmp lab68010

lab68009:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab68010:
    ; substitute (f !-> f)(c !-> c)(a0 !-> a0)(a5 !-> a5)(b0 !-> b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[List[Assign], Option[Pair[i64, i64]]] = Tup(a5, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68022
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab68023

lab68022:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68020
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68013
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68011
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68012

lab68011:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68012:

lab68013:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68016
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68014
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68015

lab68014:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68015:

lab68016:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68019
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68017
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68018

lab68017:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68018:

lab68019:
    jmp lab68021

lab68020:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68021:

lab68023:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68035
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68036

lab68035:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68033
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68026
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68024
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68025

lab68024:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68025:

lab68026:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68029
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68027
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68028

lab68027:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68028:

lab68029:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68032
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68030
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68031

lab68030:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68031:

lab68032:
    jmp lab68034

lab68033:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68034:

lab68036:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_Option_Pair_i64_i64_68037]
    ; substitute (a2 !-> a2)(c !-> c)(f !-> f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new x2: Fun[Node[List[Assign]], Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68049
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68050

lab68049:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68047
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68040
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68038
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68039

lab68038:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68039:

lab68040:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68043
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68041
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68042

lab68041:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68042:

lab68043:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68046
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68044
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68045

lab68044:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68045:

lab68046:
    jmp lab68048

lab68047:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68048:

lab68050:
    ; #load tag
    lea r9, [rel Fun_Node_List_Assign_Node_Pair_List_Assign_Option_Pair_i64_i64_68051]
    ; substitute (x2 !-> x2)(c !-> c)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump label_map_
    jmp label_map_

Fun_Node_List_Assign_Node_Pair_List_Assign_Option_Pair_i64_i64_68051:

Fun_Node_List_Assign_Node_Pair_List_Assign_Option_Pair_i64_i64_68051_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68053
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab68052
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68052:
    jmp lab68054

lab68053:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab68054:
    ; substitute (f !-> f)(x !-> x)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump label_map_tree_
    jmp label_map_tree_

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68037:
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68037_Nil
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68037_Cons

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68037_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68057
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab68055
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68055:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68056
    ; ####increment refcount
    add qword [rax + 0], 1

lab68056:
    jmp lab68058

lab68057:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab68058:
    ; let x1: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    jmp r9

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68037_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68061
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68059
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68059:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68060
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68060:
    jmp lab68062

lab68061:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68062:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68074
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68075

lab68074:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68072
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68065
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68063
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68064

lab68063:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68064:

lab68065:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68068
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68066
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68067

lab68066:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68067:

lab68068:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68071
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68069
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68070

lab68069:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68070:

lab68071:
    jmp lab68073

lab68072:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68073:

lab68075:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    jmp r9

label_inconsistencies_:
    ; substitute (a0 !-> a0)(t !-> t)(csp !-> csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new f2: Fun[List[Assign], Pair[List[Assign], Option[Pair[i64, i64]]]] = (csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68087
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68088

lab68087:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68085
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68078
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68076
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68077

lab68076:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68077:

lab68078:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68081
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68079
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68080

lab68079:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68080:

lab68081:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68084
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68082
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68083

lab68082:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68083:

lab68084:
    jmp lab68086

lab68085:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68086:

lab68088:
    ; #load tag
    lea r9, [rel Fun_List_Assign_Pair_List_Assign_Option_Pair_i64_i64_68089]
    ; substitute (f2 !-> f2)(t !-> t)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump label_map_tree_
    jmp label_map_tree_

Fun_List_Assign_Pair_List_Assign_Option_Pair_i64_i64_68089:

Fun_List_Assign_Pair_List_Assign_Option_Pair_i64_i64_68089_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68091
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab68090
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68090:
    jmp lab68092

lab68091:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab68092:
    ; substitute (s0 !-> s)(csp !-> csp)(a1 !-> a1)(s !-> s);
    ; #share s
    cmp rax, 0
    je lab68093
    ; ####increment refcount
    add qword [rax + 0], 1

lab68093:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a2: Option[Pair[i64, i64]] = (a1, s)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68105
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68106

lab68105:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68103
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68096
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68094
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68095

lab68094:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68095:

lab68096:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68099
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68097
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68098

lab68097:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68098:

lab68099:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68102
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68100
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68101

lab68100:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68101:

lab68102:
    jmp lab68104

lab68103:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68104:

lab68106:
    ; #load tag
    lea r9, [rel Option_Pair_i64_i64_68107]
    ; substitute (csp !-> csp)(s0 !-> s0)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump earliest_inconsistency_
    jmp earliest_inconsistency_

Option_Pair_i64_i64_68107:
    jmp near Option_Pair_i64_i64_68107_None
    jmp near Option_Pair_i64_i64_68107_Some

Option_Pair_i64_i64_68107_None:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68110
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab68108
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68108:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68109
    ; ####increment refcount
    add qword [rax + 0], 1

lab68109:
    jmp lab68111

lab68110:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab68111:
    ; let x0: Option[Pair[i64, i64]] = None();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (s !-> s)(x0 !-> x0)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Tup
    jmp r9

Option_Pair_i64_i64_68107_Some:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab68114
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab68112
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68112:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab68113
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68113:
    jmp lab68115

lab68114:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab68115:
    ; substitute (s !-> s)(a1 !-> a1)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: Option[Pair[i64, i64]] = Some(a3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68127
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68128

lab68127:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68125
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68118
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68116
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68117

lab68116:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68117:

lab68118:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68121
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68119
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68120

lab68119:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68120:

lab68121:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68124
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68122
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68123

lab68122:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68123:

lab68124:
    jmp lab68126

lab68125:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68126:

lab68128:
    ; #load tag
    mov r9, 5
    ; substitute (s !-> s)(x0 !-> x0)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a1 Tup
    jmp r9

filter_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_Option_Pair_i64_i64_68129]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68129:
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68129_Nil
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68129_Cons

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68129_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab68132
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab68130
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab68131

lab68130:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab68131:

lab68132:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68129_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68135
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68133
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68133:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68134
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68134:
    jmp lab68136

lab68135:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68136:
    ; substitute (f0 !-> f)(p0 !-> p)(p !-> p)(ps !-> ps)(f !-> f)(a0 !-> a0);
    ; #share f
    cmp rax, 0
    je lab68137
    ; ####increment refcount
    add qword [rax + 0], 1

lab68137:
    ; #share p
    cmp r8, 0
    je lab68138
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68138:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rsi, r8
    mov rdi, r9
    ; new a2: Bool = (p, ps, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68150
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab68151

lab68150:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68148
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68141
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68139
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68140

lab68139:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68140:

lab68141:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68144
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68142
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68143

lab68142:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68143:

lab68144:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68147
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68145
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68146

lab68145:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68146:

lab68147:
    jmp lab68149

lab68148:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68149:

lab68151:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68163
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68164

lab68163:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68161
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68154
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68152
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68153

lab68152:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68153:

lab68154:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68157
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68155
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68156

lab68155:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68156:

lab68157:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68160
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68158
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68159

lab68158:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68159:

lab68160:
    jmp lab68162

lab68161:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68162:

lab68164:
    ; #load tag
    lea r9, [rel Bool_68165]
    ; substitute (p0 !-> p0)(a2 !-> a2)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Bool_68165:
    jmp near Bool_68165_True
    jmp near Bool_68165_False

Bool_68165_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68170
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68166
    ; ####increment refcount
    add qword [rax + 0], 1

lab68166:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab68167
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68167:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab68168
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68168:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab68169
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68169:
    jmp lab68171

lab68170:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab68171:
    ; substitute (f !-> f)(ps !-> ps)(p !-> p)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a1: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = (p, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68183
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68184

lab68183:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68181
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68174
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68172
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68173

lab68172:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68173:

lab68174:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68177
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68175
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68176

lab68175:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68176:

lab68177:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68180
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68178
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68179

lab68178:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68179:

lab68180:
    jmp lab68182

lab68181:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68182:

lab68184:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_Option_Pair_i64_i64_68185]
    ; jump filter_
    jmp filter_

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68185:
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68185_Nil
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68185_Cons

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68185_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68188
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab68186
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68186:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68187
    ; ####increment refcount
    add qword [rax + 0], 1

lab68187:
    jmp lab68189

lab68188:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab68189:
    ; let x0: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (p !-> p)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68185_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68192
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68190
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68190:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68191
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68191:
    jmp lab68193

lab68192:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68193:
    ; substitute (a0 !-> a0)(p !-> p)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68205
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68206

lab68205:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68203
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68196
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68194
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68195

lab68194:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68195:

lab68196:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68199
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68197
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68198

lab68197:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68198:

lab68199:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68202
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68200
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68201

lab68200:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68201:

lab68202:
    jmp lab68204

lab68203:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68204:

lab68206:
    ; #load tag
    mov r9, 5
    ; substitute (p !-> p)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_68165_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68211
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68207
    ; ####increment refcount
    add qword [rax + 0], 1

lab68207:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab68208
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68208:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab68209
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68209:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab68210
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68210:
    jmp lab68212

lab68211:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab68212:
    ; substitute (f !-> f)(ps !-> ps)(a0 !-> a0);
    ; #erase p
    cmp rax, 0
    je lab68215
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab68213
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab68214

lab68213:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab68214:

lab68215:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump filter_
    jmp filter_

lab_:
    ; substitute (a0 !-> a0)(n !-> n);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch n \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_Pair_List_Assign_Option_Pair_i64_i64_68216:

Node_Pair_List_Assign_Option_Pair_i64_i64_68216_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab68219
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab68217
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68217:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab68218
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68218:
    jmp lab68220

lab68219:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab68220:
    ; substitute (a0 !-> a0)(l !-> l);
    ; #erase ch
    cmp r8, 0
    je lab68223
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab68221
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab68222

lab68221:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab68222:

lab68223:
    ; switch l \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_List_Assign_Option_Pair_i64_i64_68224:

Pair_List_Assign_Option_Pair_i64_i64_68224_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab68227
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab68225
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68225:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab68226
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68226:
    jmp lab68228

lab68227:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab68228:
    ; substitute (a1 !-> a1)(b0 !-> b0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Tup
    jmp r9

solv_map2_:
    ; substitute (f !-> f)(a0 !-> a0)(n !-> n);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch n \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_Option_Pair_i64_i64_68229]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68229:
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68229_Nil
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68229_Cons

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68229_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab68232
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab68230
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab68231

lab68230:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab68231:

lab68232:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68229_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68235
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68233
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68233:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68234
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68234:
    jmp lab68236

lab68235:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68236:
    ; substitute (f0 !-> f)(p !-> p)(a0 !-> a0)(ps !-> ps)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab68237
    ; ####increment refcount
    add qword [rax + 0], 1

lab68237:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Node[Pair[List[Assign], Option[Pair[i64, i64]]]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68249
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68250

lab68249:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68247
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68240
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68238
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68239

lab68238:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68239:

lab68240:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68243
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68241
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68242

lab68241:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68242:

lab68243:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68246
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68244
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68245

lab68244:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68245:

lab68246:
    jmp lab68248

lab68247:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68248:

lab68250:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_Option_Pair_i64_i64_68251]
    ; substitute (p !-> p)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Node_Pair_List_Assign_Option_Pair_i64_i64_68251:

Node_Pair_List_Assign_Option_Pair_i64_i64_68251_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68255
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab68252
    ; ####increment refcount
    add qword [r12 + 0], 1

lab68252:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab68253
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68253:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab68254
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68254:
    jmp lab68256

lab68255:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab68256:
    ; substitute (f !-> f)(ps !-> ps)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], Option[Pair[i64, i64]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68268
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab68269

lab68268:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68266
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68259
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68257
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68258

lab68257:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68258:

lab68259:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68262
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68260
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68261

lab68260:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68261:

lab68262:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68265
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68263
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68264

lab68263:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68264:

lab68265:
    jmp lab68267

lab68266:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68267:

lab68269:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68281
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68282

lab68281:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68279
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68272
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68270
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68271

lab68270:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68271:

lab68272:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68275
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68273
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68274

lab68273:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68274:

lab68275:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68278
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68276
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68277

lab68276:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68277:

lab68278:
    jmp lab68280

lab68279:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68280:

lab68282:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_Option_Pair_i64_i64_68283]
    ; jump solv_map2_
    jmp solv_map2_

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68283:
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68283_Nil
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68283_Cons

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68283_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68286
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab68284
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68284:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68285
    ; ####increment refcount
    add qword [rax + 0], 1

lab68285:
    jmp lab68287

lab68286:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab68287:
    ; let x1: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68283_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68290
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68288
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68288:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68289
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68289:
    jmp lab68291

lab68290:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68291:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68303
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68304

lab68303:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68301
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68294
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68292
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68293

lab68292:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68293:

lab68294:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68297
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68295
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68296

lab68295:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68296:

lab68297:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68300
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68298
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68299

lab68298:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68299:

lab68300:
    jmp lab68302

lab68301:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68302:

lab68304:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

fold_tree_:
    ; substitute (f !-> f)(a0 !-> a0)(n !-> n);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch n \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_Pair_List_Assign_Option_Pair_i64_i64_68305:

Node_Pair_List_Assign_Option_Pair_i64_i64_68305_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68308
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68306
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68306:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68307
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68307:
    jmp lab68309

lab68308:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68309:
    ; substitute (f0 !-> f)(c !-> c)(l !-> l)(a0 !-> a0)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab68310
    ; ####increment refcount
    add qword [rax + 0], 1

lab68310:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; new a1: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = (l, a0, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68322
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68323

lab68322:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68320
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68313
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68311
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68312

lab68311:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68312:

lab68313:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68316
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68314
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68315

lab68314:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68315:

lab68316:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68319
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68317
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68318

lab68317:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68318:

lab68319:
    jmp lab68321

lab68320:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68321:

lab68323:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_Option_Pair_i64_i64_68324]
    ; substitute (a1 !-> a1)(c !-> c)(f0 !-> f0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new x1: Fun[Node[Pair[List[Assign], Option[Pair[i64, i64]]]], Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = (f0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68336
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68337

lab68336:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68334
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68327
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68325
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68326

lab68325:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68326:

lab68327:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68330
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68328
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68329

lab68328:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68329:

lab68330:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68333
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68331
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68332

lab68331:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68332:

lab68333:
    jmp lab68335

lab68334:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68335:

lab68337:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_Option_Pair_i64_i64_Node_Pair_List_Assign_Option_Pair_i64_i64_68338]
    ; substitute (x1 !-> x1)(c !-> c)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump solv_map2_
    jmp solv_map2_

Fun_Node_Pair_List_Assign_Option_Pair_i64_i64_Node_Pair_List_Assign_Option_Pair_i64_i64_68338:

Fun_Node_Pair_List_Assign_Option_Pair_i64_i64_Node_Pair_List_Assign_Option_Pair_i64_i64_68338_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68340
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab68339
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68339:
    jmp lab68341

lab68340:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab68341:
    ; substitute (f0 !-> f0)(x !-> x)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump fold_tree_
    jmp fold_tree_

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68324:
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68324_Nil
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68324_Cons

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68324_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68345
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab68342
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68342:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab68343
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68343:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab68344
    ; ####increment refcount
    add qword [rax + 0], 1

lab68344:
    jmp lab68346

lab68345:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab68346:
    ; let x0: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 !-> a0)(f !-> f)(l !-> l)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_fold_tree_0_
    jmp lift_fold_tree_0_

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68324_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68350
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab68347
    ; ####increment refcount
    add qword [r12 + 0], 1

lab68347:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab68348
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68348:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab68349
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68349:
    jmp lab68351

lab68350:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab68351:
    ; substitute (f !-> f)(a0 !-> a0)(l !-> l)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68363
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab68364

lab68363:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68361
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68354
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68352
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68353

lab68352:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68353:

lab68354:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68357
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68355
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68356

lab68355:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68356:

lab68357:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68360
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68358
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68359

lab68358:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68359:

lab68360:
    jmp lab68362

lab68361:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68362:

lab68364:
    ; #load tag
    mov r11, 5
    ; substitute (a0 !-> a0)(f !-> f)(l !-> l)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_fold_tree_0_
    jmp lift_fold_tree_0_

lift_fold_tree_0_:
    ; substitute (l !-> l)(f !-> f)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; let a3: Fun[List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]], Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = Ap(x0, a0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68376
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68377

lab68376:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68374
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68367
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68365
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68366

lab68365:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68366:

lab68367:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68370
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68368
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68369

lab68368:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68369:

lab68370:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68373
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68371
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68372

lab68371:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68372:

lab68373:
    jmp lab68375

lab68374:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68375:

lab68377:
    ; #load tag
    mov r9, 0
    ; substitute (l !-> l)(a3 !-> a3)(f !-> f);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke f Ap
    jmp r9

filter_tree_:
    ; substitute (a0 !-> a0)(t !-> t)(p !-> p);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new f1: Fun[Pair[List[Assign], Option[Pair[i64, i64]]], Fun[List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]], Node[Pair[List[Assign], Option[Pair[i64, i64]]]]]] = (p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68389
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68390

lab68389:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68387
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68380
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68378
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68379

lab68378:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68379:

lab68380:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68383
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68381
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68382

lab68381:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68382:

lab68383:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68386
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68384
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68385

lab68384:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68385:

lab68386:
    jmp lab68388

lab68387:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68388:

lab68390:
    ; #load tag
    lea r9, [rel Fun_Pair_List_Assign_Option_Pair_i64_i64_Fun_List_Node_Pair_List_Assign_Option_Pair_i64_i64_Node_Pair_List_Assign_Option_Pair_i64_i64_68391]
    ; substitute (f1 !-> f1)(t !-> t)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump fold_tree_
    jmp fold_tree_

Fun_Pair_List_Assign_Option_Pair_i64_i64_Fun_List_Node_Pair_List_Assign_Option_Pair_i64_i64_Node_Pair_List_Assign_Option_Pair_i64_i64_68391:

Fun_Pair_List_Assign_Option_Pair_i64_i64_Fun_List_Node_Pair_List_Assign_Option_Pair_i64_i64_Node_Pair_List_Assign_Option_Pair_i64_i64_68391_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68393
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab68392
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68392:
    jmp lab68394

lab68393:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab68394:
    ; substitute (a !-> a)(p !-> p)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_List_Node_Pair_List_Assign_Option_Pair_i64_i64_Node_Pair_List_Assign_Option_Pair_i64_i64_68395:

Fun_List_Node_Pair_List_Assign_Option_Pair_i64_i64_Node_Pair_List_Assign_Option_Pair_i64_i64_68395_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68398
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68396
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68396:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68397
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68397:
    jmp lab68399

lab68398:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68399:
    ; substitute (cs !-> cs)(p !-> p)(a !-> a)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a3: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = (a, a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68411
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68412

lab68411:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68409
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68402
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68400
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68401

lab68400:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68401:

lab68402:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68405
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68403
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68404

lab68403:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68404:

lab68405:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68408
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68406
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68407

lab68406:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68407:

lab68408:
    jmp lab68410

lab68409:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68410:

lab68412:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_Option_Pair_i64_i64_68413]
    ; substitute (cs !-> cs)(a3 !-> a3)(p !-> p);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new x1: Fun[Node[Pair[List[Assign], Option[Pair[i64, i64]]]], Bool] = (p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68425
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68426

lab68425:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68423
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68416
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68414
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68415

lab68414:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68415:

lab68416:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68419
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68417
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68418

lab68417:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68418:

lab68419:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68422
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68420
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68421

lab68420:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68421:

lab68422:
    jmp lab68424

lab68423:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68424:

lab68426:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_Option_Pair_i64_i64_Bool_68427]
    ; substitute (x1 !-> x1)(cs !-> cs)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump filter_
    jmp filter_

Fun_Node_Pair_List_Assign_Option_Pair_i64_i64_Bool_68427:

Fun_Node_Pair_List_Assign_Option_Pair_i64_i64_Bool_68427_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68429
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab68428
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68428:
    jmp lab68430

lab68429:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab68430:
    ; new a5: Pair[List[Assign], Option[Pair[i64, i64]]] = (a4, p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68442
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab68443

lab68442:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68440
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68433
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68431
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68432

lab68431:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68432:

lab68433:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68436
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68434
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68435

lab68434:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68435:

lab68436:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68439
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68437
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68438

lab68437:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68438:

lab68439:
    jmp lab68441

lab68440:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68441:

lab68443:
    ; #load tag
    lea rdi, [rel Pair_List_Assign_Option_Pair_i64_i64_68444]
    ; jump lab_
    jmp lab_

Pair_List_Assign_Option_Pair_i64_i64_68444:

Pair_List_Assign_Option_Pair_i64_i64_68444_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68447
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68445
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68445:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68446
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68446:
    jmp lab68448

lab68447:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68448:
    ; substitute (p !-> p)(a4 !-> a4)(a7 !-> a7)(b0 !-> b0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x2: Pair[List[Assign], Option[Pair[i64, i64]]] = Tup(a7, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68460
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68461

lab68460:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68458
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68451
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68449
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68450

lab68449:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68450:

lab68451:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68454
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68452
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68453

lab68452:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68453:

lab68454:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68457
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68455
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68456

lab68455:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68456:

lab68457:
    jmp lab68459

lab68458:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68459:

lab68461:
    ; #load tag
    mov r9, 0
    ; substitute (x2 !-> x2)(a4 !-> a4)(p !-> p);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke p Ap
    jmp r9

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68413:
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68413_Nil
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68413_Cons

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68413_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68464
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab68462
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68462:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68463
    ; ####increment refcount
    add qword [rax + 0], 1

lab68463:
    jmp lab68465

lab68464:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab68465:
    ; let x0: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (a !-> a)(x0 !-> x0)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a2 Node
    jmp r9

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68413_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68468
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68466
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68466:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68467
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68467:
    jmp lab68469

lab68468:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68469:
    ; substitute (a2 !-> a2)(a !-> a)(a6 !-> a6)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], Option[Pair[i64, i64]]]]] = Cons(a6, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68481
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68482

lab68481:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68479
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68472
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68470
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68471

lab68470:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68471:

lab68472:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68475
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68473
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68474

lab68473:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68474:

lab68475:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68478
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68476
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68477

lab68476:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68477:

lab68478:
    jmp lab68480

lab68479:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68480:

lab68482:
    ; #load tag
    mov r9, 5
    ; substitute (a !-> a)(x0 !-> x0)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a2 Node
    jmp r9

prune_:
    ; substitute (a0 !-> a0)(t !-> t)(p !-> p);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new x0: Fun[Pair[List[Assign], Option[Pair[i64, i64]]], Bool] = (p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68494
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68495

lab68494:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68492
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68485
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68483
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68484

lab68483:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68484:

lab68485:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68488
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68486
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68487

lab68486:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68487:

lab68488:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68491
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68489
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68490

lab68489:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68490:

lab68491:
    jmp lab68493

lab68492:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68493:

lab68495:
    ; #load tag
    lea r9, [rel Fun_Pair_List_Assign_Option_Pair_i64_i64_Bool_68496]
    ; substitute (x0 !-> x0)(t !-> t)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump filter_tree_
    jmp filter_tree_

Fun_Pair_List_Assign_Option_Pair_i64_i64_Bool_68496:

Fun_Pair_List_Assign_Option_Pair_i64_i64_Bool_68496_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68498
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab68497
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68497:
    jmp lab68499

lab68498:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab68499:
    ; substitute (x !-> x)(p !-> p)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a2: Bool = (a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68511
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68512

lab68511:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68509
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68502
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68500
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68501

lab68500:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68501:

lab68502:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68505
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68503
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68504

lab68503:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68504:

lab68505:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68508
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68506
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68507

lab68506:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68507:

lab68508:
    jmp lab68510

lab68509:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68510:

lab68512:
    ; #load tag
    lea r9, [rel Bool_68513]
    ; substitute (x !-> x)(a2 !-> a2)(p !-> p);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke p Ap
    jmp r9

Bool_68513:
    jmp near Bool_68513_True
    jmp near Bool_68513_False

Bool_68513_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68515
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab68514
    ; ####increment refcount
    add qword [rax + 0], 1

lab68514:
    jmp lab68516

lab68515:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab68516:
    ; let x1: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 !-> x1)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_68513_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68518
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab68517
    ; ####increment refcount
    add qword [rax + 0], 1

lab68517:
    jmp lab68519

lab68518:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab68519:
    ; let x1: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x1 !-> x1)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

fst_:
    ; substitute (a0 !-> a0)(p !-> p);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch p \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_List_Assign_Option_Pair_i64_i64_68520:

Pair_List_Assign_Option_Pair_i64_i64_68520_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab68523
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab68521
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68521:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab68522
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68522:
    jmp lab68524

lab68523:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab68524:
    ; substitute (a0 !-> a0)(ls !-> ls);
    ; #erase o
    cmp r8, 0
    je lab68527
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab68525
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab68526

lab68525:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab68526:

lab68527:
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_68528]
    add rcx, rdi
    jmp rcx

List_Assign_68528:
    jmp near List_Assign_68528_Nil
    jmp near List_Assign_68528_Cons

List_Assign_68528_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Assign_68528_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab68531
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab68529
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68529:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab68530
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68530:
    jmp lab68532

lab68531:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab68532:
    ; substitute (a1 !-> a1)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

snd_:
    ; substitute (a0 !-> a0)(p !-> p);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch p \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_List_Assign_Option_Pair_i64_i64_68533:

Pair_List_Assign_Option_Pair_i64_i64_68533_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab68536
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab68534
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68534:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab68535
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68535:
    jmp lab68537

lab68536:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab68537:
    ; substitute (a0 !-> a0)(p0 !-> p0);
    ; #erase ls
    cmp rsi, 0
    je lab68540
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab68538
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab68539

lab68538:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab68539:

lab68540:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; switch p0 \{ ... \};
    lea rcx, [rel Option_Pair_i64_i64_68541]
    add rcx, rdi
    jmp rcx

Option_Pair_i64_i64_68541:
    jmp near Option_Pair_i64_i64_68541_None
    jmp near Option_Pair_i64_i64_68541_Some

Option_Pair_i64_i64_68541_None:
    ; invoke a0 None
    add rdx, 0
    jmp rdx

Option_Pair_i64_i64_68541_Some:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab68543
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab68542
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68542:
    jmp lab68544

lab68543:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab68544:
    ; substitute (a1 !-> a1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Some
    add rdi, 5
    jmp rdi

option_eq_:
    ; substitute (a0 !-> a0)(o2 !-> o2)(o1 !-> o1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch o1 \{ ... \};
    lea rcx, [rel Option_Pair_i64_i64_68545]
    add rcx, r9
    jmp rcx

Option_Pair_i64_i64_68545:
    jmp near Option_Pair_i64_i64_68545_None
    jmp near Option_Pair_i64_i64_68545_Some

Option_Pair_i64_i64_68545_None:
    ; switch o2 \{ ... \};
    lea rcx, [rel Option_Pair_i64_i64_68546]
    add rcx, rdi
    jmp rcx

Option_Pair_i64_i64_68546:
    jmp near Option_Pair_i64_i64_68546_None
    jmp near Option_Pair_i64_i64_68546_Some

Option_Pair_i64_i64_68546_None:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

Option_Pair_i64_i64_68546_Some:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab68548
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab68547
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68547:
    jmp lab68549

lab68548:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab68549:
    ; substitute (a0 !-> a0);
    ; #erase p
    cmp rsi, 0
    je lab68552
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab68550
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab68551

lab68550:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab68551:

lab68552:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

Option_Pair_i64_i64_68545_Some:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68554
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab68553
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68553:
    jmp lab68555

lab68554:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab68555:
    ; substitute (a0 !-> a0)(p1 !-> p1)(o2 !-> o2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch o2 \{ ... \};
    lea rcx, [rel Option_Pair_i64_i64_68556]
    add rcx, r9
    jmp rcx

Option_Pair_i64_i64_68556:
    jmp near Option_Pair_i64_i64_68556_None
    jmp near Option_Pair_i64_i64_68556_Some

Option_Pair_i64_i64_68556_None:
    ; substitute (a0 !-> a0);
    ; #erase p1
    cmp rsi, 0
    je lab68559
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab68557
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab68558

lab68557:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab68558:

lab68559:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

Option_Pair_i64_i64_68556_Some:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68561
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab68560
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68560:
    jmp lab68562

lab68561:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab68562:
    ; substitute (a0 !-> a0)(p2 !-> p2)(p1 !-> p1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch p1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_i64_i64_68563:

Pair_i64_i64_68563_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68564
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    jmp lab68565

lab68564:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]

lab68565:
    ; substitute (a0 !-> a0)(i12 !-> i12)(i11 !-> i11)(p2 !-> p2);
    ; #move variables
    mov r10, rsi
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch p2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_i64_i64_68566:

Pair_i64_i64_68566_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab68567
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]
    jmp lab68568

lab68567:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]

lab68568:
    ; substitute (i21 !-> i21)(i11 !-> i11)(i12 !-> i12)(a0 !-> a0)(i22 !-> i22);
    ; #move variables
    mov r10, rax
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Bool = (i12, a0, i22)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68580
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68581

lab68580:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68578
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68571
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68569
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68570

lab68569:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68570:

lab68571:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68574
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68572
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68573

lab68572:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68573:

lab68574:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68577
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68575
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68576

lab68575:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68576:

lab68577:
    jmp lab68579

lab68578:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68579:

lab68581:
    ; #load tag
    lea r9, [rel Bool_68582]
    ; substitute (i11 !-> i11)(i21 !-> i21)(a1 !-> a1);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump eq_
    jmp eq_

Bool_68582:
    jmp near Bool_68582_True
    jmp near Bool_68582_False

Bool_68582_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68584
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab68583
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68583:
    mov rdx, [rax + 24]
    jmp lab68585

lab68584:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]

lab68585:
    ; let x0: Bool = True();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 !-> a0)(i12 !-> i12)(i22 !-> i22)(x0 !-> x0);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump lift_option_eq_0_
    jmp lift_option_eq_0_

Bool_68582_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68587
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab68586
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68586:
    mov rdx, [rax + 24]
    jmp lab68588

lab68587:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]

lab68588:
    ; let x0: Bool = False();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 5
    ; substitute (a0 !-> a0)(i12 !-> i12)(i22 !-> i22)(x0 !-> x0);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump lift_option_eq_0_
    jmp lift_option_eq_0_

lift_option_eq_0_:
    ; substitute (i22 !-> i22)(i12 !-> i12)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov r8, rax
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a2: Bool = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68600
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68601

lab68600:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68598
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68591
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68589
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68590

lab68589:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68590:

lab68591:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68594
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68592
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68593

lab68592:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68593:

lab68594:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68597
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68595
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68596

lab68595:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68596:

lab68597:
    jmp lab68599

lab68598:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68599:

lab68601:
    ; #load tag
    lea r9, [rel Bool_68602]
    ; substitute (i12 !-> i12)(i22 !-> i22)(a2 !-> a2);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump eq_
    jmp eq_

Bool_68602:
    jmp near Bool_68602_True
    jmp near Bool_68602_False

Bool_68602_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68605
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab68603
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68603:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68604
    ; ####increment refcount
    add qword [rax + 0], 1

lab68604:
    jmp lab68606

lab68605:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab68606:
    ; let x1: Bool = True();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump and_
    jmp and_

Bool_68602_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68609
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab68607
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68607:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68608
    ; ####increment refcount
    add qword [rax + 0], 1

lab68608:
    jmp lab68610

lab68609:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab68610:
    ; let x1: Bool = False();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump and_
    jmp and_

solv_map_tree_:
    ; substitute (f !-> f)(a0 !-> a0)(n !-> n);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch n \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_Pair_List_Assign_Option_Pair_i64_i64_68611:

Node_Pair_List_Assign_Option_Pair_i64_i64_68611_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68614
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68612
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68612:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68613
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68613:
    jmp lab68615

lab68614:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68615:
    ; substitute (f0 !-> f)(l !-> l)(a0 !-> a0)(c !-> c)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab68616
    ; ####increment refcount
    add qword [rax + 0], 1

lab68616:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: List[Assign] = (a0, c, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68628
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68629

lab68628:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68626
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68619
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68617
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68618

lab68617:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68618:

lab68619:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68622
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68620
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68621

lab68620:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68621:

lab68622:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68625
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68623
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68624

lab68623:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68624:

lab68625:
    jmp lab68627

lab68626:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68627:

lab68629:
    ; #load tag
    lea r9, [rel List_Assign_68630]
    ; substitute (l !-> l)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

List_Assign_68630:
    jmp near List_Assign_68630_Nil
    jmp near List_Assign_68630_Cons

List_Assign_68630_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68634
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab68631
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68631:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab68632
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68632:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab68633
    ; ####increment refcount
    add qword [rax + 0], 1

lab68633:
    jmp lab68635

lab68634:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab68635:
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; jump lift_solv_map_tree_0_
    jmp lift_solv_map_tree_0_

List_Assign_68630_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68639
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab68636
    ; ####increment refcount
    add qword [r12 + 0], 1

lab68636:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab68637
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68637:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab68638
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68638:
    jmp lab68640

lab68639:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab68640:
    ; substitute (f !-> f)(c !-> c)(a0 !-> a0)(a5 !-> a5)(as1 !-> as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Assign] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68652
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab68653

lab68652:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68650
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68643
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68641
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68642

lab68641:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68642:

lab68643:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68646
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68644
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68645

lab68644:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68645:

lab68646:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68649
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68647
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68648

lab68647:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68648:

lab68649:
    jmp lab68651

lab68650:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68651:

lab68653:
    ; #load tag
    mov r11, 5
    ; substitute (a0 !-> a0)(c !-> c)(f !-> f)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_solv_map_tree_0_
    jmp lift_solv_map_tree_0_

lift_solv_map_tree_0_:
    ; substitute (f !-> f)(c !-> c)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a2: List[Node[List[Assign]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68665
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68666

lab68665:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68663
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68656
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68654
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68655

lab68654:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68655:

lab68656:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68659
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68657
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68658

lab68657:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68658:

lab68659:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68662
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68660
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68661

lab68660:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68661:

lab68662:
    jmp lab68664

lab68663:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68664:

lab68666:
    ; #load tag
    lea r9, [rel List_Node_List_Assign_68667]
    ; substitute (a2 !-> a2)(c !-> c)(f !-> f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new x2: Fun[Node[Pair[List[Assign], Option[Pair[i64, i64]]]], Node[List[Assign]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68679
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68680

lab68679:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68677
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68670
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68668
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68669

lab68668:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68669:

lab68670:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68673
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68671
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68672

lab68671:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68672:

lab68673:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68676
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68674
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68675

lab68674:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68675:

lab68676:
    jmp lab68678

lab68677:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68678:

lab68680:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_Option_Pair_i64_i64_Node_List_Assign_68681]
    ; substitute (x2 !-> x2)(c !-> c)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump solv_map_
    jmp solv_map_

Fun_Node_Pair_List_Assign_Option_Pair_i64_i64_Node_List_Assign_68681:

Fun_Node_Pair_List_Assign_Option_Pair_i64_i64_Node_List_Assign_68681_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68683
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab68682
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68682:
    jmp lab68684

lab68683:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab68684:
    ; substitute (f !-> f)(x !-> x)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump solv_map_tree_
    jmp solv_map_tree_

List_Node_List_Assign_68667:
    jmp near List_Node_List_Assign_68667_Nil
    jmp near List_Node_List_Assign_68667_Cons

List_Node_List_Assign_68667_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68687
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab68685
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68685:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68686
    ; ####increment refcount
    add qword [rax + 0], 1

lab68686:
    jmp lab68688

lab68687:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab68688:
    ; let x1: List[Node[List[Assign]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    jmp r9

List_Node_List_Assign_68667_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68691
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68689
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68689:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68690
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68690:
    jmp lab68692

lab68691:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68692:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[List[Assign]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68704
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68705

lab68704:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68702
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68695
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68693
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68694

lab68693:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68694:

lab68695:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68698
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68696
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68697

lab68696:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68697:

lab68698:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68701
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68699
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68700

lab68699:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68700:

lab68701:
    jmp lab68703

lab68702:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68703:

lab68705:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    jmp r9

solv_map_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_Option_Pair_i64_i64_68706]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68706:
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68706_Nil
    jmp near List_Node_Pair_List_Assign_Option_Pair_i64_i64_68706_Cons

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68706_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab68709
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab68707
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab68708

lab68707:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab68708:

lab68709:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_Option_Pair_i64_i64_68706_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68712
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68710
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68710:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68711
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68711:
    jmp lab68713

lab68712:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68713:
    ; substitute (f0 !-> f)(l !-> l)(a0 !-> a0)(ls0 !-> ls0)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab68714
    ; ####increment refcount
    add qword [rax + 0], 1

lab68714:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Node[List[Assign]] = (a0, ls0, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68726
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68727

lab68726:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68724
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68717
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68715
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68716

lab68715:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68716:

lab68717:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68720
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68718
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68719

lab68718:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68719:

lab68720:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68723
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68721
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68722

lab68721:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68722:

lab68723:
    jmp lab68725

lab68724:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68725:

lab68727:
    ; #load tag
    lea r9, [rel Node_List_Assign_68728]
    ; substitute (l !-> l)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Node_List_Assign_68728:

Node_List_Assign_68728_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68732
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab68729
    ; ####increment refcount
    add qword [r12 + 0], 1

lab68729:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab68730
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68730:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab68731
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68731:
    jmp lab68733

lab68732:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab68733:
    ; substitute (f !-> f)(ls0 !-> ls0)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[List[Assign]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68745
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab68746

lab68745:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68743
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68736
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68734
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68735

lab68734:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68735:

lab68736:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68739
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68737
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68738

lab68737:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68738:

lab68739:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68742
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68740
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68741

lab68740:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68741:

lab68742:
    jmp lab68744

lab68743:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68744:

lab68746:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[List[Assign]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68758
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68759

lab68758:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68756
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68749
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68747
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68748

lab68747:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68748:

lab68749:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68752
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68750
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68751

lab68750:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68751:

lab68752:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68755
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68753
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68754

lab68753:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68754:

lab68755:
    jmp lab68757

lab68756:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68757:

lab68759:
    ; #load tag
    lea r9, [rel List_Node_List_Assign_68760]
    ; jump solv_map_
    jmp solv_map_

List_Node_List_Assign_68760:
    jmp near List_Node_List_Assign_68760_Nil
    jmp near List_Node_List_Assign_68760_Cons

List_Node_List_Assign_68760_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68763
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab68761
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68761:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68762
    ; ####increment refcount
    add qword [rax + 0], 1

lab68762:
    jmp lab68764

lab68763:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab68764:
    ; let x1: List[Node[List[Assign]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_List_Assign_68760_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68767
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68765
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68765:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68766
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68766:
    jmp lab68768

lab68767:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68768:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[List[Assign]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68780
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68781

lab68780:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68778
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68771
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68769
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68770

lab68769:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68770:

lab68771:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68774
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68772
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68773

lab68772:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68773:

lab68774:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68777
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68775
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68776

lab68775:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68776:

lab68777:
    jmp lab68779

lab68778:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68779:

lab68781:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

concat_2_:
    ; substitute (a0 !-> a0)(l2 !-> l2)(l1 !-> l1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch l1 \{ ... \};
    lea rcx, [rel List_List_Assign_68782]
    add rcx, r9
    jmp rcx

List_List_Assign_68782:
    jmp near List_List_Assign_68782_Nil
    jmp near List_List_Assign_68782_Cons

List_List_Assign_68782_Nil:
    ; switch l2 \{ ... \};
    lea rcx, [rel List_List_Assign_68783]
    add rcx, rdi
    jmp rcx

List_List_Assign_68783:
    jmp near List_List_Assign_68783_Nil
    jmp near List_List_Assign_68783_Cons

List_List_Assign_68783_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_Assign_68783_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab68786
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab68784
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68784:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab68785
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68785:
    jmp lab68787

lab68786:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab68787:
    ; substitute (a2 !-> a2)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Assign_68782_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68790
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68788
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68788:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68789
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68789:
    jmp lab68791

lab68790:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68791:
    ; substitute (l1s !-> l1s)(l2 !-> l2)(l10 !-> l10)(a0 !-> a0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; new a1: List[List[Assign]] = (l10, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68803
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68804

lab68803:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68801
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68794
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68792
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68793

lab68792:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68793:

lab68794:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68797
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68795
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68796

lab68795:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68796:

lab68797:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68800
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68798
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68799

lab68798:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68799:

lab68800:
    jmp lab68802

lab68801:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68802:

lab68804:
    ; #load tag
    lea r9, [rel List_List_Assign_68805]
    ; jump concat_2_
    jmp concat_2_

List_List_Assign_68805:
    jmp near List_List_Assign_68805_Nil
    jmp near List_List_Assign_68805_Cons

List_List_Assign_68805_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68808
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab68806
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68806:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68807
    ; ####increment refcount
    add qword [rax + 0], 1

lab68807:
    jmp lab68809

lab68808:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab68809:
    ; let x0: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (l10 !-> l10)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Assign_68805_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68812
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68810
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68810:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68811
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68811:
    jmp lab68813

lab68812:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68813:
    ; substitute (a0 !-> a0)(l10 !-> l10)(a3 !-> a3)(as1 !-> as1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[List[Assign]] = Cons(a3, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68825
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68826

lab68825:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68823
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68816
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68814
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68815

lab68814:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68815:

lab68816:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68819
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68817
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68818

lab68817:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68818:

lab68819:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68822
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68820
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68821

lab68820:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68821:

lab68822:
    jmp lab68824

lab68823:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68824:

lab68826:
    ; #load tag
    mov r9, 5
    ; substitute (l10 !-> l10)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

concat_:
    ; substitute (a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_List_Assign_68827]
    add rcx, rdi
    jmp rcx

List_List_List_Assign_68827:
    jmp near List_List_List_Assign_68827_Nil
    jmp near List_List_List_Assign_68827_Cons

List_List_List_Assign_68827_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_List_Assign_68827_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab68830
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab68828
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68828:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab68829
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68829:
    jmp lab68831

lab68830:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab68831:
    ; substitute (ls0 !-> ls0)(l !-> l)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a1: List[List[Assign]] = (l, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68843
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab68844

lab68843:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68841
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68834
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68832
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68833

lab68832:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68833:

lab68834:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68837
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68835
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68836

lab68835:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68836:

lab68837:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68840
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68838
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68839

lab68838:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68839:

lab68840:
    jmp lab68842

lab68841:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68842:

lab68844:
    ; #load tag
    lea rdi, [rel List_List_Assign_68845]
    ; jump concat_
    jmp concat_

List_List_Assign_68845:
    jmp near List_List_Assign_68845_Nil
    jmp near List_List_Assign_68845_Cons

List_List_Assign_68845_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68848
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab68846
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68846:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68847
    ; ####increment refcount
    add qword [rax + 0], 1

lab68847:
    jmp lab68849

lab68848:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab68849:
    ; let x0: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (l !-> l)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump concat_2_
    jmp concat_2_

List_List_Assign_68845_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68852
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68850
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68850:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68851
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68851:
    jmp lab68853

lab68852:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68853:
    ; substitute (a0 !-> a0)(l !-> l)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[List[Assign]] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68865
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68866

lab68865:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68863
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68856
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68854
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68855

lab68854:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68855:

lab68856:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68859
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68857
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68858

lab68857:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68858:

lab68859:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68862
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68860
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68861

lab68860:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68861:

lab68862:
    jmp lab68864

lab68863:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68864:

lab68866:
    ; #load tag
    mov r9, 5
    ; substitute (l !-> l)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump concat_2_
    jmp concat_2_

solv_map3_:
    ; substitute (f !-> f)(a0 !-> a0)(cs !-> cs);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch cs \{ ... \};
    lea rcx, [rel List_Node_List_Assign_68867]
    add rcx, r9
    jmp rcx

List_Node_List_Assign_68867:
    jmp near List_Node_List_Assign_68867_Nil
    jmp near List_Node_List_Assign_68867_Cons

List_Node_List_Assign_68867_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab68870
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab68868
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab68869

lab68868:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab68869:

lab68870:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_List_Assign_68867_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68873
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68871
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68871:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68872
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68872:
    jmp lab68874

lab68873:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68874:
    ; substitute (f0 !-> f)(n !-> n)(a0 !-> a0)(ns !-> ns)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab68875
    ; ####increment refcount
    add qword [rax + 0], 1

lab68875:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: List[List[Assign]] = (a0, ns, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68887
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68888

lab68887:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68885
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68878
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68876
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68877

lab68876:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68877:

lab68878:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68881
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68879
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68880

lab68879:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68880:

lab68881:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68884
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68882
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68883

lab68882:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68883:

lab68884:
    jmp lab68886

lab68885:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68886:

lab68888:
    ; #load tag
    lea r9, [rel List_List_Assign_68889]
    ; substitute (n !-> n)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

List_List_Assign_68889:
    jmp near List_List_Assign_68889_Nil
    jmp near List_List_Assign_68889_Cons

List_List_Assign_68889_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68893
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab68890
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68890:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab68891
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68891:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab68892
    ; ####increment refcount
    add qword [rax + 0], 1

lab68892:
    jmp lab68894

lab68893:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab68894:
    ; let x0: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 !-> a0)(f !-> f)(ns !-> ns)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_solv_map3_0_
    jmp lift_solv_map3_0_

List_List_Assign_68889_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68898
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab68895
    ; ####increment refcount
    add qword [r12 + 0], 1

lab68895:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab68896
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68896:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab68897
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68897:
    jmp lab68899

lab68898:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab68899:
    ; substitute (f !-> f)(ns !-> ns)(a0 !-> a0)(a4 !-> a4)(as1 !-> as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[List[Assign]] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68911
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab68912

lab68911:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68909
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68902
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68900
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68901

lab68900:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68901:

lab68902:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68905
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68903
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68904

lab68903:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68904:

lab68905:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68908
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68906
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68907

lab68906:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68907:

lab68908:
    jmp lab68910

lab68909:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68910:

lab68912:
    ; #load tag
    mov r11, 5
    ; substitute (a0 !-> a0)(f !-> f)(ns !-> ns)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_solv_map3_0_
    jmp lift_solv_map3_0_

lift_solv_map3_0_:
    ; substitute (ns !-> ns)(f !-> f)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a2: List[List[List[Assign]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68924
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68925

lab68924:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68922
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68915
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68913
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68914

lab68913:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68914:

lab68915:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68918
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68916
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68917

lab68916:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68917:

lab68918:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68921
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68919
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68920

lab68919:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68920:

lab68921:
    jmp lab68923

lab68922:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68923:

lab68925:
    ; #load tag
    lea r9, [rel List_List_List_Assign_68926]
    ; substitute (f !-> f)(ns !-> ns)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump solv_map3_
    jmp solv_map3_

List_List_List_Assign_68926:
    jmp near List_List_List_Assign_68926_Nil
    jmp near List_List_List_Assign_68926_Cons

List_List_List_Assign_68926_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68929
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab68927
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68927:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab68928
    ; ####increment refcount
    add qword [rax + 0], 1

lab68928:
    jmp lab68930

lab68929:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab68930:
    ; let x1: List[List[List[Assign]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_List_Assign_68926_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68933
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68931
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68931:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68932
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68932:
    jmp lab68934

lab68933:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68934:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[List[Assign]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68946
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68947

lab68946:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68944
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68937
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68935
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68936

lab68935:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68936:

lab68937:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68940
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68938
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68939

lab68938:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68939:

lab68940:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68943
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68941
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68942

lab68941:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68942:

lab68943:
    jmp lab68945

lab68944:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68945:

lab68947:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

leaves_:
    ; substitute (a0 !-> a0)(t !-> t);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch t \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_List_Assign_68948:

Node_List_Assign_68948_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab68951
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab68949
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68949:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab68950
    ; ####increment refcount
    add qword [rsi + 0], 1

lab68950:
    jmp lab68952

lab68951:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab68952:
    ; switch cs \{ ... \};
    lea rcx, [rel List_Node_List_Assign_68953]
    add rcx, r9
    jmp rcx

List_Node_List_Assign_68953:
    jmp near List_Node_List_Assign_68953_Nil
    jmp near List_Node_List_Assign_68953_Cons

List_Node_List_Assign_68953_Nil:
    ; let x0: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (leaf !-> leaf)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_List_Assign_68953_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68956
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab68954
    ; ####increment refcount
    add qword [r10 + 0], 1

lab68954:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab68955
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68955:
    jmp lab68957

lab68956:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab68957:
    ; substitute (cs0 !-> cs0)(c !-> c)(a0 !-> a0);
    ; #erase leaf
    cmp rsi, 0
    je lab68960
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab68958
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab68959

lab68958:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab68959:

lab68960:
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rdi, r9
    mov r9, rdx
    mov rax, r10
    mov rdx, r11
    ; new a1: List[List[List[Assign]]] = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68972
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68973

lab68972:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68970
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68963
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68961
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68962

lab68961:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68962:

lab68963:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68966
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68964
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68965

lab68964:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68965:

lab68966:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68969
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68967
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68968

lab68967:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68968:

lab68969:
    jmp lab68971

lab68970:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68971:

lab68973:
    ; #load tag
    lea r9, [rel List_List_List_Assign_68974]
    ; new x2: Fun[Node[List[Assign]], List[List[Assign]]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Node_List_Assign_List_List_Assign_68975]
    ; substitute (x2 !-> x2)(a1 !-> a1)(c !-> c)(cs0 !-> cs0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; let x3: List[Node[List[Assign]]] = Cons(c, cs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab68987
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab68988

lab68987:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab68985
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68978
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68976
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68977

lab68976:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68977:

lab68978:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab68981
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68979
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68980

lab68979:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68980:

lab68981:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab68984
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68982
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68983

lab68982:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68983:

lab68984:
    jmp lab68986

lab68985:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab68986:

lab68988:
    ; #load tag
    mov r9, 5
    ; substitute (x2 !-> x2)(x3 !-> x3)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump solv_map3_
    jmp solv_map3_

Fun_Node_List_Assign_List_List_Assign_68975:

Fun_Node_List_Assign_List_List_Assign_68975_Ap:
    ; jump leaves_
    jmp leaves_

List_List_List_Assign_68974:
    jmp near List_List_List_Assign_68974_Nil
    jmp near List_List_List_Assign_68974_Cons

List_List_List_Assign_68974_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab68990
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab68989
    ; ####increment refcount
    add qword [rax + 0], 1

lab68989:
    jmp lab68991

lab68990:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab68991:
    ; let x1: List[List[List[Assign]]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump concat_
    jmp concat_

List_List_List_Assign_68974_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab68993
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab68992
    ; ####increment refcount
    add qword [r8 + 0], 1

lab68992:
    jmp lab68994

lab68993:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab68994:
    ; substitute (a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x1: List[List[List[Assign]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69006
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69007

lab69006:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69004
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab68997
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68995
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68996

lab68995:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68996:

lab68997:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69000
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab68998
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab68999

lab68998:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab68999:

lab69000:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69003
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69001
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69002

lab69001:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69002:

lab69003:
    jmp lab69005

lab69004:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69005:

lab69007:
    ; #load tag
    mov rdi, 5
    ; substitute (x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump concat_
    jmp concat_

solv_filter_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_Assign_69008]
    add rcx, r9
    jmp rcx

List_List_Assign_69008:
    jmp near List_List_Assign_69008_Nil
    jmp near List_List_Assign_69008_Cons

List_List_Assign_69008_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab69011
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab69009
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab69010

lab69009:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab69010:

lab69011:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_Assign_69008_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69014
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69012
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69012:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69013
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69013:
    jmp lab69015

lab69014:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69015:
    ; substitute (f0 !-> f)(l0 !-> l)(l !-> l)(ls0 !-> ls0)(f !-> f)(a0 !-> a0);
    ; #share f
    cmp rax, 0
    je lab69016
    ; ####increment refcount
    add qword [rax + 0], 1

lab69016:
    ; #share l
    cmp r8, 0
    je lab69017
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69017:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rsi, r8
    mov rdi, r9
    ; new a2: Bool = (l, ls0, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69029
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab69030

lab69029:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69027
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69020
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69018
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69019

lab69018:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69019:

lab69020:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69023
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69021
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69022

lab69021:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69022:

lab69023:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69026
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69024
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69025

lab69024:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69025:

lab69026:
    jmp lab69028

lab69027:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69028:

lab69030:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69042
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69043

lab69042:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69040
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69033
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69031
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69032

lab69031:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69032:

lab69033:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69036
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69034
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69035

lab69034:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69035:

lab69036:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69039
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69037
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69038

lab69037:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69038:

lab69039:
    jmp lab69041

lab69040:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69041:

lab69043:
    ; #load tag
    lea r9, [rel Bool_69044]
    ; substitute (l0 !-> l0)(a2 !-> a2)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Bool_69044:
    jmp near Bool_69044_True
    jmp near Bool_69044_False

Bool_69044_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69049
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab69045
    ; ####increment refcount
    add qword [rax + 0], 1

lab69045:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab69046
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69046:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab69047
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69047:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab69048
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69048:
    jmp lab69050

lab69049:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab69050:
    ; substitute (f !-> f)(ls0 !-> ls0)(l !-> l)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a1: List[List[Assign]] = (l, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69062
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69063

lab69062:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69060
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69053
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69051
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69052

lab69051:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69052:

lab69053:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69056
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69054
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69055

lab69054:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69055:

lab69056:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69059
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69057
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69058

lab69057:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69058:

lab69059:
    jmp lab69061

lab69060:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69061:

lab69063:
    ; #load tag
    lea r9, [rel List_List_Assign_69064]
    ; jump solv_filter_
    jmp solv_filter_

List_List_Assign_69064:
    jmp near List_List_Assign_69064_Nil
    jmp near List_List_Assign_69064_Cons

List_List_Assign_69064_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69067
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab69065
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69065:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab69066
    ; ####increment refcount
    add qword [rax + 0], 1

lab69066:
    jmp lab69068

lab69067:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab69068:
    ; let x0: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (l !-> l)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Assign_69064_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69071
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69069
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69069:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69070
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69070:
    jmp lab69072

lab69071:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69072:
    ; substitute (a0 !-> a0)(l !-> l)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[List[Assign]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69084
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69085

lab69084:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69082
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69075
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69073
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69074

lab69073:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69074:

lab69075:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69078
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69076
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69077

lab69076:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69077:

lab69078:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69081
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69079
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69080

lab69079:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69080:

lab69081:
    jmp lab69083

lab69082:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69083:

lab69085:
    ; #load tag
    mov r9, 5
    ; substitute (l !-> l)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_69044_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69090
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab69086
    ; ####increment refcount
    add qword [rax + 0], 1

lab69086:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab69087
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69087:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab69088
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69088:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab69089
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69089:
    jmp lab69091

lab69090:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab69091:
    ; substitute (f !-> f)(ls0 !-> ls0)(a0 !-> a0);
    ; #erase l
    cmp rax, 0
    je lab69094
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab69092
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab69093

lab69092:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab69093:

lab69094:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump solv_filter_
    jmp solv_filter_

btsolver0_:
    ; substitute (csp0 !-> csp)(a0 !-> a0)(csp !-> csp);
    ; #share csp
    cmp rax, 0
    je lab69095
    ; ####increment refcount
    add qword [rax + 0], 1

lab69095:
    ; #move variables
    mov r8, rax
    mov r9, rdx
    ; new x1: Fun[List[Assign], Bool] = (csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69107
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69108

lab69107:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69105
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69098
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69096
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69097

lab69096:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69097:

lab69098:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69101
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69099
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69100

lab69099:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69100:

lab69101:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69104
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69102
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69103

lab69102:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69103:

lab69104:
    jmp lab69106

lab69105:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69106:

lab69108:
    ; #load tag
    lea r9, [rel Fun_List_Assign_Bool_69109]
    ; new a2: List[List[Assign]] = (a0, x1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69121
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69122

lab69121:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69119
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69112
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69110
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69111

lab69110:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69111:

lab69112:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69115
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69113
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69114

lab69113:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69114:

lab69115:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69118
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69116
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69117

lab69116:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69117:

lab69118:
    jmp lab69120

lab69119:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69120:

lab69122:
    ; #load tag
    lea rdi, [rel List_List_Assign_69123]
    ; new a3: Node[List[Assign]] = (a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69135
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69136

lab69135:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69133
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69126
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69124
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69125

lab69124:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69125:

lab69126:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69129
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69127
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69128

lab69127:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69128:

lab69129:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69132
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69130
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69131

lab69130:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69131:

lab69132:
    jmp lab69134

lab69133:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69134:

lab69136:
    ; #load tag
    lea rdi, [rel Node_List_Assign_69137]
    ; new x4: Fun[Pair[List[Assign], Option[Pair[i64, i64]]], List[Assign]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Pair_List_Assign_Option_Pair_i64_i64_List_Assign_69138]
    ; new a5: Node[Pair[List[Assign], Option[Pair[i64, i64]]]] = (a3, x4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69150
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69151

lab69150:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69148
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69141
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69139
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69140

lab69139:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69140:

lab69141:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69144
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69142
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69143

lab69142:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69143:

lab69144:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69147
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69145
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69146

lab69145:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69146:

lab69147:
    jmp lab69149

lab69148:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69149:

lab69151:
    ; #load tag
    lea rdi, [rel Node_Pair_List_Assign_Option_Pair_i64_i64_69152]
    ; new x6: Fun[Pair[List[Assign], Option[Pair[i64, i64]]], Bool] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Pair_List_Assign_Option_Pair_i64_i64_Bool_69153]
    ; new a9: Node[Pair[List[Assign], Option[Pair[i64, i64]]]] = (a5, x6)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69165
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69166

lab69165:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69163
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69156
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69154
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69155

lab69154:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69155:

lab69156:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69159
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69157
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69158

lab69157:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69158:

lab69159:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69162
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69160
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69161

lab69160:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69161:

lab69162:
    jmp lab69164

lab69163:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69164:

lab69166:
    ; #load tag
    lea rdi, [rel Node_Pair_List_Assign_Option_Pair_i64_i64_69167]
    ; substitute (csp00 !-> csp0)(a9 !-> a9)(csp0 !-> csp0);
    ; #share csp0
    cmp rax, 0
    je lab69168
    ; ####increment refcount
    add qword [rax + 0], 1

lab69168:
    ; #move variables
    mov r8, rax
    mov r9, rdx
    ; new a10: Node[List[Assign]] = (a9, csp0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69180
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69181

lab69180:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69178
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69171
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69169
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69170

lab69169:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69170:

lab69171:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69174
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69172
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69173

lab69172:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69173:

lab69174:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69177
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69175
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69176

lab69175:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69176:

lab69177:
    jmp lab69179

lab69178:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69179:

lab69181:
    ; #load tag
    lea rdi, [rel Node_List_Assign_69182]
    ; jump mk_tree_
    jmp mk_tree_

Node_List_Assign_69182:

Node_List_Assign_69182_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69185
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69183
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69183:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69184
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69184:
    jmp lab69186

lab69185:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69186:
    ; substitute (csp0 !-> csp0)(a9 !-> a9)(lab3 !-> lab3)(children3 !-> children3);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x8: Node[List[Assign]] = Node(lab3, children3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69198
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69199

lab69198:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69196
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69189
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69187
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69188

lab69187:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69188:

lab69189:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69192
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69190
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69191

lab69190:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69191:

lab69192:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69195
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69193
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69194

lab69193:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69194:

lab69195:
    jmp lab69197

lab69196:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69197:

lab69199:
    ; #load tag
    mov r9, 0
    ; substitute (csp0 !-> csp0)(x8 !-> x8)(a9 !-> a9);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump label_inconsistencies_
    jmp label_inconsistencies_

Node_Pair_List_Assign_Option_Pair_i64_i64_69167:

Node_Pair_List_Assign_Option_Pair_i64_i64_69167_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69202
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69200
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69200:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69201
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69201:
    jmp lab69203

lab69202:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69203:
    ; substitute (x6 !-> x6)(a5 !-> a5)(lab2 !-> lab2)(children2 !-> children2);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x7: Node[Pair[List[Assign], Option[Pair[i64, i64]]]] = Node(lab2, children2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69215
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69216

lab69215:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69213
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69206
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69204
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69205

lab69204:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69205:

lab69206:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69209
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69207
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69208

lab69207:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69208:

lab69209:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69212
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69210
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69211

lab69210:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69211:

lab69212:
    jmp lab69214

lab69213:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69214:

lab69216:
    ; #load tag
    mov r9, 0
    ; substitute (x6 !-> x6)(x7 !-> x7)(a5 !-> a5);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump prune_
    jmp prune_

Fun_Pair_List_Assign_Option_Pair_i64_i64_Bool_69153:

Fun_Pair_List_Assign_Option_Pair_i64_i64_Bool_69153_Ap:
    ; new a7: Bool = (a6)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69228
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69229

lab69228:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69226
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69219
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69217
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69218

lab69217:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69218:

lab69219:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69222
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69220
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69221

lab69220:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69221:

lab69222:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69225
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69223
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69224

lab69223:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69224:

lab69225:
    jmp lab69227

lab69226:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69227:

lab69229:
    ; #load tag
    lea rdi, [rel Bool_69230]
    ; new a8: Option[Pair[i64, i64]] = (a7)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69242
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69243

lab69242:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69240
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69233
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69231
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69232

lab69231:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69232:

lab69233:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69236
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69234
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69235

lab69234:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69235:

lab69236:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69239
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69237
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69238

lab69237:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69238:

lab69239:
    jmp lab69241

lab69240:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69241:

lab69243:
    ; #load tag
    lea rdi, [rel Option_Pair_i64_i64_69244]
    ; jump snd_
    jmp snd_

Option_Pair_i64_i64_69244:
    jmp near Option_Pair_i64_i64_69244_None
    jmp near Option_Pair_i64_i64_69244_Some

Option_Pair_i64_i64_69244_None:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69246
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab69245
    ; ####increment refcount
    add qword [rax + 0], 1

lab69245:
    jmp lab69247

lab69246:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab69247:
    ; let x10: Option[Pair[i64, i64]] = None();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; jump lift_btsolver0_0_
    jmp lift_btsolver0_0_

Option_Pair_i64_i64_69244_Some:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab69249
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab69248
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69248:
    jmp lab69250

lab69249:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab69250:
    ; substitute (a7 !-> a7)(a12 !-> a12);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x10: Option[Pair[i64, i64]] = Some(a12);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69262
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69263

lab69262:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69260
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69253
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69251
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69252

lab69251:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69252:

lab69253:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69256
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69254
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69255

lab69254:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69255:

lab69256:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69259
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69257
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69258

lab69257:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69258:

lab69259:
    jmp lab69261

lab69260:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69261:

lab69263:
    ; #load tag
    mov rdi, 5
    ; jump lift_btsolver0_0_
    jmp lift_btsolver0_0_

Bool_69230:
    jmp near Bool_69230_True
    jmp near Bool_69230_False

Bool_69230_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69265
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab69264
    ; ####increment refcount
    add qword [rax + 0], 1

lab69264:
    jmp lab69266

lab69265:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab69266:
    ; let x9: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x9 !-> x9)(a6 !-> a6);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_69230_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69268
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab69267
    ; ####increment refcount
    add qword [rax + 0], 1

lab69267:
    jmp lab69269

lab69268:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab69269:
    ; let x9: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x9 !-> x9)(a6 !-> a6);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Node_Pair_List_Assign_Option_Pair_i64_i64_69152:

Node_Pair_List_Assign_Option_Pair_i64_i64_69152_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69272
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69270
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69270:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69271
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69271:
    jmp lab69273

lab69272:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69273:
    ; substitute (x4 !-> x4)(a3 !-> a3)(lab1 !-> lab1)(children1 !-> children1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x5: Node[Pair[List[Assign], Option[Pair[i64, i64]]]] = Node(lab1, children1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69285
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69286

lab69285:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69283
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69276
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69274
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69275

lab69274:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69275:

lab69276:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69279
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69277
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69278

lab69277:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69278:

lab69279:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69282
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69280
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69281

lab69280:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69281:

lab69282:
    jmp lab69284

lab69283:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69284:

lab69286:
    ; #load tag
    mov r9, 0
    ; substitute (x4 !-> x4)(x5 !-> x5)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump solv_map_tree_
    jmp solv_map_tree_

Fun_Pair_List_Assign_Option_Pair_i64_i64_List_Assign_69138:

Fun_Pair_List_Assign_Option_Pair_i64_i64_List_Assign_69138_Ap:
    ; jump fst_
    jmp fst_

Node_List_Assign_69137:

Node_List_Assign_69137_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69288
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab69287
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69287:
    jmp lab69289

lab69288:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab69289:
    ; substitute (a2 !-> a2)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x3: Node[List[Assign]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69301
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69302

lab69301:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69299
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69292
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69290
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69291

lab69290:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69291:

lab69292:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69295
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69293
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69294

lab69293:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69294:

lab69295:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69298
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69296
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69297

lab69296:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69297:

lab69298:
    jmp lab69300

lab69299:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69300:

lab69302:
    ; #load tag
    mov rdi, 0
    ; substitute (x3 !-> x3)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump leaves_
    jmp leaves_

List_List_Assign_69123:
    jmp near List_List_Assign_69123_Nil
    jmp near List_List_Assign_69123_Cons

List_List_Assign_69123_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69305
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab69303
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69303:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab69304
    ; ####increment refcount
    add qword [rax + 0], 1

lab69304:
    jmp lab69306

lab69305:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab69306:
    ; let x2: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x1 !-> x1)(x2 !-> x2)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump solv_filter_
    jmp solv_filter_

List_List_Assign_69123_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69309
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69307
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69307:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69308
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69308:
    jmp lab69310

lab69309:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69310:
    ; substitute (x1 !-> x1)(a0 !-> a0)(a11 !-> a11)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x2: List[List[Assign]] = Cons(a11, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69322
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69323

lab69322:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69320
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69313
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69311
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69312

lab69311:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69312:

lab69313:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69316
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69314
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69315

lab69314:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69315:

lab69316:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69319
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69317
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69318

lab69317:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69318:

lab69319:
    jmp lab69321

lab69320:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69321:

lab69323:
    ; #load tag
    mov r9, 5
    ; substitute (x1 !-> x1)(x2 !-> x2)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump solv_filter_
    jmp solv_filter_

Fun_List_Assign_Bool_69109:

Fun_List_Assign_Bool_69109_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69325
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab69324
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69324:
    jmp lab69326

lab69325:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab69326:
    ; substitute (csp !-> csp)(x !-> x)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump complete_
    jmp complete_

lift_btsolver0_0_:
    ; let x11: Option[Pair[i64, i64]] = None();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x10 !-> x10)(x11 !-> x11)(a7 !-> a7);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump option_eq_
    jmp option_eq_

known_conflict_:
    ; substitute (a0 !-> a0)(c !-> c);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch c \{ ... \};
    lea rcx, [rel ConflictSet_69327]
    add rcx, rdi
    jmp rcx

ConflictSet_69327:
    jmp near ConflictSet_69327_Known
    jmp near ConflictSet_69327_Unknown

ConflictSet_69327_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab69329
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab69328
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69328:
    jmp lab69330

lab69329:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab69330:
    ; switch vs \{ ... \};
    lea rcx, [rel List_i64_69331]
    add rcx, rdi
    jmp rcx

List_i64_69331:
    jmp near List_i64_69331_Nil
    jmp near List_i64_69331_Cons

List_i64_69331_Nil:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

List_i64_69331_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab69333
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab69332
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69332:
    mov rdi, [rsi + 40]
    jmp lab69334

lab69333:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab69334:
    ; substitute (a0 !-> a0);
    ; #erase vs0
    cmp r8, 0
    je lab69337
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab69335
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab69336

lab69335:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab69336:

lab69337:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

ConflictSet_69327_Unknown:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

known_solution_:
    ; substitute (a0 !-> a0)(c !-> c);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch c \{ ... \};
    lea rcx, [rel ConflictSet_69338]
    add rcx, rdi
    jmp rcx

ConflictSet_69338:
    jmp near ConflictSet_69338_Known
    jmp near ConflictSet_69338_Unknown

ConflictSet_69338_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab69340
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab69339
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69339:
    jmp lab69341

lab69340:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab69341:
    ; switch vs \{ ... \};
    lea rcx, [rel List_i64_69342]
    add rcx, rdi
    jmp rcx

List_i64_69342:
    jmp near List_i64_69342_Nil
    jmp near List_i64_69342_Cons

List_i64_69342_Nil:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

List_i64_69342_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab69344
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab69343
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69343:
    mov rdi, [rsi + 40]
    jmp lab69345

lab69344:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab69345:
    ; substitute (a0 !-> a0);
    ; #erase vs0
    cmp r8, 0
    je lab69348
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab69346
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab69347

lab69346:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab69347:

lab69348:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

ConflictSet_69338_Unknown:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

check_complete_:
    ; new a1: Bool = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69360
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69361

lab69360:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69358
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69351
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69349
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69350

lab69349:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69350:

lab69351:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69354
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69352
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69353

lab69352:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69353:

lab69354:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69357
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69355
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69356

lab69355:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69356:

lab69357:
    jmp lab69359

lab69358:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69359:

lab69361:
    ; #load tag
    lea r9, [rel Bool_69362]
    ; jump complete_
    jmp complete_

Bool_69362:
    jmp near Bool_69362_True
    jmp near Bool_69362_False

Bool_69362_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69364
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab69363
    ; ####increment refcount
    add qword [rax + 0], 1

lab69363:
    jmp lab69365

lab69364:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab69365:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Known
    add rdi, 0
    jmp rdi

Bool_69362_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69367
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab69366
    ; ####increment refcount
    add qword [rax + 0], 1

lab69366:
    jmp lab69368

lab69367:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab69368:
    ; invoke a0 Unknown
    add rdx, 5
    jmp rdx

search_filter_:
    ; substitute (f !-> f)(a0 !-> a0)(l !-> l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_69369]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_69369:
    jmp near List_Node_Pair_List_Assign_ConflictSet_69369_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_69369_Cons

List_Node_Pair_List_Assign_ConflictSet_69369_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab69372
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab69370
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab69371

lab69370:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab69371:

lab69372:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_69369_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69375
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69373
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69373:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69374
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69374:
    jmp lab69376

lab69375:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69376:
    ; substitute (f0 !-> f)(p0 !-> p)(p !-> p)(ps !-> ps)(f !-> f)(a0 !-> a0);
    ; #share f
    cmp rax, 0
    je lab69377
    ; ####increment refcount
    add qword [rax + 0], 1

lab69377:
    ; #share p
    cmp r8, 0
    je lab69378
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69378:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rsi, r8
    mov rdi, r9
    ; new a2: Bool = (p, ps, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69390
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab69391

lab69390:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69388
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69381
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69379
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69380

lab69379:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69380:

lab69381:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69384
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69382
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69383

lab69382:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69383:

lab69384:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69387
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69385
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69386

lab69385:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69386:

lab69387:
    jmp lab69389

lab69388:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69389:

lab69391:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69403
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69404

lab69403:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69401
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69394
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69392
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69393

lab69392:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69393:

lab69394:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69397
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69395
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69396

lab69395:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69396:

lab69397:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69400
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69398
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69399

lab69398:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69399:

lab69400:
    jmp lab69402

lab69401:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69402:

lab69404:
    ; #load tag
    lea r9, [rel Bool_69405]
    ; substitute (p0 !-> p0)(a2 !-> a2)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Bool_69405:
    jmp near Bool_69405_True
    jmp near Bool_69405_False

Bool_69405_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69410
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab69406
    ; ####increment refcount
    add qword [rax + 0], 1

lab69406:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab69407
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69407:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab69408
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69408:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab69409
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69409:
    jmp lab69411

lab69410:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab69411:
    ; substitute (f !-> f)(ps !-> ps)(p !-> p)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a1: List[Node[Pair[List[Assign], ConflictSet]]] = (p, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69423
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69424

lab69423:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69421
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69414
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69412
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69413

lab69412:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69413:

lab69414:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69417
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69415
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69416

lab69415:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69416:

lab69417:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69420
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69418
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69419

lab69418:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69419:

lab69420:
    jmp lab69422

lab69421:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69422:

lab69424:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_69425]
    ; jump search_filter_
    jmp search_filter_

List_Node_Pair_List_Assign_ConflictSet_69425:
    jmp near List_Node_Pair_List_Assign_ConflictSet_69425_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_69425_Cons

List_Node_Pair_List_Assign_ConflictSet_69425_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69428
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab69426
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69426:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab69427
    ; ####increment refcount
    add qword [rax + 0], 1

lab69427:
    jmp lab69429

lab69428:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab69429:
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (p !-> p)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_69425_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69432
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69430
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69430:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69431
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69431:
    jmp lab69433

lab69432:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69433:
    ; substitute (a0 !-> a0)(p !-> p)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69445
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69446

lab69445:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69443
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69436
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69434
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69435

lab69434:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69435:

lab69436:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69439
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69437
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69438

lab69437:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69438:

lab69439:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69442
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69440
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69441

lab69440:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69441:

lab69442:
    jmp lab69444

lab69443:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69444:

lab69446:
    ; #load tag
    mov r9, 5
    ; substitute (p !-> p)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_69405_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69451
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab69447
    ; ####increment refcount
    add qword [rax + 0], 1

lab69447:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab69448
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69448:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab69449
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69449:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab69450
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69450:
    jmp lab69452

lab69451:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab69452:
    ; substitute (f !-> f)(ps !-> ps)(a0 !-> a0);
    ; #erase p
    cmp rax, 0
    je lab69455
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab69453
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab69454

lab69453:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab69454:

lab69455:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump search_filter_
    jmp search_filter_

search_label_:
    ; substitute (a0 !-> a0)(n !-> n);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch n \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_Pair_List_Assign_ConflictSet_69456:

Node_Pair_List_Assign_ConflictSet_69456_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab69459
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab69457
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69457:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab69458
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69458:
    jmp lab69460

lab69459:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab69460:
    ; substitute (a0 !-> a0)(p !-> p);
    ; #erase cs
    cmp r8, 0
    je lab69463
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab69461
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab69462

lab69461:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab69462:

lab69463:
    ; switch p \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_List_Assign_ConflictSet_69464:

Pair_List_Assign_ConflictSet_69464_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab69467
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab69465
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69465:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab69466
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69466:
    jmp lab69468

lab69467:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab69468:
    ; substitute (a1 !-> a1)(b0 !-> b0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Tup
    jmp r9

search_map_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_69469]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_69469:
    jmp near List_Node_Pair_List_Assign_ConflictSet_69469_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_69469_Cons

List_Node_Pair_List_Assign_ConflictSet_69469_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab69472
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab69470
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab69471

lab69470:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab69471:

lab69472:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_69469_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69475
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69473
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69473:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69474
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69474:
    jmp lab69476

lab69475:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69476:
    ; substitute (f0 !-> f)(n !-> n)(a0 !-> a0)(ns !-> ns)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab69477
    ; ####increment refcount
    add qword [rax + 0], 1

lab69477:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ns, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69489
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69490

lab69489:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69487
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69480
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69478
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69479

lab69478:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69479:

lab69480:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69483
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69481
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69482

lab69481:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69482:

lab69483:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69486
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69484
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69485

lab69484:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69485:

lab69486:
    jmp lab69488

lab69487:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69488:

lab69490:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_69491]
    ; substitute (n !-> n)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Node_Pair_List_Assign_ConflictSet_69491:

Node_Pair_List_Assign_ConflictSet_69491_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69495
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab69492
    ; ####increment refcount
    add qword [r12 + 0], 1

lab69492:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab69493
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69493:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab69494
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69494:
    jmp lab69496

lab69495:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab69496:
    ; substitute (f !-> f)(ns !-> ns)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69508
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab69509

lab69508:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69506
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69499
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69497
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69498

lab69497:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69498:

lab69499:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69502
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69500
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69501

lab69500:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69501:

lab69502:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69505
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69503
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69504

lab69503:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69504:

lab69505:
    jmp lab69507

lab69506:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69507:

lab69509:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69521
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69522

lab69521:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69519
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69512
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69510
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69511

lab69510:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69511:

lab69512:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69515
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69513
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69514

lab69513:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69514:

lab69515:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69518
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69516
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69517

lab69516:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69517:

lab69518:
    jmp lab69520

lab69519:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69520:

lab69522:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_69523]
    ; jump search_map_
    jmp search_map_

List_Node_Pair_List_Assign_ConflictSet_69523:
    jmp near List_Node_Pair_List_Assign_ConflictSet_69523_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_69523_Cons

List_Node_Pair_List_Assign_ConflictSet_69523_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69526
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab69524
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69524:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab69525
    ; ####increment refcount
    add qword [rax + 0], 1

lab69525:
    jmp lab69527

lab69526:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab69527:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_69523_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69530
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69528
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69528:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69529
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69529:
    jmp lab69531

lab69530:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69531:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69543
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69544

lab69543:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69541
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69534
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69532
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69533

lab69532:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69533:

lab69534:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69537
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69535
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69536

lab69535:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69536:

lab69537:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69540
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69538
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69539

lab69538:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69539:

lab69540:
    jmp lab69542

lab69541:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69542:

lab69544:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

search_fold_tree_:
    ; substitute (f !-> f)(a0 !-> a0)(n !-> n);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch n \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_Pair_List_Assign_ConflictSet_69545:

Node_Pair_List_Assign_ConflictSet_69545_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69548
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69546
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69546:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69547
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69547:
    jmp lab69549

lab69548:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69549:
    ; substitute (f0 !-> f)(c !-> c)(l !-> l)(a0 !-> a0)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab69550
    ; ####increment refcount
    add qword [rax + 0], 1

lab69550:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; new a1: List[Node[Pair[List[Assign], ConflictSet]]] = (l, a0, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69562
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69563

lab69562:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69560
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69553
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69551
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69552

lab69551:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69552:

lab69553:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69556
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69554
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69555

lab69554:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69555:

lab69556:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69559
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69557
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69558

lab69557:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69558:

lab69559:
    jmp lab69561

lab69560:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69561:

lab69563:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_69564]
    ; substitute (a1 !-> a1)(c !-> c)(f0 !-> f0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new x1: Fun[Node[Pair[List[Assign], ConflictSet]], Node[Pair[List[Assign], ConflictSet]]] = (f0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69576
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69577

lab69576:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69574
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69567
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69565
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69566

lab69565:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69566:

lab69567:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69570
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69568
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69569

lab69568:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69569:

lab69570:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69573
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69571
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69572

lab69571:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69572:

lab69573:
    jmp lab69575

lab69574:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69575:

lab69577:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_69578]
    ; substitute (x1 !-> x1)(c !-> c)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_map_
    jmp search_map_

Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_69578:

Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_69578_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69580
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab69579
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69579:
    jmp lab69581

lab69580:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab69581:
    ; substitute (f0 !-> f0)(x !-> x)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_fold_tree_
    jmp search_fold_tree_

List_Node_Pair_List_Assign_ConflictSet_69564:
    jmp near List_Node_Pair_List_Assign_ConflictSet_69564_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_69564_Cons

List_Node_Pair_List_Assign_ConflictSet_69564_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69585
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab69582
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69582:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab69583
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69583:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab69584
    ; ####increment refcount
    add qword [rax + 0], 1

lab69584:
    jmp lab69586

lab69585:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab69586:
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 !-> a0)(f !-> f)(l !-> l)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_search_fold_tree_0_
    jmp lift_search_fold_tree_0_

List_Node_Pair_List_Assign_ConflictSet_69564_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69590
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab69587
    ; ####increment refcount
    add qword [r12 + 0], 1

lab69587:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab69588
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69588:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab69589
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69589:
    jmp lab69591

lab69590:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab69591:
    ; substitute (f !-> f)(a0 !-> a0)(l !-> l)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69603
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab69604

lab69603:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69601
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69594
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69592
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69593

lab69592:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69593:

lab69594:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69597
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69595
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69596

lab69595:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69596:

lab69597:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69600
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69598
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69599

lab69598:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69599:

lab69600:
    jmp lab69602

lab69601:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69602:

lab69604:
    ; #load tag
    mov r11, 5
    ; substitute (a0 !-> a0)(f !-> f)(l !-> l)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_search_fold_tree_0_
    jmp lift_search_fold_tree_0_

lift_search_fold_tree_0_:
    ; substitute (l !-> l)(f !-> f)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; let a3: Fun[List[Node[Pair[List[Assign], ConflictSet]]], Node[Pair[List[Assign], ConflictSet]]] = Ap(x0, a0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69616
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69617

lab69616:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69614
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69607
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69605
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69606

lab69605:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69606:

lab69607:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69610
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69608
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69609

lab69608:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69609:

lab69610:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69613
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69611
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69612

lab69611:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69612:

lab69613:
    jmp lab69615

lab69614:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69615:

lab69617:
    ; #load tag
    mov r9, 0
    ; substitute (l !-> l)(a3 !-> a3)(f !-> f);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke f Ap
    jmp r9

search_filter_tree_:
    ; substitute (a0 !-> a0)(n !-> n)(p !-> p);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new f1: Fun[Pair[List[Assign], ConflictSet], Fun[List[Node[Pair[List[Assign], ConflictSet]]], Node[Pair[List[Assign], ConflictSet]]]] = (p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69629
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69630

lab69629:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69627
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69620
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69618
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69619

lab69618:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69619:

lab69620:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69623
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69621
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69622

lab69621:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69622:

lab69623:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69626
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69624
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69625

lab69624:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69625:

lab69626:
    jmp lab69628

lab69627:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69628:

lab69630:
    ; #load tag
    lea r9, [rel Fun_Pair_List_Assign_ConflictSet_Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_69631]
    ; substitute (f1 !-> f1)(n !-> n)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_fold_tree_
    jmp search_fold_tree_

Fun_Pair_List_Assign_ConflictSet_Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_69631:

Fun_Pair_List_Assign_ConflictSet_Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_69631_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69633
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab69632
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69632:
    jmp lab69634

lab69633:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab69634:
    ; substitute (a !-> a)(p !-> p)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_69635:

Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_69635_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69638
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69636
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69636:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69637
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69637:
    jmp lab69639

lab69638:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69639:
    ; substitute (cs !-> cs)(p !-> p)(a !-> a)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a3: List[Node[Pair[List[Assign], ConflictSet]]] = (a, a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69651
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69652

lab69651:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69649
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69642
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69640
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69641

lab69640:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69641:

lab69642:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69645
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69643
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69644

lab69643:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69644:

lab69645:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69648
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69646
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69647

lab69646:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69647:

lab69648:
    jmp lab69650

lab69649:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69650:

lab69652:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_69653]
    ; substitute (cs !-> cs)(a3 !-> a3)(p !-> p);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new x1: Fun[Node[Pair[List[Assign], ConflictSet]], Bool] = (p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69665
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69666

lab69665:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69663
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69656
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69654
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69655

lab69654:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69655:

lab69656:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69659
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69657
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69658

lab69657:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69658:

lab69659:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69662
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69660
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69661

lab69660:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69661:

lab69662:
    jmp lab69664

lab69663:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69664:

lab69666:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Bool_69667]
    ; substitute (x1 !-> x1)(cs !-> cs)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_filter_
    jmp search_filter_

Fun_Node_Pair_List_Assign_ConflictSet_Bool_69667:

Fun_Node_Pair_List_Assign_ConflictSet_Bool_69667_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69669
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab69668
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69668:
    jmp lab69670

lab69669:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab69670:
    ; new a5: Pair[List[Assign], ConflictSet] = (a4, p)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69682
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69683

lab69682:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69680
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69673
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69671
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69672

lab69671:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69672:

lab69673:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69676
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69674
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69675

lab69674:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69675:

lab69676:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69679
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69677
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69678

lab69677:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69678:

lab69679:
    jmp lab69681

lab69680:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69681:

lab69683:
    ; #load tag
    lea rdi, [rel Pair_List_Assign_ConflictSet_69684]
    ; jump search_label_
    jmp search_label_

Pair_List_Assign_ConflictSet_69684:

Pair_List_Assign_ConflictSet_69684_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69687
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69685
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69685:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69686
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69686:
    jmp lab69688

lab69687:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69688:
    ; substitute (p !-> p)(a4 !-> a4)(a7 !-> a7)(b0 !-> b0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x2: Pair[List[Assign], ConflictSet] = Tup(a7, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69700
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69701

lab69700:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69698
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69691
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69689
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69690

lab69689:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69690:

lab69691:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69694
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69692
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69693

lab69692:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69693:

lab69694:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69697
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69695
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69696

lab69695:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69696:

lab69697:
    jmp lab69699

lab69698:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69699:

lab69701:
    ; #load tag
    mov r9, 0
    ; substitute (x2 !-> x2)(a4 !-> a4)(p !-> p);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke p Ap
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_69653:
    jmp near List_Node_Pair_List_Assign_ConflictSet_69653_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_69653_Cons

List_Node_Pair_List_Assign_ConflictSet_69653_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69704
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab69702
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69702:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab69703
    ; ####increment refcount
    add qword [rax + 0], 1

lab69703:
    jmp lab69705

lab69704:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab69705:
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (a !-> a)(x0 !-> x0)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a2 Node
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_69653_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69708
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69706
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69706:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69707
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69707:
    jmp lab69709

lab69708:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69709:
    ; substitute (a2 !-> a2)(a !-> a)(a6 !-> a6)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a6, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69721
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69722

lab69721:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69719
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69712
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69710
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69711

lab69710:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69711:

lab69712:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69715
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69713
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69714

lab69713:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69714:

lab69715:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69718
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69716
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69717

lab69716:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69717:

lab69718:
    jmp lab69720

lab69719:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69720:

lab69722:
    ; #load tag
    mov r9, 5
    ; substitute (a !-> a)(x0 !-> x0)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a2 Node
    jmp r9

search_prune_:
    ; substitute (a0 !-> a0)(n !-> n)(f !-> f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new x0: Fun[Pair[List[Assign], ConflictSet], Bool] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69734
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69735

lab69734:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69732
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69725
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69723
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69724

lab69723:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69724:

lab69725:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69728
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69726
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69727

lab69726:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69727:

lab69728:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69731
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69729
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69730

lab69729:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69730:

lab69731:
    jmp lab69733

lab69732:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69733:

lab69735:
    ; #load tag
    lea r9, [rel Fun_Pair_List_Assign_ConflictSet_Bool_69736]
    ; substitute (x0 !-> x0)(n !-> n)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_filter_tree_
    jmp search_filter_tree_

Fun_Pair_List_Assign_ConflictSet_Bool_69736:

Fun_Pair_List_Assign_ConflictSet_Bool_69736_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69738
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab69737
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69737:
    jmp lab69739

lab69738:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab69739:
    ; substitute (x !-> x)(f !-> f)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a2: Bool = (a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69751
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69752

lab69751:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69749
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69742
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69740
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69741

lab69740:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69741:

lab69742:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69745
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69743
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69744

lab69743:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69744:

lab69745:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69748
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69746
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69747

lab69746:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69747:

lab69748:
    jmp lab69750

lab69749:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69750:

lab69752:
    ; #load tag
    lea r9, [rel Bool_69753]
    ; substitute (x !-> x)(a2 !-> a2)(f !-> f);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke f Ap
    jmp r9

Bool_69753:
    jmp near Bool_69753_True
    jmp near Bool_69753_False

Bool_69753_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69755
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab69754
    ; ####increment refcount
    add qword [rax + 0], 1

lab69754:
    jmp lab69756

lab69755:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab69756:
    ; let x1: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 !-> x1)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_69753_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69758
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab69757
    ; ####increment refcount
    add qword [rax + 0], 1

lab69757:
    jmp lab69759

lab69758:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab69759:
    ; let x1: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x1 !-> x1)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

search_map2_:
    ; substitute (f !-> f)(a0 !-> a0)(l !-> l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_69760]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_69760:
    jmp near List_Node_Pair_List_Assign_ConflictSet_69760_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_69760_Cons

List_Node_Pair_List_Assign_ConflictSet_69760_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab69763
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab69761
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab69762

lab69761:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab69762:

lab69763:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_69760_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69766
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69764
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69764:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69765
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69765:
    jmp lab69767

lab69766:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69767:
    ; substitute (f0 !-> f)(n !-> n)(a0 !-> a0)(ns !-> ns)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab69768
    ; ####increment refcount
    add qword [rax + 0], 1

lab69768:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: List[Pair[List[Assign], ConflictSet]] = (a0, ns, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69780
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69781

lab69780:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69778
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69771
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69769
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69770

lab69769:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69770:

lab69771:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69774
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69772
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69773

lab69772:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69773:

lab69774:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69777
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69775
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69776

lab69775:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69776:

lab69777:
    jmp lab69779

lab69778:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69779:

lab69781:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_69782]
    ; substitute (n !-> n)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

List_Pair_List_Assign_ConflictSet_69782:
    jmp near List_Pair_List_Assign_ConflictSet_69782_Nil
    jmp near List_Pair_List_Assign_ConflictSet_69782_Cons

List_Pair_List_Assign_ConflictSet_69782_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69786
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab69783
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69783:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab69784
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69784:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab69785
    ; ####increment refcount
    add qword [rax + 0], 1

lab69785:
    jmp lab69787

lab69786:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab69787:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 !-> a0)(f !-> f)(ns !-> ns)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_search_map2_0_
    jmp lift_search_map2_0_

List_Pair_List_Assign_ConflictSet_69782_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69791
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab69788
    ; ####increment refcount
    add qword [r12 + 0], 1

lab69788:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab69789
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69789:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab69790
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69790:
    jmp lab69792

lab69791:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab69792:
    ; substitute (f !-> f)(ns !-> ns)(a0 !-> a0)(a4 !-> a4)(as1 !-> as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69804
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab69805

lab69804:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69802
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69795
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69793
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69794

lab69793:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69794:

lab69795:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69798
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69796
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69797

lab69796:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69797:

lab69798:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69801
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69799
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69800

lab69799:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69800:

lab69801:
    jmp lab69803

lab69802:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69803:

lab69805:
    ; #load tag
    mov r11, 5
    ; substitute (a0 !-> a0)(f !-> f)(ns !-> ns)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_search_map2_0_
    jmp lift_search_map2_0_

lift_search_map2_0_:
    ; substitute (ns !-> ns)(f !-> f)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a2: List[List[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69817
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69818

lab69817:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69815
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69808
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69806
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69807

lab69806:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69807:

lab69808:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69811
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69809
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69810

lab69809:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69810:

lab69811:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69814
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69812
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69813

lab69812:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69813:

lab69814:
    jmp lab69816

lab69815:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69816:

lab69818:
    ; #load tag
    lea r9, [rel List_List_Pair_List_Assign_ConflictSet_69819]
    ; substitute (f !-> f)(ns !-> ns)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_map2_
    jmp search_map2_

List_List_Pair_List_Assign_ConflictSet_69819:
    jmp near List_List_Pair_List_Assign_ConflictSet_69819_Nil
    jmp near List_List_Pair_List_Assign_ConflictSet_69819_Cons

List_List_Pair_List_Assign_ConflictSet_69819_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69822
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab69820
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69820:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab69821
    ; ####increment refcount
    add qword [rax + 0], 1

lab69821:
    jmp lab69823

lab69822:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab69823:
    ; let x1: List[List[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Pair_List_Assign_ConflictSet_69819_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69826
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69824
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69824:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69825
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69825:
    jmp lab69827

lab69826:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69827:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69839
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69840

lab69839:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69837
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69830
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69828
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69829

lab69828:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69829:

lab69830:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69833
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69831
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69832

lab69831:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69832:

lab69833:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69836
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69834
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69835

lab69834:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69835:

lab69836:
    jmp lab69838

lab69837:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69838:

lab69840:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

search_concat2_:
    ; substitute (a0 !-> a0)(l2 !-> l2)(l1 !-> l1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch l1 \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_69841]
    add rcx, r9
    jmp rcx

List_Pair_List_Assign_ConflictSet_69841:
    jmp near List_Pair_List_Assign_ConflictSet_69841_Nil
    jmp near List_Pair_List_Assign_ConflictSet_69841_Cons

List_Pair_List_Assign_ConflictSet_69841_Nil:
    ; switch l2 \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_69842]
    add rcx, rdi
    jmp rcx

List_Pair_List_Assign_ConflictSet_69842:
    jmp near List_Pair_List_Assign_ConflictSet_69842_Nil
    jmp near List_Pair_List_Assign_ConflictSet_69842_Cons

List_Pair_List_Assign_ConflictSet_69842_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Pair_List_Assign_ConflictSet_69842_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab69845
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab69843
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69843:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab69844
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69844:
    jmp lab69846

lab69845:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab69846:
    ; substitute (a2 !-> a2)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_List_Assign_ConflictSet_69841_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69849
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69847
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69847:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69848
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69848:
    jmp lab69850

lab69849:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69850:
    ; substitute (ps !-> ps)(l2 !-> l2)(p !-> p)(a0 !-> a0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; new a1: List[Pair[List[Assign], ConflictSet]] = (p, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69862
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69863

lab69862:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69860
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69853
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69851
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69852

lab69851:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69852:

lab69853:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69856
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69854
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69855

lab69854:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69855:

lab69856:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69859
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69857
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69858

lab69857:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69858:

lab69859:
    jmp lab69861

lab69860:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69861:

lab69863:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_69864]
    ; jump search_concat2_
    jmp search_concat2_

List_Pair_List_Assign_ConflictSet_69864:
    jmp near List_Pair_List_Assign_ConflictSet_69864_Nil
    jmp near List_Pair_List_Assign_ConflictSet_69864_Cons

List_Pair_List_Assign_ConflictSet_69864_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69867
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab69865
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69865:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab69866
    ; ####increment refcount
    add qword [rax + 0], 1

lab69866:
    jmp lab69868

lab69867:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab69868:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (p !-> p)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_List_Assign_ConflictSet_69864_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69871
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69869
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69869:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69870
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69870:
    jmp lab69872

lab69871:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69872:
    ; substitute (a0 !-> a0)(p !-> p)(a3 !-> a3)(as1 !-> as1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Cons(a3, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69884
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69885

lab69884:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69882
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69875
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69873
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69874

lab69873:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69874:

lab69875:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69878
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69876
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69877

lab69876:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69877:

lab69878:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69881
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69879
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69880

lab69879:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69880:

lab69881:
    jmp lab69883

lab69882:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69883:

lab69885:
    ; #load tag
    mov r9, 5
    ; substitute (p !-> p)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

search_concat_:
    ; substitute (a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_Pair_List_Assign_ConflictSet_69886]
    add rcx, rdi
    jmp rcx

List_List_Pair_List_Assign_ConflictSet_69886:
    jmp near List_List_Pair_List_Assign_ConflictSet_69886_Nil
    jmp near List_List_Pair_List_Assign_ConflictSet_69886_Cons

List_List_Pair_List_Assign_ConflictSet_69886_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_Pair_List_Assign_ConflictSet_69886_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab69889
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab69887
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69887:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab69888
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69888:
    jmp lab69890

lab69889:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab69890:
    ; substitute (ls0 !-> ls0)(l !-> l)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a1: List[Pair[List[Assign], ConflictSet]] = (l, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69902
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69903

lab69902:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69900
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69893
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69891
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69892

lab69891:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69892:

lab69893:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69896
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69894
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69895

lab69894:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69895:

lab69896:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69899
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69897
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69898

lab69897:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69898:

lab69899:
    jmp lab69901

lab69900:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69901:

lab69903:
    ; #load tag
    lea rdi, [rel List_Pair_List_Assign_ConflictSet_69904]
    ; jump search_concat_
    jmp search_concat_

List_Pair_List_Assign_ConflictSet_69904:
    jmp near List_Pair_List_Assign_ConflictSet_69904_Nil
    jmp near List_Pair_List_Assign_ConflictSet_69904_Cons

List_Pair_List_Assign_ConflictSet_69904_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69907
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab69905
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69905:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab69906
    ; ####increment refcount
    add qword [rax + 0], 1

lab69906:
    jmp lab69908

lab69907:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab69908:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (l !-> l)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_concat2_
    jmp search_concat2_

List_Pair_List_Assign_ConflictSet_69904_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69911
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69909
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69909:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69910
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69910:
    jmp lab69912

lab69911:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69912:
    ; substitute (a0 !-> a0)(l !-> l)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69924
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69925

lab69924:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69922
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69915
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69913
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69914

lab69913:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69914:

lab69915:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69918
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69916
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69917

lab69916:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69917:

lab69918:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69921
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69919
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69920

lab69919:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69920:

lab69921:
    jmp lab69923

lab69922:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69923:

lab69925:
    ; #load tag
    mov r9, 5
    ; substitute (l !-> l)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_concat2_
    jmp search_concat2_

search_leaves_:
    ; substitute (a0 !-> a0)(n !-> n);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch n \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_Pair_List_Assign_ConflictSet_69926:

Node_Pair_List_Assign_ConflictSet_69926_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab69929
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab69927
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69927:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab69928
    ; ####increment refcount
    add qword [rsi + 0], 1

lab69928:
    jmp lab69930

lab69929:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab69930:
    ; switch cs \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_69931]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_69931:
    jmp near List_Node_Pair_List_Assign_ConflictSet_69931_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_69931_Cons

List_Node_Pair_List_Assign_ConflictSet_69931_Nil:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (leaf !-> leaf)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_69931_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69934
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69932
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69932:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69933
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69933:
    jmp lab69935

lab69934:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69935:
    ; substitute (cs0 !-> cs0)(c !-> c)(a0 !-> a0);
    ; #erase leaf
    cmp rsi, 0
    je lab69938
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab69936
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab69937

lab69936:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab69937:

lab69938:
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rdi, r9
    mov r9, rdx
    mov rax, r10
    mov rdx, r11
    ; new a1: List[List[Pair[List[Assign], ConflictSet]]] = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69950
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69951

lab69950:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69948
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69941
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69939
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69940

lab69939:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69940:

lab69941:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69944
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69942
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69943

lab69942:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69943:

lab69944:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69947
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69945
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69946

lab69945:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69946:

lab69947:
    jmp lab69949

lab69948:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69949:

lab69951:
    ; #load tag
    lea r9, [rel List_List_Pair_List_Assign_ConflictSet_69952]
    ; new x2: Fun[Node[Pair[List[Assign], ConflictSet]], List[Pair[List[Assign], ConflictSet]]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Node_Pair_List_Assign_ConflictSet_List_Pair_List_Assign_ConflictSet_69953]
    ; substitute (x2 !-> x2)(a1 !-> a1)(c !-> c)(cs0 !-> cs0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; let x3: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(c, cs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69965
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab69966

lab69965:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69963
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69956
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69954
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69955

lab69954:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69955:

lab69956:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69959
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69957
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69958

lab69957:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69958:

lab69959:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69962
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69960
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69961

lab69960:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69961:

lab69962:
    jmp lab69964

lab69963:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69964:

lab69966:
    ; #load tag
    mov r9, 5
    ; substitute (x2 !-> x2)(x3 !-> x3)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_map2_
    jmp search_map2_

Fun_Node_Pair_List_Assign_ConflictSet_List_Pair_List_Assign_ConflictSet_69953:

Fun_Node_Pair_List_Assign_ConflictSet_List_Pair_List_Assign_ConflictSet_69953_Ap:
    ; jump search_leaves_
    jmp search_leaves_

List_List_Pair_List_Assign_ConflictSet_69952:
    jmp near List_List_Pair_List_Assign_ConflictSet_69952_Nil
    jmp near List_List_Pair_List_Assign_ConflictSet_69952_Cons

List_List_Pair_List_Assign_ConflictSet_69952_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab69968
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab69967
    ; ####increment refcount
    add qword [rax + 0], 1

lab69967:
    jmp lab69969

lab69968:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab69969:
    ; let x1: List[List[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_concat_
    jmp search_concat_

List_List_Pair_List_Assign_ConflictSet_69952_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69971
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab69970
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69970:
    jmp lab69972

lab69971:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab69972:
    ; substitute (a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x1: List[List[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab69984
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab69985

lab69984:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab69982
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69975
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69973
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69974

lab69973:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69974:

lab69975:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab69978
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69976
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69977

lab69976:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69977:

lab69978:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab69981
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69979
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69980

lab69979:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69980:

lab69981:
    jmp lab69983

lab69982:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab69983:

lab69985:
    ; #load tag
    mov rdi, 5
    ; substitute (x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_concat_
    jmp search_concat_

search_filter2_:
    ; substitute (f !-> f)(a0 !-> a0)(l !-> l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_69986]
    add rcx, r9
    jmp rcx

List_Pair_List_Assign_ConflictSet_69986:
    jmp near List_Pair_List_Assign_ConflictSet_69986_Nil
    jmp near List_Pair_List_Assign_ConflictSet_69986_Cons

List_Pair_List_Assign_ConflictSet_69986_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab69989
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab69987
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab69988

lab69987:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab69988:

lab69989:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Pair_List_Assign_ConflictSet_69986_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab69992
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab69990
    ; ####increment refcount
    add qword [r10 + 0], 1

lab69990:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab69991
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69991:
    jmp lab69993

lab69992:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab69993:
    ; substitute (f0 !-> f)(p0 !-> p)(p !-> p)(ps !-> ps)(f !-> f)(a0 !-> a0);
    ; #share f
    cmp rax, 0
    je lab69994
    ; ####increment refcount
    add qword [rax + 0], 1

lab69994:
    ; #share p
    cmp r8, 0
    je lab69995
    ; ####increment refcount
    add qword [r8 + 0], 1

lab69995:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rsi, r8
    mov rdi, r9
    ; new a2: Bool = (p, ps, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70007
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab70008

lab70007:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70005
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab69998
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69996
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab69997

lab69996:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab69997:

lab69998:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70001
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab69999
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70000

lab69999:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70000:

lab70001:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70004
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70002
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70003

lab70002:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70003:

lab70004:
    jmp lab70006

lab70005:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70006:

lab70008:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70020
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70021

lab70020:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70018
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70011
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70009
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70010

lab70009:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70010:

lab70011:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70014
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70012
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70013

lab70012:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70013:

lab70014:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70017
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70015
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70016

lab70015:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70016:

lab70017:
    jmp lab70019

lab70018:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70019:

lab70021:
    ; #load tag
    lea r9, [rel Bool_70022]
    ; substitute (p0 !-> p0)(a2 !-> a2)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Bool_70022:
    jmp near Bool_70022_True
    jmp near Bool_70022_False

Bool_70022_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70027
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab70023
    ; ####increment refcount
    add qword [rax + 0], 1

lab70023:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab70024
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70024:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab70025
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70025:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab70026
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70026:
    jmp lab70028

lab70027:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab70028:
    ; substitute (f !-> f)(ps !-> ps)(p !-> p)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a1: List[Pair[List[Assign], ConflictSet]] = (p, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70040
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70041

lab70040:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70038
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70031
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70029
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70030

lab70029:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70030:

lab70031:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70034
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70032
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70033

lab70032:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70033:

lab70034:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70037
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70035
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70036

lab70035:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70036:

lab70037:
    jmp lab70039

lab70038:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70039:

lab70041:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_70042]
    ; jump search_filter2_
    jmp search_filter2_

List_Pair_List_Assign_ConflictSet_70042:
    jmp near List_Pair_List_Assign_ConflictSet_70042_Nil
    jmp near List_Pair_List_Assign_ConflictSet_70042_Cons

List_Pair_List_Assign_ConflictSet_70042_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70045
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab70043
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70043:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab70044
    ; ####increment refcount
    add qword [rax + 0], 1

lab70044:
    jmp lab70046

lab70045:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab70046:
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (p !-> p)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_List_Assign_ConflictSet_70042_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70049
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70047
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70047:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70048
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70048:
    jmp lab70050

lab70049:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70050:
    ; substitute (a0 !-> a0)(p !-> p)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: List[Pair[List[Assign], ConflictSet]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70062
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70063

lab70062:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70060
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70053
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70051
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70052

lab70051:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70052:

lab70053:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70056
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70054
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70055

lab70054:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70055:

lab70056:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70059
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70057
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70058

lab70057:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70058:

lab70059:
    jmp lab70061

lab70060:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70061:

lab70063:
    ; #load tag
    mov r9, 5
    ; substitute (p !-> p)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_70022_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70068
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab70064
    ; ####increment refcount
    add qword [rax + 0], 1

lab70064:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab70065
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70065:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab70066
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70066:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab70067
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70067:
    jmp lab70069

lab70068:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab70069:
    ; substitute (f !-> f)(ps !-> ps)(a0 !-> a0);
    ; #erase p
    cmp rax, 0
    je lab70072
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab70070
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab70071

lab70070:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab70071:

lab70072:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump search_filter2_
    jmp search_filter2_

search_map3_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_70073]
    add rcx, r9
    jmp rcx

List_Pair_List_Assign_ConflictSet_70073:
    jmp near List_Pair_List_Assign_ConflictSet_70073_Nil
    jmp near List_Pair_List_Assign_ConflictSet_70073_Cons

List_Pair_List_Assign_ConflictSet_70073_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab70076
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab70074
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab70075

lab70074:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab70075:

lab70076:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Pair_List_Assign_ConflictSet_70073_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70079
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70077
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70077:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70078
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70078:
    jmp lab70080

lab70079:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70080:
    ; substitute (f0 !-> f)(p !-> p)(a0 !-> a0)(ps !-> ps)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab70081
    ; ####increment refcount
    add qword [rax + 0], 1

lab70081:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: List[Assign] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70093
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70094

lab70093:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70091
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70084
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70082
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70083

lab70082:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70083:

lab70084:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70087
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70085
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70086

lab70085:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70086:

lab70087:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70090
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70088
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70089

lab70088:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70089:

lab70090:
    jmp lab70092

lab70091:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70092:

lab70094:
    ; #load tag
    lea r9, [rel List_Assign_70095]
    ; substitute (p !-> p)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

List_Assign_70095:
    jmp near List_Assign_70095_Nil
    jmp near List_Assign_70095_Cons

List_Assign_70095_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70099
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab70096
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70096:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab70097
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70097:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab70098
    ; ####increment refcount
    add qword [rax + 0], 1

lab70098:
    jmp lab70100

lab70099:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab70100:
    ; let x0: List[Assign] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 !-> a0)(f !-> f)(ps !-> ps)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_search_map3_0_
    jmp lift_search_map3_0_

List_Assign_70095_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70104
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab70101
    ; ####increment refcount
    add qword [r12 + 0], 1

lab70101:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab70102
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70102:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab70103
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70103:
    jmp lab70105

lab70104:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab70105:
    ; substitute (f !-> f)(ps !-> ps)(a0 !-> a0)(a4 !-> a4)(as1 !-> as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Assign] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70117
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab70118

lab70117:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70115
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70108
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70106
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70107

lab70106:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70107:

lab70108:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70111
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70109
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70110

lab70109:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70110:

lab70111:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70114
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70112
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70113

lab70112:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70113:

lab70114:
    jmp lab70116

lab70115:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70116:

lab70118:
    ; #load tag
    mov r11, 5
    ; substitute (a0 !-> a0)(f !-> f)(ps !-> ps)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_search_map3_0_
    jmp lift_search_map3_0_

lift_search_map3_0_:
    ; substitute (ps !-> ps)(f !-> f)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a2: List[List[Assign]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70130
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70131

lab70130:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70128
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70121
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70119
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70120

lab70119:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70120:

lab70121:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70124
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70122
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70123

lab70122:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70123:

lab70124:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70127
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70125
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70126

lab70125:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70126:

lab70127:
    jmp lab70129

lab70128:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70129:

lab70131:
    ; #load tag
    lea r9, [rel List_List_Assign_70132]
    ; substitute (f !-> f)(ps !-> ps)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_map3_
    jmp search_map3_

List_List_Assign_70132:
    jmp near List_List_Assign_70132_Nil
    jmp near List_List_Assign_70132_Cons

List_List_Assign_70132_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70135
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab70133
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70133:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab70134
    ; ####increment refcount
    add qword [rax + 0], 1

lab70134:
    jmp lab70136

lab70135:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab70136:
    ; let x1: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Assign_70132_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70139
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70137
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70137:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70138
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70138:
    jmp lab70140

lab70139:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70140:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[Assign]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70152
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70153

lab70152:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70150
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70143
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70141
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70142

lab70141:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70142:

lab70143:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70146
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70144
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70145

lab70144:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70145:

lab70146:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70149
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70147
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70148

lab70147:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70148:

lab70149:
    jmp lab70151

lab70150:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70151:

lab70153:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

search_fst_:
    ; substitute (a0 !-> a0)(p !-> p);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch p \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_List_Assign_ConflictSet_70154:

Pair_List_Assign_ConflictSet_70154_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab70157
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab70155
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70155:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab70156
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70156:
    jmp lab70158

lab70157:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab70158:
    ; substitute (a0 !-> a0)(l !-> l);
    ; #erase c
    cmp r8, 0
    je lab70161
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab70159
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab70160

lab70159:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab70160:

lab70161:
    ; switch l \{ ... \};
    lea rcx, [rel List_Assign_70162]
    add rcx, rdi
    jmp rcx

List_Assign_70162:
    jmp near List_Assign_70162_Nil
    jmp near List_Assign_70162_Cons

List_Assign_70162_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Assign_70162_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab70165
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab70163
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70163:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab70164
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70164:
    jmp lab70166

lab70165:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab70166:
    ; substitute (a1 !-> a1)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

search_snd_:
    ; substitute (a0 !-> a0)(p !-> p);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch p \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_List_Assign_ConflictSet_70167:

Pair_List_Assign_ConflictSet_70167_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab70170
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab70168
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70168:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab70169
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70169:
    jmp lab70171

lab70170:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab70171:
    ; substitute (a0 !-> a0)(c !-> c);
    ; #erase l
    cmp rsi, 0
    je lab70174
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab70172
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab70173

lab70172:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab70173:

lab70174:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; switch c \{ ... \};
    lea rcx, [rel ConflictSet_70175]
    add rcx, rdi
    jmp rcx

ConflictSet_70175:
    jmp near ConflictSet_70175_Known
    jmp near ConflictSet_70175_Unknown

ConflictSet_70175_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab70177
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab70176
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70176:
    jmp lab70178

lab70177:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab70178:
    ; substitute (vs0 !-> vs0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Known
    add rdi, 0
    jmp rdi

ConflictSet_70175_Unknown:
    ; invoke a0 Unknown
    add rdx, 5
    jmp rdx

search_:
    ; new x2: Fun[Pair[List[Assign], ConflictSet], List[Assign]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Pair_List_Assign_ConflictSet_List_Assign_70179]
    ; new a2: List[Pair[List[Assign], ConflictSet]] = (a0, x2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70191
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70192

lab70191:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70189
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70182
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70180
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70181

lab70180:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70181:

lab70182:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70185
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70183
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70184

lab70183:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70184:

lab70185:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70188
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70186
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70187

lab70186:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70187:

lab70188:
    jmp lab70190

lab70189:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70190:

lab70192:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_70193]
    ; new x4: Fun[Pair[List[Assign], ConflictSet], Bool] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Pair_List_Assign_ConflictSet_Bool_70194]
    ; new a5: List[Pair[List[Assign], ConflictSet]] = (a2, x4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70206
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70207

lab70206:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70204
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70197
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70195
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70196

lab70195:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70196:

lab70197:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70200
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70198
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70199

lab70198:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70199:

lab70200:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70203
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70201
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70202

lab70201:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70202:

lab70203:
    jmp lab70205

lab70204:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70205:

lab70207:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_70208]
    ; new a6: Node[Pair[List[Assign], ConflictSet]] = (a5)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70220
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70221

lab70220:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70218
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70211
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70209
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70210

lab70209:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70210:

lab70211:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70214
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70212
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70213

lab70212:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70213:

lab70214:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70217
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70215
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70216

lab70215:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70216:

lab70217:
    jmp lab70219

lab70218:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70219:

lab70221:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_70222]
    ; new x7: Fun[Pair[List[Assign], ConflictSet], Bool] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Pair_List_Assign_ConflictSet_Bool_70223]
    ; new a9: Node[Pair[List[Assign], ConflictSet]] = (a6, x7)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70235
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70236

lab70235:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70233
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70226
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70224
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70225

lab70224:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70225:

lab70226:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70229
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70227
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70228

lab70227:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70228:

lab70229:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70232
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70230
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70231

lab70230:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70231:

lab70232:
    jmp lab70234

lab70233:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70234:

lab70236:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_70237]
    ; substitute (csp0 !-> csp)(csp !-> csp)(a9 !-> a9)(labeler !-> labeler);
    ; #share csp
    cmp rsi, 0
    je lab70238
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70238:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rax, rsi
    mov rdx, rdi
    ; new a10: Node[List[Assign]] = (csp, a9, labeler)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70250
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab70251

lab70250:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70248
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70241
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70239
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70240

lab70239:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70240:

lab70241:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70244
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70242
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70243

lab70242:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70243:

lab70244:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70247
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70245
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70246

lab70245:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70246:

lab70247:
    jmp lab70249

lab70248:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70249:

lab70251:
    ; #load tag
    lea rdi, [rel Node_List_Assign_70252]
    ; jump mk_tree_
    jmp mk_tree_

Node_List_Assign_70252:

Node_List_Assign_70252_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70256
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab70253
    ; ####increment refcount
    add qword [r12 + 0], 1

lab70253:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab70254
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70254:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab70255
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70255:
    jmp lab70257

lab70256:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab70257:
    ; substitute (labeler !-> labeler)(a9 !-> a9)(csp !-> csp)(lab2 !-> lab2)(children2 !-> children2);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x9: Node[List[Assign]] = Node(lab2, children2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70269
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab70270

lab70269:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70267
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70260
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70258
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70259

lab70258:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70259:

lab70260:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70263
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70261
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70262

lab70261:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70262:

lab70263:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70266
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70264
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70265

lab70264:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70265:

lab70266:
    jmp lab70268

lab70267:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70268:

lab70270:
    ; #load tag
    mov r11, 0
    ; substitute (labeler !-> labeler)(csp !-> csp)(x9 !-> x9)(a9 !-> a9);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rcx
    ; let a11: Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = Ap(x9, a9);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70282
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70283

lab70282:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70280
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70273
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70271
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70272

lab70271:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70272:

lab70273:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70276
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70274
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70275

lab70274:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70275:

lab70276:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70279
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70277
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70278

lab70277:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70278:

lab70279:
    jmp lab70281

lab70280:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70281:

lab70283:
    ; #load tag
    mov r9, 0
    ; substitute (csp !-> csp)(a11 !-> a11)(labeler !-> labeler);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke labeler Ap
    jmp r9

Node_Pair_List_Assign_ConflictSet_70237:

Node_Pair_List_Assign_ConflictSet_70237_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70286
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70284
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70284:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70285
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70285:
    jmp lab70287

lab70286:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70287:
    ; substitute (x7 !-> x7)(a6 !-> a6)(lab1 !-> lab1)(children1 !-> children1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x8: Node[Pair[List[Assign], ConflictSet]] = Node(lab1, children1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70299
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70300

lab70299:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70297
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70290
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70288
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70289

lab70288:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70289:

lab70290:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70293
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70291
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70292

lab70291:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70292:

lab70293:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70296
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70294
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70295

lab70294:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70295:

lab70296:
    jmp lab70298

lab70297:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70298:

lab70300:
    ; #load tag
    mov r9, 0
    ; substitute (x7 !-> x7)(x8 !-> x8)(a6 !-> a6);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_prune_
    jmp search_prune_

Fun_Pair_List_Assign_ConflictSet_Bool_70223:

Fun_Pair_List_Assign_ConflictSet_Bool_70223_Ap:
    ; new a8: ConflictSet = (a7)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70312
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab70313

lab70312:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70310
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70303
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70301
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70302

lab70301:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70302:

lab70303:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70306
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70304
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70305

lab70304:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70305:

lab70306:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70309
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70307
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70308

lab70307:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70308:

lab70309:
    jmp lab70311

lab70310:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70311:

lab70313:
    ; #load tag
    lea rdi, [rel ConflictSet_70314]
    ; jump search_snd_
    jmp search_snd_

ConflictSet_70314:
    jmp near ConflictSet_70314_Known
    jmp near ConflictSet_70314_Unknown

ConflictSet_70314_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab70316
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab70315
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70315:
    jmp lab70317

lab70316:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab70317:
    ; substitute (a7 !-> a7)(vs1 !-> vs1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x10: ConflictSet = Known(vs1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70329
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab70330

lab70329:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70327
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70320
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70318
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70319

lab70318:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70319:

lab70320:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70323
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70321
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70322

lab70321:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70322:

lab70323:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70326
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70324
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70325

lab70324:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70325:

lab70326:
    jmp lab70328

lab70327:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70328:

lab70330:
    ; #load tag
    mov rdi, 0
    ; substitute (x10 !-> x10)(a7 !-> a7);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump known_conflict_
    jmp known_conflict_

ConflictSet_70314_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70332
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab70331
    ; ####increment refcount
    add qword [rax + 0], 1

lab70331:
    jmp lab70333

lab70332:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab70333:
    ; let x10: ConflictSet = Unknown();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x10 !-> x10)(a7 !-> a7);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump known_conflict_
    jmp known_conflict_

Node_Pair_List_Assign_ConflictSet_70222:

Node_Pair_List_Assign_ConflictSet_70222_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70335
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab70334
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70334:
    jmp lab70336

lab70335:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab70336:
    ; substitute (a5 !-> a5)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x6: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70348
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab70349

lab70348:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70346
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70339
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70337
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70338

lab70337:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70338:

lab70339:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70342
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70340
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70341

lab70340:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70341:

lab70342:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70345
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70343
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70344

lab70343:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70344:

lab70345:
    jmp lab70347

lab70346:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70347:

lab70349:
    ; #load tag
    mov rdi, 0
    ; substitute (x6 !-> x6)(a5 !-> a5);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump search_leaves_
    jmp search_leaves_

List_Pair_List_Assign_ConflictSet_70208:
    jmp near List_Pair_List_Assign_ConflictSet_70208_Nil
    jmp near List_Pair_List_Assign_ConflictSet_70208_Cons

List_Pair_List_Assign_ConflictSet_70208_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70352
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab70350
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70350:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab70351
    ; ####increment refcount
    add qword [rax + 0], 1

lab70351:
    jmp lab70353

lab70352:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab70353:
    ; let x5: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x4 !-> x4)(x5 !-> x5)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_filter2_
    jmp search_filter2_

List_Pair_List_Assign_ConflictSet_70208_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70356
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70354
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70354:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70355
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70355:
    jmp lab70357

lab70356:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70357:
    ; substitute (x4 !-> x4)(a2 !-> a2)(a13 !-> a13)(as1 !-> as1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x5: List[Pair[List[Assign], ConflictSet]] = Cons(a13, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70369
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70370

lab70369:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70367
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70360
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70358
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70359

lab70358:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70359:

lab70360:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70363
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70361
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70362

lab70361:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70362:

lab70363:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70366
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70364
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70365

lab70364:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70365:

lab70366:
    jmp lab70368

lab70367:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70368:

lab70370:
    ; #load tag
    mov r9, 5
    ; substitute (x4 !-> x4)(x5 !-> x5)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_filter2_
    jmp search_filter2_

Fun_Pair_List_Assign_ConflictSet_Bool_70194:

Fun_Pair_List_Assign_ConflictSet_Bool_70194_Ap:
    ; new a4: ConflictSet = (a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70382
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab70383

lab70382:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70380
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70373
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70371
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70372

lab70371:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70372:

lab70373:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70376
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70374
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70375

lab70374:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70375:

lab70376:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70379
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70377
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70378

lab70377:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70378:

lab70379:
    jmp lab70381

lab70380:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70381:

lab70383:
    ; #load tag
    lea rdi, [rel ConflictSet_70384]
    ; jump search_snd_
    jmp search_snd_

ConflictSet_70384:
    jmp near ConflictSet_70384_Known
    jmp near ConflictSet_70384_Unknown

ConflictSet_70384_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab70386
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab70385
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70385:
    jmp lab70387

lab70386:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab70387:
    ; substitute (a3 !-> a3)(vs0 !-> vs0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x11: ConflictSet = Known(vs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70399
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab70400

lab70399:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70397
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70390
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70388
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70389

lab70388:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70389:

lab70390:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70393
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70391
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70392

lab70391:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70392:

lab70393:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70396
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70394
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70395

lab70394:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70395:

lab70396:
    jmp lab70398

lab70397:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70398:

lab70400:
    ; #load tag
    mov rdi, 0
    ; substitute (x11 !-> x11)(a3 !-> a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump known_solution_
    jmp known_solution_

ConflictSet_70384_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70402
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab70401
    ; ####increment refcount
    add qword [rax + 0], 1

lab70401:
    jmp lab70403

lab70402:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab70403:
    ; let x11: ConflictSet = Unknown();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x11 !-> x11)(a3 !-> a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump known_solution_
    jmp known_solution_

List_Pair_List_Assign_ConflictSet_70193:
    jmp near List_Pair_List_Assign_ConflictSet_70193_Nil
    jmp near List_Pair_List_Assign_ConflictSet_70193_Cons

List_Pair_List_Assign_ConflictSet_70193_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70406
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab70404
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70404:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab70405
    ; ####increment refcount
    add qword [rax + 0], 1

lab70405:
    jmp lab70407

lab70406:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab70407:
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x2 !-> x2)(x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_map3_
    jmp search_map3_

List_Pair_List_Assign_ConflictSet_70193_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70410
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70408
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70408:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70409
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70409:
    jmp lab70411

lab70410:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70411:
    ; substitute (x2 !-> x2)(a0 !-> a0)(a12 !-> a12)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Cons(a12, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70423
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70424

lab70423:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70421
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70414
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70412
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70413

lab70412:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70413:

lab70414:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70417
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70415
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70416

lab70415:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70416:

lab70417:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70420
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70418
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70419

lab70418:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70419:

lab70420:
    jmp lab70422

lab70421:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70422:

lab70424:
    ; #load tag
    mov r9, 5
    ; substitute (x2 !-> x2)(x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump search_map3_
    jmp search_map3_

Fun_Pair_List_Assign_ConflictSet_List_Assign_70179:

Fun_Pair_List_Assign_ConflictSet_List_Assign_70179_Ap:
    ; jump search_fst_
    jmp search_fst_

bt_map_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Node_List_Assign_70425]
    add rcx, r9
    jmp rcx

List_Node_List_Assign_70425:
    jmp near List_Node_List_Assign_70425_Nil
    jmp near List_Node_List_Assign_70425_Cons

List_Node_List_Assign_70425_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab70428
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab70426
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab70427

lab70426:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab70427:

lab70428:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_List_Assign_70425_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70431
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70429
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70429:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70430
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70430:
    jmp lab70432

lab70431:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70432:
    ; substitute (f0 !-> f)(n !-> n)(a0 !-> a0)(ns !-> ns)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab70433
    ; ####increment refcount
    add qword [rax + 0], 1

lab70433:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ns, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70445
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70446

lab70445:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70443
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70436
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70434
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70435

lab70434:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70435:

lab70436:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70439
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70437
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70438

lab70437:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70438:

lab70439:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70442
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70440
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70441

lab70440:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70441:

lab70442:
    jmp lab70444

lab70443:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70444:

lab70446:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_70447]
    ; substitute (n !-> n)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Node_Pair_List_Assign_ConflictSet_70447:

Node_Pair_List_Assign_ConflictSet_70447_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70451
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab70448
    ; ####increment refcount
    add qword [r12 + 0], 1

lab70448:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab70449
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70449:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab70450
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70450:
    jmp lab70452

lab70451:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab70452:
    ; substitute (f !-> f)(ns !-> ns)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70464
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab70465

lab70464:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70462
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70455
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70453
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70454

lab70453:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70454:

lab70455:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70458
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70456
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70457

lab70456:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70457:

lab70458:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70461
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70459
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70460

lab70459:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70460:

lab70461:
    jmp lab70463

lab70462:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70463:

lab70465:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70477
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70478

lab70477:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70475
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70468
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70466
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70467

lab70466:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70467:

lab70468:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70471
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70469
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70470

lab70469:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70470:

lab70471:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70474
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70472
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70473

lab70472:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70473:

lab70474:
    jmp lab70476

lab70475:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70476:

lab70478:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_70479]
    ; jump bt_map_
    jmp bt_map_

List_Node_Pair_List_Assign_ConflictSet_70479:
    jmp near List_Node_Pair_List_Assign_ConflictSet_70479_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_70479_Cons

List_Node_Pair_List_Assign_ConflictSet_70479_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70482
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab70480
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70480:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab70481
    ; ####increment refcount
    add qword [rax + 0], 1

lab70481:
    jmp lab70483

lab70482:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab70483:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_70479_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70486
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70484
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70484:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70485
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70485:
    jmp lab70487

lab70486:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70487:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70499
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70500

lab70499:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70497
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70490
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70488
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70489

lab70488:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70489:

lab70490:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70493
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70491
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70492

lab70491:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70492:

lab70493:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70496
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70494
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70495

lab70494:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70495:

lab70496:
    jmp lab70498

lab70497:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70498:

lab70500:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bt_map_tree_:
    ; substitute (f !-> f)(a0 !-> a0)(n !-> n);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch n \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_List_Assign_70501:

Node_List_Assign_70501_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70504
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70502
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70502:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70503
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70503:
    jmp lab70505

lab70504:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70505:
    ; substitute (f0 !-> f)(l !-> l)(a0 !-> a0)(ls !-> ls)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab70506
    ; ####increment refcount
    add qword [rax + 0], 1

lab70506:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Pair[List[Assign], ConflictSet] = (a0, ls, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70518
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70519

lab70518:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70516
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70509
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70507
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70508

lab70507:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70508:

lab70509:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70512
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70510
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70511

lab70510:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70511:

lab70512:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70515
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70513
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70514

lab70513:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70514:

lab70515:
    jmp lab70517

lab70516:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70517:

lab70519:
    ; #load tag
    lea r9, [rel Pair_List_Assign_ConflictSet_70520]
    ; substitute (l !-> l)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Pair_List_Assign_ConflictSet_70520:

Pair_List_Assign_ConflictSet_70520_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70524
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab70521
    ; ####increment refcount
    add qword [r12 + 0], 1

lab70521:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab70522
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70522:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab70523
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70523:
    jmp lab70525

lab70524:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab70525:
    ; substitute (f !-> f)(ls !-> ls)(a0 !-> a0)(a5 !-> a5)(b0 !-> b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a5, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70537
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab70538

lab70537:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70535
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70528
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70526
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70527

lab70526:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70527:

lab70528:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70531
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70529
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70530

lab70529:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70530:

lab70531:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70534
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70532
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70533

lab70532:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70533:

lab70534:
    jmp lab70536

lab70535:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70536:

lab70538:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70550
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70551

lab70550:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70548
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70541
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70539
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70540

lab70539:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70540:

lab70541:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70544
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70542
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70543

lab70542:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70543:

lab70544:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70547
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70545
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70546

lab70545:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70546:

lab70547:
    jmp lab70549

lab70548:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70549:

lab70551:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_70552]
    ; substitute (a2 !-> a2)(ls !-> ls)(f !-> f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new x2: Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70564
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70565

lab70564:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70562
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70555
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70553
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70554

lab70553:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70554:

lab70555:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70558
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70556
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70557

lab70556:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70557:

lab70558:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70561
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70559
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70560

lab70559:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70560:

lab70561:
    jmp lab70563

lab70562:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70563:

lab70565:
    ; #load tag
    lea r9, [rel Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_70566]
    ; substitute (x2 !-> x2)(ls !-> ls)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bt_map_
    jmp bt_map_

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_70566:

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_70566_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70568
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab70567
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70567:
    jmp lab70569

lab70568:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab70569:
    ; substitute (f !-> f)(x !-> x)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bt_map_tree_
    jmp bt_map_tree_

List_Node_Pair_List_Assign_ConflictSet_70552:
    jmp near List_Node_Pair_List_Assign_ConflictSet_70552_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_70552_Cons

List_Node_Pair_List_Assign_ConflictSet_70552_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70572
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab70570
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70570:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab70571
    ; ####increment refcount
    add qword [rax + 0], 1

lab70571:
    jmp lab70573

lab70572:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab70573:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_70552_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70576
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70574
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70574:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70575
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70575:
    jmp lab70577

lab70576:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70577:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70589
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70590

lab70589:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70587
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70580
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70578
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70579

lab70578:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70579:

lab70580:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70583
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70581
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70582

lab70581:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70582:

lab70583:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70586
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70584
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70585

lab70584:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70585:

lab70586:
    jmp lab70588

lab70587:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70588:

lab70590:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    jmp r9

bt_:
    ; substitute (a0 !-> a0)(t !-> t)(csp !-> csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new f3: Fun[List[Assign], Pair[List[Assign], ConflictSet]] = (csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70602
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70603

lab70602:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70600
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70593
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70591
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70592

lab70591:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70592:

lab70593:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70596
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70594
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70595

lab70594:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70595:

lab70596:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70599
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70597
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70598

lab70597:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70598:

lab70599:
    jmp lab70601

lab70600:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70601:

lab70603:
    ; #load tag
    lea r9, [rel Fun_List_Assign_Pair_List_Assign_ConflictSet_70604]
    ; substitute (f3 !-> f3)(t !-> t)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bt_map_tree_
    jmp bt_map_tree_

Fun_List_Assign_Pair_List_Assign_ConflictSet_70604:

Fun_List_Assign_Pair_List_Assign_ConflictSet_70604_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70606
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab70605
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70605:
    jmp lab70607

lab70606:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab70607:
    ; substitute (s0 !-> s)(csp !-> csp)(a1 !-> a1)(s !-> s);
    ; #share s
    cmp rax, 0
    je lab70608
    ; ####increment refcount
    add qword [rax + 0], 1

lab70608:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a2: ConflictSet = (a1, s)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70620
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70621

lab70620:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70618
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70611
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70609
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70610

lab70609:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70610:

lab70611:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70614
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70612
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70613

lab70612:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70613:

lab70614:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70617
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70615
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70616

lab70615:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70616:

lab70617:
    jmp lab70619

lab70618:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70619:

lab70621:
    ; #load tag
    lea r9, [rel ConflictSet_70622]
    ; substitute (s00 !-> s0)(csp0 !-> csp)(a2 !-> a2)(s0 !-> s0)(csp !-> csp);
    ; #share csp
    cmp rsi, 0
    je lab70623
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70623:
    ; #share s0
    cmp rax, 0
    je lab70624
    ; ####increment refcount
    add qword [rax + 0], 1

lab70624:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov r12, rsi
    mov r13, rdi
    ; new a3: Option[Pair[i64, i64]] = (a2, s0, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70636
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70637

lab70636:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70634
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70627
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70625
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70626

lab70625:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70626:

lab70627:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70630
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70628
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70629

lab70628:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70629:

lab70630:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70633
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70631
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70632

lab70631:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70632:

lab70633:
    jmp lab70635

lab70634:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70635:

lab70637:
    ; #load tag
    lea r9, [rel Option_Pair_i64_i64_70638]
    ; substitute (csp0 !-> csp0)(s00 !-> s00)(a3 !-> a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump earliest_inconsistency_
    jmp earliest_inconsistency_

Option_Pair_i64_i64_70638:
    jmp near Option_Pair_i64_i64_70638_None
    jmp near Option_Pair_i64_i64_70638_Some

Option_Pair_i64_i64_70638_None:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70642
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab70639
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70639:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab70640
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70640:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab70641
    ; ####increment refcount
    add qword [rax + 0], 1

lab70641:
    jmp lab70643

lab70642:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab70643:
    ; substitute (csp !-> csp)(s0 !-> s0)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump check_complete_
    jmp check_complete_

Option_Pair_i64_i64_70638_Some:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab70647
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab70644
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70644:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab70645
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70645:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab70646
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70646:
    jmp lab70648

lab70647:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab70648:
    ; substitute (a2 !-> a2)(p !-> p);
    ; #erase csp
    cmp r10, 0
    je lab70651
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab70649
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab70650

lab70649:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab70650:

lab70651:
    ; #erase s0
    cmp r8, 0
    je lab70654
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab70652
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab70653

lab70652:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab70653:

lab70654:
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch p \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_i64_i64_70655:

Pair_i64_i64_70655_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab70656
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    jmp lab70657

lab70656:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]

lab70657:
    ; let x3: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; let x2: List[i64] = Cons(b, x3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70669
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70670

lab70669:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70667
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70660
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70658
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70659

lab70658:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70659:

lab70660:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70663
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70661
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70662

lab70661:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70662:

lab70663:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70666
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70664
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70665

lab70664:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70665:

lab70666:
    jmp lab70668

lab70667:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70668:

lab70670:
    ; #load tag
    mov r9, 5
    ; let x1: List[i64] = Cons(a, x2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70682
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab70683

lab70682:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70680
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70673
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70671
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70672

lab70671:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70672:

lab70673:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70676
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70674
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70675

lab70674:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70675:

lab70676:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70679
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70677
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70678

lab70677:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70678:

lab70679:
    jmp lab70681

lab70680:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70681:

lab70683:
    ; #load tag
    mov rdi, 5
    ; substitute (x1 !-> x1)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a2 Known
    add rdi, 0
    jmp rdi

ConflictSet_70622:
    jmp near ConflictSet_70622_Known
    jmp near ConflictSet_70622_Unknown

ConflictSet_70622_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab70686
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab70684
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70684:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab70685
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70685:
    jmp lab70687

lab70686:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab70687:
    ; substitute (s !-> s)(a1 !-> a1)(vs0 !-> vs0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: ConflictSet = Known(vs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70699
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70700

lab70699:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70697
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70690
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70688
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70689

lab70688:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70689:

lab70690:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70693
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70691
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70692

lab70691:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70692:

lab70693:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70696
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70694
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70695

lab70694:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70695:

lab70696:
    jmp lab70698

lab70697:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70698:

lab70700:
    ; #load tag
    mov r9, 0
    ; substitute (s !-> s)(x0 !-> x0)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a1 Tup
    jmp r9

ConflictSet_70622_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70703
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab70701
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70701:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab70702
    ; ####increment refcount
    add qword [rax + 0], 1

lab70702:
    jmp lab70704

lab70703:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab70704:
    ; let x0: ConflictSet = Unknown();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 5
    ; substitute (s !-> s)(x0 !-> x0)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Tup
    jmp r9

empt_lscomp2_:
    ; substitute (a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_70705]
    add rcx, rdi
    jmp rcx

List_i64_70705:
    jmp near List_i64_70705_Nil
    jmp near List_i64_70705_Cons

List_i64_70705_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_70705_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab70707
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab70706
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70706:
    mov rdi, [rsi + 40]
    jmp lab70708

lab70707:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab70708:
    ; substitute (a0 !-> a0)(t2 !-> t2);
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; let x0: ConflictSet = Unknown();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 5
    ; substitute (t2 !-> t2)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; new a1: List[ConflictSet] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70720
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab70721

lab70720:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70718
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70711
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70709
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70710

lab70709:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70710:

lab70711:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70714
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70712
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70713

lab70712:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70713:

lab70714:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70717
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70715
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70716

lab70715:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70716:

lab70717:
    jmp lab70719

lab70718:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70719:

lab70721:
    ; #load tag
    lea rdi, [rel List_ConflictSet_70722]
    ; jump empt_lscomp2_
    jmp empt_lscomp2_

List_ConflictSet_70722:
    jmp near List_ConflictSet_70722_Nil
    jmp near List_ConflictSet_70722_Cons

List_ConflictSet_70722_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70725
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab70723
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70723:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab70724
    ; ####increment refcount
    add qword [rax + 0], 1

lab70724:
    jmp lab70726

lab70725:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab70726:
    ; let x1: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_ConflictSet_70722_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70729
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70727
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70727:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70728
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70728:
    jmp lab70730

lab70729:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70730:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[ConflictSet] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70742
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70743

lab70742:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70740
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70733
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70731
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70732

lab70731:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70732:

lab70733:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70736
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70734
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70735

lab70734:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70735:

lab70736:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70739
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70737
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70738

lab70737:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70738:

lab70739:
    jmp lab70741

lab70740:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70741:

lab70743:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

empt_lscomp1_:
    ; substitute (a0 !-> a0)(vals !-> vals)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_70744]
    add rcx, r9
    jmp rcx

List_i64_70744:
    jmp near List_i64_70744_Nil
    jmp near List_i64_70744_Cons

List_i64_70744_Nil:
    ; substitute (a0 !-> a0);
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_70744_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70746
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70745
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70745:
    mov r9, [r8 + 40]
    jmp lab70747

lab70746:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab70747:
    ; substitute (vals0 !-> vals)(vals !-> vals)(a0 !-> a0)(t1 !-> t1);
    ; #move variables
    mov r8, rax
    mov r9, rdx
    mov rdx, rdi
    ; new a1: List[ConflictSet] = (vals, a0, t1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70759
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab70760

lab70759:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70757
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70750
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70748
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70749

lab70748:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70749:

lab70750:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70753
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70751
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70752

lab70751:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70752:

lab70753:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70756
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70754
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70755

lab70754:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70755:

lab70756:
    jmp lab70758

lab70757:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70758:

lab70760:
    ; #load tag
    lea rdi, [rel List_ConflictSet_70761]
    ; new a2: List[i64] = (a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70773
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab70774

lab70773:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70771
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70764
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70762
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70763

lab70762:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70763:

lab70764:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70767
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70765
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70766

lab70765:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70766:

lab70767:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70770
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70768
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70769

lab70768:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70769:

lab70770:
    jmp lab70772

lab70771:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70772:

lab70774:
    ; #load tag
    lea rdi, [rel List_i64_70775]
    ; lit x2 <- 1;
    mov r9, 1
    ; substitute (x2 !-> x2)(vals0 !-> vals0)(a2 !-> a2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_70775:
    jmp near List_i64_70775_Nil
    jmp near List_i64_70775_Cons

List_i64_70775_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70777
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab70776
    ; ####increment refcount
    add qword [rax + 0], 1

lab70776:
    jmp lab70778

lab70777:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab70778:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 !-> x1)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump empt_lscomp2_
    jmp empt_lscomp2_

List_i64_70775_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70780
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab70779
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70779:
    jmp lab70781

lab70780:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab70781:
    ; substitute (a1 !-> a1)(a6 !-> a6)(as2 !-> as2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; let x1: List[i64] = Cons(a6, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70793
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab70794

lab70793:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70791
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70784
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70782
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70783

lab70782:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70783:

lab70784:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70787
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70785
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70786

lab70785:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70786:

lab70787:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70790
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70788
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70789

lab70788:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70789:

lab70790:
    jmp lab70792

lab70791:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70792:

lab70794:
    ; #load tag
    mov rdi, 5
    ; substitute (x1 !-> x1)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump empt_lscomp2_
    jmp empt_lscomp2_

List_ConflictSet_70761:
    jmp near List_ConflictSet_70761_Nil
    jmp near List_ConflictSet_70761_Cons

List_ConflictSet_70761_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70797
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab70795
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70795:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab70796
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70796:
    mov rdx, [rax + 24]
    jmp lab70798

lab70797:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]

lab70798:
    ; let x0: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 !-> a0)(t1 !-> t1)(vals !-> vals)(x0 !-> x0);
    ; #move variables
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, rsi
    mov rsi, r8
    ; jump lift_empt_lscomp1_0_
    jmp lift_empt_lscomp1_0_

List_ConflictSet_70761_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70801
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab70799
    ; ####increment refcount
    add qword [r12 + 0], 1

lab70799:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab70800
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70800:
    mov r9, [r8 + 24]
    jmp lab70802

lab70801:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab70802:
    ; substitute (t1 !-> t1)(a0 !-> a0)(vals !-> vals)(a5 !-> a5)(as1 !-> as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[ConflictSet] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70814
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab70815

lab70814:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70812
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70805
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70803
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70804

lab70803:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70804:

lab70805:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70808
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70806
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70807

lab70806:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70807:

lab70808:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70811
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70809
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70810

lab70809:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70810:

lab70811:
    jmp lab70813

lab70812:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70813:

lab70815:
    ; #load tag
    mov r11, 5
    ; substitute (a0 !-> a0)(t1 !-> t1)(vals !-> vals)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_empt_lscomp1_0_
    jmp lift_empt_lscomp1_0_

lift_empt_lscomp1_0_:
    ; substitute (vals !-> vals)(t1 !-> t1)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov r8, rax
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a3: List[List[ConflictSet]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70827
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70828

lab70827:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70825
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70818
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70816
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70817

lab70816:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70817:

lab70818:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70821
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70819
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70820

lab70819:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70820:

lab70821:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70824
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70822
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70823

lab70822:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70823:

lab70824:
    jmp lab70826

lab70825:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70826:

lab70828:
    ; #load tag
    lea r9, [rel List_List_ConflictSet_70829]
    ; substitute (t1 !-> t1)(vals !-> vals)(a3 !-> a3);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump empt_lscomp1_
    jmp empt_lscomp1_

List_List_ConflictSet_70829:
    jmp near List_List_ConflictSet_70829_Nil
    jmp near List_List_ConflictSet_70829_Cons

List_List_ConflictSet_70829_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70832
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab70830
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70830:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab70831
    ; ####increment refcount
    add qword [rax + 0], 1

lab70831:
    jmp lab70833

lab70832:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab70833:
    ; let x3: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_ConflictSet_70829_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70836
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70834
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70834:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70835
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70835:
    jmp lab70837

lab70836:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70837:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x3: List[List[ConflictSet]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70849
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70850

lab70849:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70847
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70840
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70838
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70839

lab70838:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70839:

lab70840:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70843
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70841
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70842

lab70841:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70842:

lab70843:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70846
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70844
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70845

lab70844:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70845:

lab70846:
    jmp lab70848

lab70847:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70848:

lab70850:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

empty_table_:
    ; substitute (a0 !-> a0)(csp !-> csp);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #if there is only one clause, we can just fall through

CSP_70851:

CSP_70851_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab70853
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab70852
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70852:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab70854

lab70853:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab70854:
    ; substitute (a0 !-> a0)(vars !-> vars)(vals !-> vals);
    ; #erase rel
    cmp r10, 0
    je lab70857
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab70855
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab70856

lab70855:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab70856:

lab70857:
    ; let x0: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (vals !-> vals)(vars !-> vars)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov r8, rax
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a1: List[List[ConflictSet]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70869
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70870

lab70869:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70867
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70860
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70858
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70859

lab70858:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70859:

lab70860:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70863
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70861
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70862

lab70861:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70862:

lab70863:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70866
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70864
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70865

lab70864:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70865:

lab70866:
    jmp lab70868

lab70867:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70868:

lab70870:
    ; #load tag
    lea r9, [rel List_List_ConflictSet_70871]
    ; substitute (vars !-> vars)(vals !-> vals)(a1 !-> a1);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; new a2: List[i64] = (vals, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70883
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab70884

lab70883:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70881
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70874
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70872
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70873

lab70872:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70873:

lab70874:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70877
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70875
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70876

lab70875:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70876:

lab70877:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70880
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70878
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70879

lab70878:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70879:

lab70880:
    jmp lab70882

lab70881:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70882:

lab70884:
    ; #load tag
    lea rdi, [rel List_i64_70885]
    ; lit x3 <- 1;
    mov r9, 1
    ; substitute (x3 !-> x3)(vars !-> vars)(a2 !-> a2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_70885:
    jmp near List_i64_70885_Nil
    jmp near List_i64_70885_Cons

List_i64_70885_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70887
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab70886
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70886:
    mov rdx, [rax + 40]
    jmp lab70888

lab70887:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab70888:
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x2 !-> x2)(vals !-> vals)(a1 !-> a1);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump empt_lscomp1_
    jmp empt_lscomp1_

List_i64_70885_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70890
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70889
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70889:
    mov r9, [r8 + 40]
    jmp lab70891

lab70890:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab70891:
    ; substitute (a1 !-> a1)(vals !-> vals)(a4 !-> a4)(as1 !-> as1);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x2: List[i64] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70903
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70904

lab70903:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70901
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70894
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70892
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70893

lab70892:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70893:

lab70894:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70897
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70895
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70896

lab70895:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70896:

lab70897:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70900
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70898
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70899

lab70898:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70899:

lab70900:
    jmp lab70902

lab70901:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70902:

lab70904:
    ; #load tag
    mov r9, 5
    ; substitute (x2 !-> x2)(vals !-> vals)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump empt_lscomp1_
    jmp empt_lscomp1_

List_List_ConflictSet_70871:
    jmp near List_List_ConflictSet_70871_Nil
    jmp near List_List_ConflictSet_70871_Cons

List_List_ConflictSet_70871_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70907
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab70905
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70905:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab70906
    ; ####increment refcount
    add qword [rax + 0], 1

lab70906:
    jmp lab70908

lab70907:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab70908:
    ; let x1: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_ConflictSet_70871_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70911
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70909
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70909:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70910
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70910:
    jmp lab70912

lab70911:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70912:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[ConflictSet]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70924
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70925

lab70924:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70922
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70915
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70913
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70914

lab70913:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70914:

lab70915:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70918
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70916
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70917

lab70916:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70917:

lab70918:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70921
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70919
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70920

lab70919:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70920:

lab70921:
    jmp lab70923

lab70922:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70923:

lab70925:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

fill_lscomp2_:
    ; substitute (a0 !-> a0)(varrr !-> varrr)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_70926]
    add rcx, r9
    jmp rcx

List_i64_70926:
    jmp near List_i64_70926_Nil
    jmp near List_i64_70926_Cons

List_i64_70926_Nil:
    ; substitute (a0 !-> a0);
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_70926_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70928
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70927
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70927:
    mov r9, [r8 + 40]
    jmp lab70929

lab70928:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab70929:
    ; substitute (a0 !-> a0)(varrr !-> varrr)(t2 !-> t2)(varrr0 !-> varrr)(valll !-> valll);
    ; #move variables
    mov r13, r9
    mov r9, r11
    mov r11, rdi
    mov r8, r10
    ; let x0: Pair[i64, i64] = Tup(varrr0, valll);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70941
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab70942

lab70941:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70939
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70932
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70930
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70931

lab70930:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70931:

lab70932:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70935
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70933
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70934

lab70933:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70934:

lab70935:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70938
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70936
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70937

lab70936:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70937:

lab70938:
    jmp lab70940

lab70939:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70940:

lab70942:
    ; #load tag
    mov r11, 0
    ; substitute (t2 !-> t2)(varrr !-> varrr)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a1: List[Pair[i64, i64]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70954
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70955

lab70954:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70952
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70945
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70943
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70944

lab70943:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70944:

lab70945:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70948
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70946
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70947

lab70946:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70947:

lab70948:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70951
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70949
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70950

lab70949:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70950:

lab70951:
    jmp lab70953

lab70952:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70953:

lab70955:
    ; #load tag
    lea r9, [rel List_Pair_i64_i64_70956]
    ; jump fill_lscomp2_
    jmp fill_lscomp2_

List_Pair_i64_i64_70956:
    jmp near List_Pair_i64_i64_70956_Nil
    jmp near List_Pair_i64_i64_70956_Cons

List_Pair_i64_i64_70956_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab70959
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab70957
    ; ####increment refcount
    add qword [rsi + 0], 1

lab70957:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab70958
    ; ####increment refcount
    add qword [rax + 0], 1

lab70958:
    jmp lab70960

lab70959:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab70960:
    ; let x1: List[Pair[i64, i64]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_i64_i64_70956_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70963
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70961
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70961:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab70962
    ; ####increment refcount
    add qword [r8 + 0], 1

lab70962:
    jmp lab70964

lab70963:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab70964:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Pair[i64, i64]] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70976
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70977

lab70976:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70974
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70967
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70965
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70966

lab70965:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70966:

lab70967:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70970
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70968
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70969

lab70968:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70969:

lab70970:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70973
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70971
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70972

lab70971:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70972:

lab70973:
    jmp lab70975

lab70974:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70975:

lab70977:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

fill_lscomp1_:
    ; substitute (a0 !-> a0)(vals !-> vals)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_70978]
    add rcx, r9
    jmp rcx

List_i64_70978:
    jmp near List_i64_70978_Nil
    jmp near List_i64_70978_Cons

List_i64_70978_Nil:
    ; substitute (a0 !-> a0);
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_70978_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab70980
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab70979
    ; ####increment refcount
    add qword [r10 + 0], 1

lab70979:
    mov r9, [r8 + 40]
    jmp lab70981

lab70980:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab70981:
    ; substitute (varrr !-> varrr)(vals0 !-> vals)(vals !-> vals)(t1 !-> t1)(a0 !-> a0);
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rdx, r9
    mov r9, rdi
    ; new a1: List[Pair[i64, i64]] = (vals, t1, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab70993
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab70994

lab70993:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab70991
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70984
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70982
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70983

lab70982:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70983:

lab70984:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab70987
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70985
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70986

lab70985:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70986:

lab70987:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab70990
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70988
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70989

lab70988:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70989:

lab70990:
    jmp lab70992

lab70991:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab70992:

lab70994:
    ; #load tag
    lea r9, [rel List_Pair_i64_i64_70995]
    ; substitute (vals0 !-> vals0)(varrr !-> varrr)(a1 !-> a1);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; new a2: List[i64] = (varrr, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71007
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab71008

lab71007:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71005
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab70998
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70996
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab70997

lab70996:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab70997:

lab70998:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71001
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab70999
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71000

lab70999:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71000:

lab71001:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71004
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71002
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71003

lab71002:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71003:

lab71004:
    jmp lab71006

lab71005:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71006:

lab71008:
    ; #load tag
    lea rdi, [rel List_i64_71009]
    ; lit x2 <- 1;
    mov r9, 1
    ; substitute (x2 !-> x2)(vals0 !-> vals0)(a2 !-> a2);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov r8, rsi
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_71009:
    jmp near List_i64_71009_Nil
    jmp near List_i64_71009_Cons

List_i64_71009_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71011
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab71010
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71010:
    mov rdx, [rax + 40]
    jmp lab71012

lab71011:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab71012:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x1 !-> x1)(varrr !-> varrr)(a1 !-> a1);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump fill_lscomp2_
    jmp fill_lscomp2_

List_i64_71009_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71014
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab71013
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71013:
    mov r9, [r8 + 40]
    jmp lab71015

lab71014:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab71015:
    ; substitute (a1 !-> a1)(varrr !-> varrr)(a6 !-> a6)(as2 !-> as2);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x1: List[i64] = Cons(a6, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71027
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71028

lab71027:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71025
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71018
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71016
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71017

lab71016:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71017:

lab71018:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71021
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71019
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71020

lab71019:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71020:

lab71021:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71024
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71022
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71023

lab71022:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71023:

lab71024:
    jmp lab71026

lab71025:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71026:

lab71028:
    ; #load tag
    mov r9, 5
    ; substitute (x1 !-> x1)(varrr !-> varrr)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump fill_lscomp2_
    jmp fill_lscomp2_

List_Pair_i64_i64_70995:
    jmp near List_Pair_i64_i64_70995_Nil
    jmp near List_Pair_i64_i64_70995_Cons

List_Pair_i64_i64_70995_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71031
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab71029
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71029:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab71030
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71030:
    mov rdx, [rax + 24]
    jmp lab71032

lab71031:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]

lab71032:
    ; let x0: List[Pair[i64, i64]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 !-> a0)(t1 !-> t1)(vals !-> vals)(x0 !-> x0);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r8
    ; jump lift_fill_lscomp1_0_
    jmp lift_fill_lscomp1_0_

List_Pair_i64_i64_70995_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71035
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab71033
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71033:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab71034
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71034:
    mov r9, [r8 + 24]
    jmp lab71036

lab71035:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab71036:
    ; substitute (a0 !-> a0)(t1 !-> t1)(vals !-> vals)(a5 !-> a5)(as1 !-> as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Pair[i64, i64]] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71048
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab71049

lab71048:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71046
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71039
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71037
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71038

lab71037:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71038:

lab71039:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71042
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71040
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71041

lab71040:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71041:

lab71042:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71045
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71043
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71044

lab71043:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71044:

lab71045:
    jmp lab71047

lab71046:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71047:

lab71049:
    ; #load tag
    mov r11, 5
    ; jump lift_fill_lscomp1_0_
    jmp lift_fill_lscomp1_0_

lift_fill_lscomp1_0_:
    ; substitute (vals !-> vals)(t1 !-> t1)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov r8, rax
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a3: List[List[Pair[i64, i64]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71061
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71062

lab71061:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71059
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71052
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71050
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71051

lab71050:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71051:

lab71052:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71055
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71053
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71054

lab71053:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71054:

lab71055:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71058
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71056
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71057

lab71056:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71057:

lab71058:
    jmp lab71060

lab71059:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71060:

lab71062:
    ; #load tag
    lea r9, [rel List_List_Pair_i64_i64_71063]
    ; substitute (t1 !-> t1)(vals !-> vals)(a3 !-> a3);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump fill_lscomp1_
    jmp fill_lscomp1_

List_List_Pair_i64_i64_71063:
    jmp near List_List_Pair_i64_i64_71063_Nil
    jmp near List_List_Pair_i64_i64_71063_Cons

List_List_Pair_i64_i64_71063_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71066
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab71064
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71064:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab71065
    ; ####increment refcount
    add qword [rax + 0], 1

lab71065:
    jmp lab71067

lab71066:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab71067:
    ; let x3: List[List[Pair[i64, i64]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_Pair_i64_i64_71063_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71070
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab71068
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71068:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab71069
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71069:
    jmp lab71071

lab71070:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab71071:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x3: List[List[Pair[i64, i64]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71083
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71084

lab71083:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71081
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71074
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71072
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71073

lab71072:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71073:

lab71074:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71077
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71075
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71076

lab71075:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71076:

lab71077:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71080
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71078
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71079

lab71078:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71079:

lab71080:
    jmp lab71082

lab71081:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71082:

lab71084:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

fill_zip_with_:
    ; substitute (f !-> f)(a0 !-> a0)(y !-> y)(x !-> x);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch x \{ ... \};
    lea rcx, [rel List_ConflictSet_71085]
    add rcx, r11
    jmp rcx

List_ConflictSet_71085:
    jmp near List_ConflictSet_71085_Nil
    jmp near List_ConflictSet_71085_Cons

List_ConflictSet_71085_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab71088
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab71086
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab71087

lab71086:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab71087:

lab71088:
    ; #erase y
    cmp r8, 0
    je lab71091
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab71089
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab71090

lab71089:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab71090:

lab71091:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_ConflictSet_71085_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab71094
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab71092
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71092:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab71093
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71093:
    jmp lab71095

lab71094:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab71095:
    ; substitute (f !-> f)(a0 !-> a0)(cs !-> cs)(c !-> c)(y !-> y);
    ; #move variables
    mov rcx, r12
    mov r12, r8
    mov r8, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    ; switch y \{ ... \};
    lea rcx, [rel List_Pair_i64_i64_71096]
    add rcx, r13
    jmp rcx

List_Pair_i64_i64_71096:
    jmp near List_Pair_i64_i64_71096_Nil
    jmp near List_Pair_i64_i64_71096_Cons

List_Pair_i64_i64_71096_Nil:
    ; substitute (a0 !-> a0);
    ; #erase c
    cmp r10, 0
    je lab71099
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab71097
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab71098

lab71097:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab71098:

lab71099:
    ; #erase cs
    cmp r8, 0
    je lab71102
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab71100
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab71101

lab71100:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab71101:

lab71102:
    ; #erase f
    cmp rax, 0
    je lab71105
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab71103
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab71104

lab71103:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab71104:

lab71105:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Pair_i64_i64_71096_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab71108
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab71106
    ; ####increment refcount
    add qword [r14 + 0], 1

lab71106:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab71107
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71107:
    jmp lab71109

lab71108:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab71109:
    ; substitute (f0 !-> f)(p !-> p)(c !-> c)(cs !-> cs)(a0 !-> a0)(ps !-> ps)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab71110
    ; ####increment refcount
    add qword [rax + 0], 1

lab71110:
    ; #move variables
    mov [rsp + 2032], rax
    mov [rsp + 2024], rdx
    mov rcx, r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; new a1: ConflictSet = (cs, a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71122
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab71123

lab71122:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71120
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71113
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71111
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71112

lab71111:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71112:

lab71113:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71116
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71114
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71115

lab71114:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71115:

lab71116:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71119
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71117
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71118

lab71117:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71118:

lab71119:
    jmp lab71121

lab71120:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71121:

lab71123:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71135
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab71136

lab71135:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71133
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71126
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71124
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71125

lab71124:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71125:

lab71126:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71129
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71127
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71128

lab71127:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71128:

lab71129:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71132
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71130
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71131

lab71130:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71131:

lab71132:
    jmp lab71134

lab71133:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71134:

lab71136:
    ; #load tag
    lea r11, [rel ConflictSet_71137]
    ; substitute (f0 !-> f0)(c !-> c)(p !-> p)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; let a3: Fun[Pair[i64, i64], ConflictSet] = Ap(p, a1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71149
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71150

lab71149:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71147
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71140
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71138
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71139

lab71138:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71139:

lab71140:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71143
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71141
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71142

lab71141:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71142:

lab71143:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71146
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71144
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71145

lab71144:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71145:

lab71146:
    jmp lab71148

lab71147:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71148:

lab71150:
    ; #load tag
    mov r9, 0
    ; substitute (c !-> c)(a3 !-> a3)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

ConflictSet_71137:
    jmp near ConflictSet_71137_Known
    jmp near ConflictSet_71137_Unknown

ConflictSet_71137_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab71155
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab71151
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71151:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab71152
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71152:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab71153
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71153:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab71154
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71154:
    jmp lab71156

lab71155:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab71156:
    ; substitute (f !-> f)(cs !-> cs)(a0 !-> a0)(ps !-> ps)(vs0 !-> vs0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    ; let x0: ConflictSet = Known(vs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71168
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab71169

lab71168:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71166
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71159
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71157
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71158

lab71157:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71158:

lab71159:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71162
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71160
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71161

lab71160:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71161:

lab71162:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71165
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71163
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71164

lab71163:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71164:

lab71165:
    jmp lab71167

lab71166:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71167:

lab71169:
    ; #load tag
    mov r13, 0
    ; substitute (a0 !-> a0)(cs !-> cs)(f !-> f)(ps !-> ps)(x0 !-> x0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_fill_zip_with_0_
    jmp lift_fill_zip_with_0_

ConflictSet_71137_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71174
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab71170
    ; ####increment refcount
    add qword [rax + 0], 1

lab71170:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab71171
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71171:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab71172
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71172:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab71173
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71173:
    jmp lab71175

lab71174:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab71175:
    ; let x0: ConflictSet = Unknown();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 5
    ; substitute (a0 !-> a0)(cs !-> cs)(f !-> f)(ps !-> ps)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; jump lift_fill_zip_with_0_
    jmp lift_fill_zip_with_0_

lift_fill_zip_with_0_:
    ; substitute (ps !-> ps)(cs !-> cs)(f !-> f)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; new a2: List[ConflictSet] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71187
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab71188

lab71187:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71185
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71178
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71176
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71177

lab71176:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71177:

lab71178:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71181
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71179
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71180

lab71179:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71180:

lab71181:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71184
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71182
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71183

lab71182:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71183:

lab71184:
    jmp lab71186

lab71185:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71186:

lab71188:
    ; #load tag
    lea r11, [rel List_ConflictSet_71189]
    ; substitute (f !-> f)(cs !-> cs)(ps !-> ps)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump fill_zip_with_
    jmp fill_zip_with_

List_ConflictSet_71189:
    jmp near List_ConflictSet_71189_Nil
    jmp near List_ConflictSet_71189_Cons

List_ConflictSet_71189_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71192
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab71190
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71190:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab71191
    ; ####increment refcount
    add qword [rax + 0], 1

lab71191:
    jmp lab71193

lab71192:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab71193:
    ; let x1: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_ConflictSet_71189_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71196
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab71194
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71194:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab71195
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71195:
    jmp lab71197

lab71196:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab71197:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[ConflictSet] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71209
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71210

lab71209:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71207
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71200
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71198
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71199

lab71198:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71199:

lab71200:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71203
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71201
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71202

lab71201:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71202:

lab71203:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71206
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71204
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71205

lab71204:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71205:

lab71206:
    jmp lab71208

lab71207:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71208:

lab71210:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

fill_zip_with2_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls)(tbl !-> tbl);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; switch tbl \{ ... \};
    lea rcx, [rel List_List_ConflictSet_71211]
    add rcx, r11
    jmp rcx

List_List_ConflictSet_71211:
    jmp near List_List_ConflictSet_71211_Nil
    jmp near List_List_ConflictSet_71211_Cons

List_List_ConflictSet_71211_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab71214
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab71212
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab71213

lab71212:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab71213:

lab71214:
    ; #erase ls
    cmp r8, 0
    je lab71217
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab71215
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab71216

lab71215:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab71216:

lab71217:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_71211_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab71220
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab71218
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71218:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab71219
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71219:
    jmp lab71221

lab71220:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab71221:
    ; substitute (f !-> f)(a0 !-> a0)(css !-> css)(cs !-> cs)(ls !-> ls);
    ; #move variables
    mov rcx, r12
    mov r12, r8
    mov r8, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_Pair_i64_i64_71222]
    add rcx, r13
    jmp rcx

List_List_Pair_i64_i64_71222:
    jmp near List_List_Pair_i64_i64_71222_Nil
    jmp near List_List_Pair_i64_i64_71222_Cons

List_List_Pair_i64_i64_71222_Nil:
    ; substitute (a0 !-> a0);
    ; #erase cs
    cmp r10, 0
    je lab71225
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab71223
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab71224

lab71223:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab71224:

lab71225:
    ; #erase css
    cmp r8, 0
    je lab71228
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab71226
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab71227

lab71226:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab71227:

lab71228:
    ; #erase f
    cmp rax, 0
    je lab71231
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab71229
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab71230

lab71229:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab71230:

lab71231:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_Pair_i64_i64_71222_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab71234
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab71232
    ; ####increment refcount
    add qword [r14 + 0], 1

lab71232:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab71233
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71233:
    jmp lab71235

lab71234:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab71235:
    ; substitute (f0 !-> f)(ps !-> ps)(cs !-> cs)(css !-> css)(a0 !-> a0)(pss !-> pss)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab71236
    ; ####increment refcount
    add qword [rax + 0], 1

lab71236:
    ; #move variables
    mov [rsp + 2032], rax
    mov [rsp + 2024], rdx
    mov rcx, r12
    mov r12, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; new a1: List[ConflictSet] = (css, a0, pss, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71248
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab71249

lab71248:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71246
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71239
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71237
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71238

lab71237:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71238:

lab71239:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71242
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71240
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71241

lab71240:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71241:

lab71242:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71245
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71243
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71244

lab71243:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71244:

lab71245:
    jmp lab71247

lab71246:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71247:

lab71249:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71261
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab71262

lab71261:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71259
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71252
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71250
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71251

lab71250:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71251:

lab71252:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71255
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71253
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71254

lab71253:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71254:

lab71255:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71258
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71256
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71257

lab71256:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71257:

lab71258:
    jmp lab71260

lab71259:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71260:

lab71262:
    ; #load tag
    lea r11, [rel List_ConflictSet_71263]
    ; substitute (f0 !-> f0)(cs !-> cs)(ps !-> ps)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; let a3: Fun[List[Pair[i64, i64]], List[ConflictSet]] = Ap(ps, a1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71275
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71276

lab71275:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71273
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71266
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71264
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71265

lab71264:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71265:

lab71266:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71269
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71267
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71268

lab71267:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71268:

lab71269:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71272
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71270
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71271

lab71270:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71271:

lab71272:
    jmp lab71274

lab71273:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71274:

lab71276:
    ; #load tag
    mov r9, 0
    ; substitute (cs !-> cs)(a3 !-> a3)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

List_ConflictSet_71263:
    jmp near List_ConflictSet_71263_Nil
    jmp near List_ConflictSet_71263_Cons

List_ConflictSet_71263_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71281
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab71277
    ; ####increment refcount
    add qword [rax + 0], 1

lab71277:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab71278
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71278:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab71279
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71279:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab71280
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71280:
    jmp lab71282

lab71281:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab71282:
    ; let x0: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 0
    ; substitute (a0 !-> a0)(css !-> css)(f !-> f)(pss !-> pss)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; jump lift_fill_zip_with2_0_
    jmp lift_fill_zip_with2_0_

List_ConflictSet_71263_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71287
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab71283
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71283:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab71284
    ; ####increment refcount
    add qword [r14 + 0], 1

lab71284:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab71285
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71285:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab71286
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71286:
    jmp lab71288

lab71287:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab71288:
    ; substitute (f !-> f)(pss !-> pss)(css !-> css)(a0 !-> a0)(a5 !-> a5)(as1 !-> as1);
    ; #move variables
    mov rcx, r14
    mov r14, rsi
    mov rsi, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdi
    mov rdi, r13
    mov r13, rdx
    mov rdx, rcx
    ; let x0: List[ConflictSet] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71300
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab71301

lab71300:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71298
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71291
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71289
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71290

lab71289:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71290:

lab71291:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71294
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71292
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71293

lab71292:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71293:

lab71294:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71297
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71295
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71296

lab71295:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71296:

lab71297:
    jmp lab71299

lab71298:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71299:

lab71301:
    ; #load tag
    mov r13, 5
    ; substitute (a0 !-> a0)(css !-> css)(f !-> f)(pss !-> pss)(x0 !-> x0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_fill_zip_with2_0_
    jmp lift_fill_zip_with2_0_

lift_fill_zip_with2_0_:
    ; substitute (pss !-> pss)(css !-> css)(f !-> f)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; new a2: List[List[ConflictSet]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71313
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab71314

lab71313:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71311
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71304
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71302
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71303

lab71302:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71303:

lab71304:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71307
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71305
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71306

lab71305:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71306:

lab71307:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71310
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71308
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71309

lab71308:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71309:

lab71310:
    jmp lab71312

lab71311:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71312:

lab71314:
    ; #load tag
    lea r11, [rel List_List_ConflictSet_71315]
    ; substitute (f !-> f)(css !-> css)(pss !-> pss)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump fill_zip_with2_
    jmp fill_zip_with2_

List_List_ConflictSet_71315:
    jmp near List_List_ConflictSet_71315_Nil
    jmp near List_List_ConflictSet_71315_Cons

List_List_ConflictSet_71315_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71318
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab71316
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71316:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab71317
    ; ####increment refcount
    add qword [rax + 0], 1

lab71317:
    jmp lab71319

lab71318:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab71319:
    ; let x1: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_ConflictSet_71315_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71322
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab71320
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71320:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab71321
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71321:
    jmp lab71323

lab71322:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab71323:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[ConflictSet]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71335
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71336

lab71335:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71333
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71326
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71324
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71325

lab71324:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71325:

lab71326:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71329
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71327
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71328

lab71327:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71328:

lab71329:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71332
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71330
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71331

lab71330:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71331:

lab71332:
    jmp lab71334

lab71333:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71334:

lab71336:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

fill_table_:
    ; substitute (a0 !-> a0)(csp !-> csp)(tbl !-> tbl)(s !-> s);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; switch s \{ ... \};
    lea rcx, [rel List_Assign_71337]
    add rcx, r11
    jmp rcx

List_Assign_71337:
    jmp near List_Assign_71337_Nil
    jmp near List_Assign_71337_Cons

List_Assign_71337_Nil:
    ; substitute (a0 !-> a0)(tbl !-> tbl);
    ; #erase csp
    cmp rsi, 0
    je lab71340
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab71338
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab71339

lab71338:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab71339:

lab71340:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; switch tbl \{ ... \};
    lea rcx, [rel List_List_ConflictSet_71341]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_71341:
    jmp near List_List_ConflictSet_71341_Nil
    jmp near List_List_ConflictSet_71341_Cons

List_List_ConflictSet_71341_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_71341_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab71344
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab71342
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71342:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab71343
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71343:
    jmp lab71345

lab71344:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab71345:
    ; substitute (a11 !-> a11)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Assign_71337_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab71348
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab71346
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71346:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab71347
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71347:
    jmp lab71349

lab71348:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab71349:
    ; substitute (a0 !-> a0)(csp !-> csp)(tbl !-> tbl)(as !-> as);
    ; #erase as_
    cmp r12, 0
    je lab71352
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab71350
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab71351

lab71350:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab71351:

lab71352:
    ; switch as \{ ... \};
    ; #if there is only one clause, we can just fall through

Assign_71353:

Assign_71353_Assign:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab71354
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]
    jmp lab71355

lab71354:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r11, [r10 + 40]

lab71355:
    ; substitute (a0 !-> a0)(val_ !-> val_)(tbl !-> tbl)(var_ !-> var_)(csp !-> csp);
    ; #move variables
    mov r12, rsi
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    ; switch csp \{ ... \};
    ; #if there is only one clause, we can just fall through

CSP_71356:

CSP_71356_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab71358
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab71357
    ; ####increment refcount
    add qword [rcx + 0], 1

lab71357:
    mov r15, [r12 + 40]
    mov r13, [r12 + 24]
    jmp lab71359

lab71358:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov rcx, [r12 + 56]
    mov [rsp + 2024], rcx
    mov rcx, [r12 + 48]
    mov [rsp + 2032], rcx
    mov r15, [r12 + 40]
    mov r13, [r12 + 24]

lab71359:
    ; substitute (a0 !-> a0)(vals !-> vals)(tbl !-> tbl)(var_1 !-> var_)(vars !-> vars)(var_ !-> var_)(rel !-> rel)(val_ !-> val_);
    ; #move variables
    mov [rsp + 2008], rdi
    mov rdi, r15
    mov r15, r11
    ; new f4: Fun[ConflictSet, Fun[Pair[i64, i64], ConflictSet]] = (var_, rel, val_)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    mov [rbx + 24], r15
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71371
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab71372

lab71371:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71369
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71362
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71360
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71361

lab71360:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71361:

lab71362:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71365
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71363
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71364

lab71363:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71364:

lab71365:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71368
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71366
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71367

lab71366:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71367:

lab71368:
    jmp lab71370

lab71369:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71370:

lab71372:
    ; #load tag
    lea r15, [rel Fun_ConflictSet_Fun_Pair_i64_i64_ConflictSet_71373]
    ; new x6: Fun[List[ConflictSet], Fun[List[Pair[i64, i64]], List[ConflictSet]]] = (f4)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71385
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab71386

lab71385:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71383
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71376
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71374
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71375

lab71374:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71375:

lab71376:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71379
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71377
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71378

lab71377:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71378:

lab71379:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71382
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71380
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71381

lab71380:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71381:

lab71382:
    jmp lab71384

lab71383:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71384:

lab71386:
    ; #load tag
    lea r15, [rel Fun_List_ConflictSet_Fun_List_Pair_i64_i64_List_ConflictSet_71387]
    ; substitute (vars !-> vars)(vals !-> vals)(var_1 !-> var_1)(tbl !-> tbl)(a0 !-> a0)(x6 !-> x6);
    ; #move variables
    mov r12, rax
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov r10, r8
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; new a3: List[List[Pair[i64, i64]]] = (tbl, a0, x6)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71399
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab71400

lab71399:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71397
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71390
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71388
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71389

lab71388:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71389:

lab71390:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71393
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71391
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71392

lab71391:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71392:

lab71393:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71396
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71394
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71395

lab71394:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71395:

lab71396:
    jmp lab71398

lab71397:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71398:

lab71400:
    ; #load tag
    lea r11, [rel List_List_Pair_i64_i64_71401]
    ; substitute (vars !-> vars)(var_1 !-> var_1)(vals !-> vals)(a3 !-> a3);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a4: List[i64] = (vals, a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71413
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71414

lab71413:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71411
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71404
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71402
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71403

lab71402:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71403:

lab71404:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71407
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71405
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71406

lab71405:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71406:

lab71407:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71410
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71408
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71409

lab71408:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71409:

lab71410:
    jmp lab71412

lab71411:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71412:

lab71414:
    ; #load tag
    lea r9, [rel List_i64_71415]
    ; lit x9 <- 1;
    mov r11, 1
    ; x10 <- var_1 + x9;
    mov r13, rdi
    add r13, r11
    ; substitute (x10 !-> x10)(vars !-> vars)(a4 !-> a4);
    ; #move variables
    mov rdi, rdx
    mov rdx, r13
    ; jump enum_from_to_
    jmp enum_from_to_

List_i64_71415:
    jmp near List_i64_71415_Nil
    jmp near List_i64_71415_Cons

List_i64_71415_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71417
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab71416
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71416:
    mov rdx, [rax + 40]
    jmp lab71418

lab71417:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab71418:
    ; let x8: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x8 !-> x8)(vals !-> vals)(a3 !-> a3);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump fill_lscomp1_
    jmp fill_lscomp1_

List_i64_71415_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71420
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab71419
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71419:
    mov r9, [r8 + 40]
    jmp lab71421

lab71420:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab71421:
    ; substitute (a3 !-> a3)(vals !-> vals)(a13 !-> a13)(as2 !-> as2);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x8: List[i64] = Cons(a13, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71433
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71434

lab71433:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71431
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71424
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71422
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71423

lab71422:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71423:

lab71424:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71427
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71425
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71426

lab71425:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71426:

lab71427:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71430
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71428
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71429

lab71428:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71429:

lab71430:
    jmp lab71432

lab71431:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71432:

lab71434:
    ; #load tag
    mov r9, 5
    ; substitute (x8 !-> x8)(vals !-> vals)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump fill_lscomp1_
    jmp fill_lscomp1_

List_List_Pair_i64_i64_71401:
    jmp near List_List_Pair_i64_i64_71401_Nil
    jmp near List_List_Pair_i64_i64_71401_Cons

List_List_Pair_i64_i64_71401_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71438
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab71435
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71435:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab71436
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71436:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab71437
    ; ####increment refcount
    add qword [rax + 0], 1

lab71437:
    jmp lab71439

lab71438:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab71439:
    ; let x7: List[List[Pair[i64, i64]]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (x6 !-> x6)(tbl !-> tbl)(x7 !-> x7)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump fill_zip_with2_
    jmp fill_zip_with2_

List_List_Pair_i64_i64_71401_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71443
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab71440
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71440:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab71441
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71441:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab71442
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71442:
    jmp lab71444

lab71443:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab71444:
    ; substitute (x6 !-> x6)(a0 !-> a0)(tbl !-> tbl)(a12 !-> a12)(as1 !-> as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x7: List[List[Pair[i64, i64]]] = Cons(a12, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71456
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab71457

lab71456:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71454
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71447
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71445
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71446

lab71445:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71446:

lab71447:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71450
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71448
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71449

lab71448:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71449:

lab71450:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71453
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71451
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71452

lab71451:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71452:

lab71453:
    jmp lab71455

lab71454:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71455:

lab71457:
    ; #load tag
    mov r11, 5
    ; substitute (x6 !-> x6)(tbl !-> tbl)(x7 !-> x7)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump fill_zip_with2_
    jmp fill_zip_with2_

Fun_List_ConflictSet_Fun_List_Pair_i64_i64_List_ConflictSet_71387:

Fun_List_ConflictSet_Fun_List_Pair_i64_i64_List_ConflictSet_71387_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71459
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab71458
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71458:
    jmp lab71460

lab71459:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab71460:
    ; substitute (x !-> x)(f4 !-> f4)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_List_Pair_i64_i64_List_ConflictSet_71461:

Fun_List_Pair_i64_i64_List_ConflictSet_71461_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71464
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab71462
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71462:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab71463
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71463:
    jmp lab71465

lab71464:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab71465:
    ; substitute (f4 !-> f4)(x !-> x)(y !-> y)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump fill_zip_with_
    jmp fill_zip_with_

Fun_ConflictSet_Fun_Pair_i64_i64_ConflictSet_71373:

Fun_ConflictSet_Fun_Pair_i64_i64_ConflictSet_71373_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71467
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab71466
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71466:
    mov r9, [r8 + 24]
    jmp lab71468

lab71467:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab71468:
    ; substitute (cs !-> cs)(val_ !-> val_)(var_ !-> var_)(rel !-> rel)(a6 !-> a6);
    ; #move variables
    mov r12, rsi
    mov rcx, r13
    mov r13, rdi
    mov rdi, rcx
    ; switch a6 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Pair_i64_i64_ConflictSet_71469:

Fun_Pair_i64_i64_ConflictSet_71469_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab71472
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    cmp r14, 0
    je lab71470
    ; ####increment refcount
    add qword [r14 + 0], 1

lab71470:
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]
    cmp r12, 0
    je lab71471
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71471:
    jmp lab71473

lab71472:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r15, [r12 + 56]
    mov r14, [r12 + 48]
    mov r13, [r12 + 40]
    mov r12, [r12 + 32]

lab71473:
    ; substitute (cs !-> cs)(val_ !-> val_)(var_ !-> var_)(rel !-> rel)(a7 !-> a7)(varval !-> varval);
    ; #move variables
    mov rcx, r14
    mov r14, r12
    mov r12, rcx
    mov rcx, r15
    mov r15, r13
    mov r13, rcx
    ; switch varval \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_i64_i64_71474:

Pair_i64_i64_71474_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r14 + 0], 0
    je lab71475
    ; ##either decrement refcount and share children...
    add qword [r14 + 0], -1
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 40]
    jmp lab71476

lab71475:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2024], rcx
    mov r15, [r14 + 40]

lab71476:
    ; substitute (cs !-> cs)(val_ !-> val_)(var_ !-> var_)(rel !-> rel)(a7 !-> a7)(varr !-> varr)(vall !-> vall)(cs0 !-> cs);
    ; #share cs
    cmp rax, 0
    je lab71477
    ; ####increment refcount
    add qword [rax + 0], 1

lab71477:
    ; #move variables
    mov [rsp + 2016], rax
    mov [rsp + 2008], rdx
    ; switch cs0 \{ ... \};
    lea rcx, [rel ConflictSet_71478]
    add rcx, [rsp + 2008]
    jmp rcx

ConflictSet_71478:
    jmp near ConflictSet_71478_Known
    jmp near ConflictSet_71478_Unknown

ConflictSet_71478_Known:
    ; #load from memory
    mov rcx, [rsp + 2016]
    ; ##check refcount
    cmp qword [rcx + 0], 0
    je lab71480
    ; ##either decrement refcount and share children...
    add qword [rcx + 0], -1
    mov [rsp + 2040], rax
    mov rax, [rsp + 2016]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2016], rcx
    cmp rcx, 0
    je lab71479
    ; ####increment refcount
    add qword [rcx + 0], 1

lab71479:
    mov rax, [rsp + 2040]
    jmp lab71481

lab71480:
    ; ##... or release blocks onto linear free list when loading
    mov [rsp + 2040], rax
    mov rax, [rsp + 2016]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2008], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2016], rcx
    mov rax, [rsp + 2040]

lab71481:
    ; substitute (a7 !-> a7)(cs !-> cs);
    ; #erase rel
    cmp r10, 0
    je lab71484
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab71482
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab71483

lab71482:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab71483:

lab71484:
    ; #erase vs
    cmp qword [rsp + 2016], 0
    je lab71487
    ; ######check refcount
    mov rcx, [rsp + 2016]
    cmp qword [rcx + 0], 0
    je lab71485
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71486

lab71485:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71486:

lab71487:
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r12
    mov rdx, r13
    ; switch cs \{ ... \};
    lea rcx, [rel ConflictSet_71488]
    add rcx, rdi
    jmp rcx

ConflictSet_71488:
    jmp near ConflictSet_71488_Known
    jmp near ConflictSet_71488_Unknown

ConflictSet_71488_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab71490
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab71489
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71489:
    jmp lab71491

lab71490:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab71491:
    ; substitute (vs0 !-> vs0)(a7 !-> a7);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a7 Known
    add rdi, 0
    jmp rdi

ConflictSet_71488_Unknown:
    ; invoke a7 Unknown
    add rdx, 5
    jmp rdx

ConflictSet_71478_Unknown:
    ; substitute (vall !-> vall)(val_ !-> val_)(var_0 !-> var_)(rel !-> rel)(varr0 !-> varr)(varr !-> varr)(a7 !-> a7)(cs !-> cs)(var_ !-> var_);
    ; #move variables
    mov [rsp + 2016], rax
    mov [rsp + 2008], rdx
    mov [rsp + 1992], r9
    mov [rsp + 2032], r12
    mov rdx, [rsp + 2024]
    mov [rsp + 2024], r13
    mov r13, r15
    ; new a8: Bool = (varr, a7, cs, var_)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 1992]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov rcx, [rsp + 2008]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 32], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 24], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 16], rcx
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71503
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab71504

lab71503:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71501
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71494
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71492
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71493

lab71492:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71493:

lab71494:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71497
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71495
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71496

lab71495:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71496:

lab71497:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71500
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71498
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71499

lab71498:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71499:

lab71500:
    jmp lab71502

lab71501:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71502:

lab71504:
    ; ##store link to previous block
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    ; ##store values
    mov [rbx + 40], r15
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71516
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab71517

lab71516:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71514
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71507
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71505
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71506

lab71505:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71506:

lab71507:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71510
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71508
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71509

lab71508:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71509:

lab71510:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71513
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71511
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71512

lab71511:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71512:

lab71513:
    jmp lab71515

lab71514:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71515:

lab71517:
    ; #load tag
    lea r15, [rel Bool_71518]
    ; substitute (vall !-> vall)(a8 !-> a8)(varr0 !-> varr0)(rel !-> rel)(var_0 !-> var_0)(val_ !-> val_);
    ; #move variables
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    mov rsi, r14
    ; let x1: Assign = Assign(var_0, val_);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov qword [rbx + 48], 0
    mov [rbx + 40], r13
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71530
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab71531

lab71530:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71528
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71521
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71519
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71520

lab71519:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71520:

lab71521:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71524
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71522
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71523

lab71522:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71523:

lab71524:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71527
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71525
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71526

lab71525:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71526:

lab71527:
    jmp lab71529

lab71528:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71529:

lab71531:
    ; #load tag
    mov r13, 0
    ; substitute (x1 !-> x1)(a8 !-> a8)(rel !-> rel)(varr0 !-> varr0)(vall !-> vall);
    ; #move variables
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    mov r8, r10
    mov rax, r12
    ; let x2: Assign = Assign(varr0, vall);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov qword [rbx + 48], 0
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71543
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab71544

lab71543:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71541
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71534
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71532
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71533

lab71532:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71533:

lab71534:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71537
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71535
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71536

lab71535:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71536:

lab71537:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71540
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71538
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71539

lab71538:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71539:

lab71540:
    jmp lab71542

lab71541:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71542:

lab71544:
    ; #load tag
    mov r11, 0
    ; substitute (x1 !-> x1)(rel !-> rel)(x2 !-> x2)(a8 !-> a8);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdi
    mov rdi, rcx
    ; let a9: Fun[Assign, Bool] = Ap(x2, a8);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71556
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71557

lab71556:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71554
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71547
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71545
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71546

lab71545:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71546:

lab71547:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71550
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71548
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71549

lab71548:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71549:

lab71550:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71553
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71551
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71552

lab71551:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71552:

lab71553:
    jmp lab71555

lab71554:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71555:

lab71557:
    ; #load tag
    mov r9, 0
    ; substitute (x1 !-> x1)(a9 !-> a9)(rel !-> rel);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke rel Ap
    jmp r9

Bool_71518:
    jmp near Bool_71518_True
    jmp near Bool_71518_False

Bool_71518_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71560
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###load values
    mov r11, [rsi + 56]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab71558
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71558:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab71559
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71559:
    jmp lab71561

lab71560:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab71561:
    ; let x0: Bool = True();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 0
    ; substitute (a7 !-> a7)(cs !-> cs)(var_ !-> var_)(varr !-> varr)(x0 !-> x0);
    ; #move variables
    mov rcx, rdi
    mov rdi, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, rsi
    mov rsi, r8
    ; jump lift_fill_table_0_
    jmp lift_fill_table_0_

Bool_71518_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71564
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###load values
    mov r11, [rsi + 56]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab71562
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71562:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab71563
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71563:
    jmp lab71565

lab71564:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab71565:
    ; let x0: Bool = False();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 5
    ; substitute (a7 !-> a7)(cs !-> cs)(var_ !-> var_)(varr !-> varr)(x0 !-> x0);
    ; #move variables
    mov rcx, rdi
    mov rdi, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, rsi
    mov rsi, r8
    ; jump lift_fill_table_0_
    jmp lift_fill_table_0_

lift_fill_table_0_:
    ; substitute (x0 !-> x0)(cs !-> cs)(var_ !-> var_)(varr !-> varr)(a7 !-> a7);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    ; new a10: Bool = (cs, var_, varr, a7)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71577
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71578

lab71577:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71575
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71568
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71566
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71567

lab71566:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71567:

lab71568:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71571
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71569
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71570

lab71569:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71570:

lab71571:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71574
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71572
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71573

lab71572:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71573:

lab71574:
    jmp lab71576

lab71575:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71576:

lab71578:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71590
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab71591

lab71590:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71588
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71581
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71579
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71580

lab71579:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71580:

lab71581:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71584
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71582
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71583

lab71582:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71583:

lab71584:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71587
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71585
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71586

lab71585:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71586:

lab71587:
    jmp lab71589

lab71588:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71589:

lab71591:
    ; #load tag
    lea rdi, [rel Bool_71592]
    ; jump not_
    jmp not_

Bool_71592:
    jmp near Bool_71592_True
    jmp near Bool_71592_False

Bool_71592_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71595
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab71593
    ; ####increment refcount
    add qword [rax + 0], 1

lab71593:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab71594
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71594:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab71596

lab71595:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab71596:
    ; substitute (a7 !-> a7)(var_ !-> var_)(varr !-> varr);
    ; #erase cs
    cmp rax, 0
    je lab71599
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab71597
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab71598

lab71597:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab71598:

lab71599:
    ; #move variables
    mov rax, r10
    mov rdx, r11
    ; let x5: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; let x4: List[i64] = Cons(varr, x5);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71611
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71612

lab71611:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71609
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71602
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71600
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71601

lab71600:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71601:

lab71602:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71605
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71603
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71604

lab71603:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71604:

lab71605:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71608
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71606
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71607

lab71606:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71607:

lab71608:
    jmp lab71610

lab71609:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71610:

lab71612:
    ; #load tag
    mov r9, 5
    ; let x3: List[i64] = Cons(var_, x4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71624
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab71625

lab71624:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71622
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71615
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71613
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71614

lab71613:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71614:

lab71615:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71618
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71616
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71617

lab71616:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71617:

lab71618:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71621
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71619
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71620

lab71619:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71620:

lab71621:
    jmp lab71623

lab71622:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71623:

lab71625:
    ; #load tag
    mov rdi, 5
    ; substitute (x3 !-> x3)(a7 !-> a7);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a7 Known
    add rdi, 0
    jmp rdi

Bool_71592_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71628
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab71626
    ; ####increment refcount
    add qword [rax + 0], 1

lab71626:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab71627
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71627:
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]
    jmp lab71629

lab71628:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov rdi, [rsi + 24]

lab71629:
    ; substitute (a7 !-> a7)(cs !-> cs);
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r10
    mov rdx, r11
    ; switch cs \{ ... \};
    lea rcx, [rel ConflictSet_71630]
    add rcx, rdi
    jmp rcx

ConflictSet_71630:
    jmp near ConflictSet_71630_Known
    jmp near ConflictSet_71630_Unknown

ConflictSet_71630_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab71632
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab71631
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71631:
    jmp lab71633

lab71632:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab71633:
    ; substitute (vs1 !-> vs1)(a7 !-> a7);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a7 Known
    add rdi, 0
    jmp rdi

ConflictSet_71630_Unknown:
    ; invoke a7 Unknown
    add rdx, 5
    jmp rdx

lookup_map_:
    ; substitute (f !-> f)(a0 !-> a0)(l !-> l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_List_List_ConflictSet_71634]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_List_List_ConflictSet_71634:
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_71634_Nil
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_71634_Cons

List_Node_Pair_List_Assign_List_List_ConflictSet_71634_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab71637
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab71635
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab71636

lab71635:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab71636:

lab71637:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_List_List_ConflictSet_71634_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71640
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab71638
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71638:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab71639
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71639:
    jmp lab71641

lab71640:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab71641:
    ; substitute (f0 !-> f)(n !-> n)(a0 !-> a0)(ns !-> ns)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab71642
    ; ####increment refcount
    add qword [rax + 0], 1

lab71642:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = (a0, ns, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71654
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71655

lab71654:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71652
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71645
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71643
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71644

lab71643:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71644:

lab71645:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71648
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71646
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71647

lab71646:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71647:

lab71648:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71651
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71649
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71650

lab71649:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71650:

lab71651:
    jmp lab71653

lab71652:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71653:

lab71655:
    ; #load tag
    lea r9, [rel Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71656]
    ; substitute (n !-> n)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71656:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71656_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71660
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab71657
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71657:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab71658
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71658:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab71659
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71659:
    jmp lab71661

lab71660:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab71661:
    ; substitute (f !-> f)(ns !-> ns)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71673
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab71674

lab71673:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71671
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71664
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71662
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71663

lab71662:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71663:

lab71664:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71667
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71665
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71666

lab71665:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71666:

lab71667:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71670
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71668
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71669

lab71668:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71669:

lab71670:
    jmp lab71672

lab71671:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71672:

lab71674:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71686
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71687

lab71686:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71684
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71677
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71675
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71676

lab71675:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71676:

lab71677:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71680
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71678
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71679

lab71678:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71679:

lab71680:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71683
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71681
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71682

lab71681:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71682:

lab71683:
    jmp lab71685

lab71684:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71685:

lab71687:
    ; #load tag
    lea r9, [rel List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71688]
    ; jump lookup_map_
    jmp lookup_map_

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71688:
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71688_Nil
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71688_Cons

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71688_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71691
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab71689
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71689:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab71690
    ; ####increment refcount
    add qword [rax + 0], 1

lab71690:
    jmp lab71692

lab71691:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab71692:
    ; let x1: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71688_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71695
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab71693
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71693:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab71694
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71694:
    jmp lab71696

lab71695:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab71696:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71708
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71709

lab71708:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71706
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71699
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71697
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71698

lab71697:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71698:

lab71699:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71702
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71700
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71701

lab71700:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71701:

lab71702:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71705
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71703
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71704

lab71703:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71704:

lab71705:
    jmp lab71707

lab71706:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71707:

lab71709:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

lookup_map_tree_:
    ; substitute (f !-> f)(a0 !-> a0)(t !-> t);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch t \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_Pair_List_Assign_List_List_ConflictSet_71710:

Node_Pair_List_Assign_List_List_ConflictSet_71710_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71713
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab71711
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71711:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab71712
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71712:
    jmp lab71714

lab71713:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab71714:
    ; substitute (f0 !-> f)(p !-> p)(a0 !-> a0)(ps !-> ps)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab71715
    ; ####increment refcount
    add qword [rax + 0], 1

lab71715:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71727
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71728

lab71727:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71725
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71718
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71716
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71717

lab71716:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71717:

lab71718:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71721
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71719
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71720

lab71719:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71720:

lab71721:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71724
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71722
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71723

lab71722:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71723:

lab71724:
    jmp lab71726

lab71725:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71726:

lab71728:
    ; #load tag
    lea r9, [rel Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71729]
    ; substitute (p !-> p)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71729:

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71729_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71733
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab71730
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71730:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab71731
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71731:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab71732
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71732:
    jmp lab71734

lab71733:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab71734:
    ; substitute (f !-> f)(ps !-> ps)(a0 !-> a0)(a5 !-> a5)(b0 !-> b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]] = Tup(a5, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71746
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab71747

lab71746:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71744
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71737
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71735
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71736

lab71735:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71736:

lab71737:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71740
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71738
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71739

lab71738:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71739:

lab71740:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71743
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71741
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71742

lab71741:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71742:

lab71743:
    jmp lab71745

lab71744:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71745:

lab71747:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71759
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71760

lab71759:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71757
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71750
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71748
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71749

lab71748:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71749:

lab71750:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71753
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71751
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71752

lab71751:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71752:

lab71753:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71756
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71754
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71755

lab71754:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71755:

lab71756:
    jmp lab71758

lab71757:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71758:

lab71760:
    ; #load tag
    lea r9, [rel List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71761]
    ; substitute (a2 !-> a2)(ps !-> ps)(f !-> f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new x2: Fun[Node[Pair[List[Assign], List[List[ConflictSet]]]], Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71773
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71774

lab71773:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71771
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71764
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71762
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71763

lab71762:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71763:

lab71764:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71767
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71765
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71766

lab71765:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71766:

lab71767:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71770
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71768
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71769

lab71768:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71769:

lab71770:
    jmp lab71772

lab71771:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71772:

lab71774:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_List_List_ConflictSet_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71775]
    ; substitute (x2 !-> x2)(ps !-> ps)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lookup_map_
    jmp lookup_map_

Fun_Node_Pair_List_Assign_List_List_ConflictSet_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71775:

Fun_Node_Pair_List_Assign_List_List_ConflictSet_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71775_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71777
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab71776
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71776:
    jmp lab71778

lab71777:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab71778:
    ; substitute (f !-> f)(x !-> x)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lookup_map_tree_
    jmp lookup_map_tree_

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71761:
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71761_Nil
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71761_Cons

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71761_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71781
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab71779
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71779:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab71780
    ; ####increment refcount
    add qword [rax + 0], 1

lab71780:
    jmp lab71782

lab71781:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab71782:
    ; let x1: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    jmp r9

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71761_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71785
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab71783
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71783:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab71784
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71784:
    jmp lab71786

lab71785:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab71786:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71798
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71799

lab71798:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71796
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71789
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71787
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71788

lab71787:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71788:

lab71789:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71792
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71790
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71791

lab71790:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71791:

lab71792:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71795
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71793
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71794

lab71793:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71794:

lab71795:
    jmp lab71797

lab71796:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71797:

lab71799:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    jmp r9

lookup_at_index_:
    ; substitute (ind !-> ind)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_ConflictSet_71800]
    add rcx, r9
    jmp rcx

List_ConflictSet_71800:
    jmp near List_ConflictSet_71800_Nil
    jmp near List_ConflictSet_71800_Cons

List_ConflictSet_71800_Nil:
    ; substitute (a0 !-> a0);
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Unknown
    add rdx, 5
    jmp rdx

List_ConflictSet_71800_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71803
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab71801
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71801:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab71802
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71802:
    jmp lab71804

lab71803:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab71804:
    ; if ind == 0 \{ ... \}
    cmp rdx, 0
    je lab71805
    ; substitute (ind !-> ind)(a0 !-> a0)(cs !-> cs);
    ; #erase c
    cmp r8, 0
    je lab71808
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab71806
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab71807

lab71806:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab71807:

lab71808:
    ; #move variables
    mov r8, r10
    mov r9, r11
    ; lit x0 <- 1;
    mov r11, 1
    ; x1 <- ind - x0;
    mov r13, rdx
    sub r13, r11
    ; substitute (x1 !-> x1)(cs !-> cs)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rdx, r13
    ; jump lookup_at_index_
    jmp lookup_at_index_

lab71805:
    ; substitute (a0 !-> a0)(c !-> c);
    ; #erase cs
    cmp r10, 0
    je lab71811
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab71809
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab71810

lab71809:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab71810:

lab71811:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    mov rsi, r8
    mov rdi, r9
    ; switch c \{ ... \};
    lea rcx, [rel ConflictSet_71812]
    add rcx, rdi
    jmp rcx

ConflictSet_71812:
    jmp near ConflictSet_71812_Known
    jmp near ConflictSet_71812_Unknown

ConflictSet_71812_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab71814
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab71813
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71813:
    jmp lab71815

lab71814:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab71815:
    ; substitute (vs0 !-> vs0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Known
    add rdi, 0
    jmp rdi

ConflictSet_71812_Unknown:
    ; invoke a0 Unknown
    add rdx, 5
    jmp rdx

lookup_head_:
    ; substitute (a0 !-> a0)(tbl !-> tbl);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch tbl \{ ... \};
    lea rcx, [rel List_List_ConflictSet_71816]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_71816:
    jmp near List_List_ConflictSet_71816_Nil
    jmp near List_List_ConflictSet_71816_Cons

List_List_ConflictSet_71816_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_71816_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab71819
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab71817
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71817:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab71818
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71818:
    jmp lab71820

lab71819:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab71820:
    ; substitute (a0 !-> a0)(cs !-> cs);
    ; #erase css
    cmp r8, 0
    je lab71823
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab71821
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab71822

lab71821:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab71822:

lab71823:
    ; switch cs \{ ... \};
    lea rcx, [rel List_ConflictSet_71824]
    add rcx, rdi
    jmp rcx

List_ConflictSet_71824:
    jmp near List_ConflictSet_71824_Nil
    jmp near List_ConflictSet_71824_Cons

List_ConflictSet_71824_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_ConflictSet_71824_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab71827
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab71825
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71825:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab71826
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71826:
    jmp lab71828

lab71827:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab71828:
    ; substitute (a1 !-> a1)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

lookup_cache_:
    ; new f5: Fun[CSP, Fun[Pair[List[Assign], List[List[ConflictSet]]], Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_CSP_Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71829]
    ; substitute (a0 !-> a0)(t !-> t)(csp !-> csp)(f5 !-> f5);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new x8: Fun[Pair[List[Assign], List[List[ConflictSet]]], Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = (csp, f5)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71841
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71842

lab71841:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71839
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71832
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71830
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71831

lab71830:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71831:

lab71832:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71835
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71833
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71834

lab71833:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71834:

lab71835:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71838
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71836
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71837

lab71836:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71837:

lab71838:
    jmp lab71840

lab71839:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71840:

lab71842:
    ; #load tag
    lea r9, [rel Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71843]
    ; substitute (x8 !-> x8)(t !-> t)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lookup_map_tree_
    jmp lookup_map_tree_

Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71843:

Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71843_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71846
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab71844
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71844:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab71845
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71845:
    jmp lab71847

lab71846:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab71847:
    ; substitute (f5 !-> f5)(csp !-> csp)(x !-> x)(a1 !-> a1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let a9: Fun[Pair[List[Assign], List[List[ConflictSet]]], Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = Ap(x, a1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71859
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71860

lab71859:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71857
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71850
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71848
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71849

lab71848:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71849:

lab71850:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71853
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71851
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71852

lab71851:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71852:

lab71853:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71856
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71854
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71855

lab71854:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71855:

lab71856:
    jmp lab71858

lab71857:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71858:

lab71860:
    ; #load tag
    mov r9, 0
    ; substitute (csp !-> csp)(a9 !-> a9)(f5 !-> f5);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f5 Ap
    jmp r9

Fun_CSP_Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71829:

Fun_CSP_Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71829_Ap:
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71861:

Fun_Pair_List_Assign_List_List_ConflictSet_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_71861_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab71864
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab71862
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71862:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab71863
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71863:
    jmp lab71865

lab71864:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab71865:
    ; substitute (csp0 !-> csp0)(a3 !-> a3)(tp !-> tp);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch tp \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_List_Assign_List_List_ConflictSet_71866:

Pair_List_Assign_List_List_ConflictSet_71866_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71869
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab71867
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71867:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab71868
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71868:
    jmp lab71870

lab71869:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab71870:
    ; substitute (csp0 !-> csp0)(a3 !-> a3)(tbl !-> tbl)(ls !-> ls);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Assign_71871]
    add rcx, r11
    jmp rcx

List_Assign_71871:
    jmp near List_Assign_71871_Nil
    jmp near List_Assign_71871_Cons

List_Assign_71871_Nil:
    ; substitute (tbl !-> tbl)(a3 !-> a3);
    ; #erase csp0
    cmp rax, 0
    je lab71874
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab71872
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab71873

lab71872:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab71873:

lab71874:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; let x1: List[Assign] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; let x2: ConflictSet = Unknown();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 5
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(x1, x2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71886
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71887

lab71886:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71884
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71877
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71875
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71876

lab71875:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71876:

lab71877:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71880
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71878
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71879

lab71878:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71879:

lab71880:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71883
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71881
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71882

lab71881:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71882:

lab71883:
    jmp lab71885

lab71884:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71885:

lab71887:
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(tbl !-> tbl)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a3 Tup
    jmp r9

List_Assign_71871_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab71890
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab71888
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71888:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab71889
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71889:
    jmp lab71891

lab71890:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab71891:
    ; substitute (a11 !-> a)(a3 !-> a3)(tbl !-> tbl)(a !-> a)(as_ !-> as_)(csp0 !-> csp0);
    ; #share a
    cmp r10, 0
    je lab71892
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71892:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov rax, r10
    mov rdx, r11
    ; new a5: _Cont = (a3, tbl, a, as_, csp0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71904
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab71905

lab71904:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71902
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71895
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71893
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71894

lab71893:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71894:

lab71895:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71898
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71896
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71897

lab71896:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71897:

lab71898:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71901
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71899
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71900

lab71899:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71900:

lab71901:
    jmp lab71903

lab71902:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71903:

lab71905:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71917
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab71918

lab71917:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71915
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71908
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71906
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71907

lab71906:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71907:

lab71908:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71911
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71909
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71910

lab71909:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71910:

lab71911:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71914
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71912
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71913

lab71912:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71913:

lab71914:
    jmp lab71916

lab71915:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71916:

lab71918:
    ; #load tag
    lea rdi, [rel _Cont_71919]
    ; jump value_
    jmp value_

_Cont_71919:

_Cont_71919_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab71925
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab71920
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71920:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab71921
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71921:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab71922
    ; ####increment refcount
    add qword [r14 + 0], 1

lab71922:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab71923
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71923:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab71924
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71924:
    jmp lab71926

lab71925:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab71926:
    ; lit x4 <- 1;
    mov qword [rsp + 2024], 1
    ; x5 <- x3 - x4;
    mov rcx, rdx
    sub rcx, [rsp + 2024]
    mov [rsp + 2008], rcx
    ; substitute (tbl0 !-> tbl)(a3 !-> a3)(tbl !-> tbl)(a !-> a)(as_ !-> as_)(csp0 !-> csp0)(x5 !-> x5);
    ; #share tbl
    cmp r8, 0
    je lab71927
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71927:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov rcx, [rsp + 2008]
    mov [rsp + 2024], rcx
    ; new a6: List[ConflictSet] = (a3, tbl, a, as_, csp0, x5)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov qword [rbx + 48], 0
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71939
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab71940

lab71939:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71937
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71930
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71928
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71929

lab71928:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71929:

lab71930:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71933
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71931
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71932

lab71931:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71932:

lab71933:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71936
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71934
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71935

lab71934:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71935:

lab71936:
    jmp lab71938

lab71937:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71938:

lab71940:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71952
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab71953

lab71952:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71950
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71943
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71941
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71942

lab71941:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71942:

lab71943:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71946
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71944
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71945

lab71944:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71945:

lab71946:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71949
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71947
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71948

lab71947:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71948:

lab71949:
    jmp lab71951

lab71950:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71951:

lab71953:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71965
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab71966

lab71965:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71963
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71956
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71954
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71955

lab71954:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71955:

lab71956:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71959
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71957
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71958

lab71957:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71958:

lab71959:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71962
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71960
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71961

lab71960:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71961:

lab71962:
    jmp lab71964

lab71963:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71964:

lab71966:
    ; #load tag
    lea rdi, [rel List_ConflictSet_71967]
    ; jump lookup_head_
    jmp lookup_head_

List_ConflictSet_71967:
    jmp near List_ConflictSet_71967_Nil
    jmp near List_ConflictSet_71967_Cons

List_ConflictSet_71967_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab71973
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab71968
    ; ####increment refcount
    add qword [rax + 0], 1

lab71968:
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab71969
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71969:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab71970
    ; ####increment refcount
    add qword [rsi + 0], 1

lab71970:
    ; ###load values
    mov r15, [r10 + 56]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab71971
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71971:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab71972
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71972:
    jmp lab71974

lab71973:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab71974:
    ; let x6: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    mov qword [rsp + 2024], 0
    ; substitute (a !-> a)(a3 !-> a3)(as_ !-> as_)(csp0 !-> csp0)(tbl !-> tbl)(x5 !-> x5)(x6 !-> x6);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, r12
    mov r12, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, r13
    mov r13, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_lookup_cache_0_
    jmp lift_lookup_cache_0_

List_ConflictSet_71967_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab71980
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab71975
    ; ####increment refcount
    add qword [r8 + 0], 1

lab71975:
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab71976
    ; ####increment refcount
    add qword [r12 + 0], 1

lab71976:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab71977
    ; ####increment refcount
    add qword [r10 + 0], 1

lab71977:
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab71978
    ; ####increment refcount
    add qword [rcx + 0], 1

lab71978:
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]
    cmp r14, 0
    je lab71979
    ; ####increment refcount
    add qword [r14 + 0], 1

lab71979:
    jmp lab71981

lab71980:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load link to next block
    mov r10, [r8 + 48]
    ; ###load values
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load link to next block
    mov r14, [r10 + 48]
    ; ###load values
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    ; ###release block
    mov [r14 + 0], rbx
    mov rbx, r14
    ; ###load values
    mov rcx, [r14 + 56]
    mov [rsp + 2008], rcx
    mov rcx, [r14 + 40]
    mov [rsp + 2024], rcx
    mov rcx, [r14 + 32]
    mov [rsp + 2032], rcx
    mov r15, [r14 + 24]
    mov r14, [r14 + 16]

lab71981:
    ; substitute (x5 !-> x5)(csp0 !-> csp0)(a3 !-> a3)(tbl !-> tbl)(a !-> a)(as_ !-> as_)(a10 !-> a10)(as0 !-> as0);
    ; #move variables
    mov [rsp + 2016], rsi
    mov rsi, [rsp + 2032]
    mov [rsp + 2032], rax
    mov rcx, [rsp + 2008]
    mov [rsp + 2008], rdi
    mov rdi, [rsp + 2024]
    mov [rsp + 2024], rdx
    mov rdx, rcx
    ; let x6: List[ConflictSet] = Cons(a10, as0);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab71993
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab71994

lab71993:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab71991
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71984
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71982
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71983

lab71982:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71983:

lab71984:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab71987
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71985
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71986

lab71985:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71986:

lab71987:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab71990
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71988
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71989

lab71988:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71989:

lab71990:
    jmp lab71992

lab71991:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab71992:

lab71994:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; substitute (a !-> a)(a3 !-> a3)(as_ !-> as_)(csp0 !-> csp0)(tbl !-> tbl)(x5 !-> x5)(x6 !-> x6);
    ; #move variables
    mov rcx, r13
    mov r13, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, r15
    mov r15, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, r14
    ; jump lift_lookup_cache_0_
    jmp lift_lookup_cache_0_

lift_lookup_cache_0_:
    ; substitute (x6 !-> x6)(x5 !-> x5)(as_ !-> as_)(csp0 !-> csp0)(tbl !-> tbl)(a3 !-> a3)(a !-> a);
    ; #move variables
    mov rcx, [rsp + 2032]
    mov [rsp + 2032], rax
    mov rax, rcx
    mov rcx, [rsp + 2024]
    mov [rsp + 2024], rdx
    mov rdx, rcx
    mov r14, rsi
    mov rcx, r15
    mov r15, rdi
    mov rdi, rcx
    ; new a7: ConflictSet = (as_, csp0, tbl, a3, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    mov [rbx + 24], r13
    mov [rbx + 16], r12
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72006
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab72007

lab72006:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72004
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab71997
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71995
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71996

lab71995:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71996:

lab71997:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72000
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab71998
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab71999

lab71998:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab71999:

lab72000:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72003
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72001
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72002

lab72001:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72002:

lab72003:
    jmp lab72005

lab72004:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72005:

lab72007:
    ; ##store link to previous block
    mov [rbx + 48], r12
    ; ##store values
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72019
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72020

lab72019:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72017
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72010
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72008
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72009

lab72008:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72009:

lab72010:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72013
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72011
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72012

lab72011:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72012:

lab72013:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72016
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72014
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72015

lab72014:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72015:

lab72016:
    jmp lab72018

lab72017:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72018:

lab72020:
    ; #load tag
    lea r9, [rel ConflictSet_72021]
    ; substitute (x5 !-> x5)(x6 !-> x6)(a7 !-> a7);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lookup_at_index_
    jmp lookup_at_index_

ConflictSet_72021:
    jmp near ConflictSet_72021_Known
    jmp near ConflictSet_72021_Unknown

ConflictSet_72021_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab72027
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab72022
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72022:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab72023
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72023:
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    cmp r14, 0
    je lab72024
    ; ####increment refcount
    add qword [r14 + 0], 1

lab72024:
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    cmp r12, 0
    je lab72025
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72025:
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]
    cmp r10, 0
    je lab72026
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72026:
    jmp lab72028

lab72027:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r10, [rsi + 48]
    ; ###load values
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r15, [r10 + 56]
    mov r14, [r10 + 48]
    mov r13, [r10 + 40]
    mov r12, [r10 + 32]
    mov r11, [r10 + 24]
    mov r10, [r10 + 16]

lab72028:
    ; substitute (a !-> a)(as_ !-> as_)(csp0 !-> csp0)(tbl !-> tbl)(a3 !-> a3)(vs1 !-> vs1);
    ; #move variables
    mov rcx, r14
    mov r14, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdx
    mov rdx, rcx
    ; let table_entry: ConflictSet = Known(vs1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72040
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab72041

lab72040:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72038
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72031
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72029
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72030

lab72029:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72030:

lab72031:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72034
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72032
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72033

lab72032:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72033:

lab72034:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72037
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72035
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72036

lab72035:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72036:

lab72037:
    jmp lab72039

lab72038:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72039:

lab72041:
    ; #load tag
    mov r15, 0
    ; substitute (a !-> a)(a3 !-> a3)(as_ !-> as_)(csp0 !-> csp0)(table_entry !-> table_entry)(tbl !-> tbl);
    ; #move variables
    mov rcx, r12
    mov r12, r14
    mov r14, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r13
    mov r13, r15
    mov r15, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lift_lookup_cache_1_
    jmp lift_lookup_cache_1_

ConflictSet_72021_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72047
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab72042
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72042:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab72043
    ; ####increment refcount
    add qword [rax + 0], 1

lab72043:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab72044
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72044:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab72045
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72045:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab72046
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72046:
    jmp lab72048

lab72047:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab72048:
    ; let table_entry: ConflictSet = Unknown();
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    mov r15, 5
    ; substitute (a !-> a)(a3 !-> a3)(as_ !-> as_)(csp0 !-> csp0)(table_entry !-> table_entry)(tbl !-> tbl);
    ; #move variables
    mov rcx, r12
    mov r12, r14
    mov r14, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r15
    mov r15, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump lift_lookup_cache_1_
    jmp lift_lookup_cache_1_

lift_lookup_cache_1_:
    ; substitute (a !-> a)(a3 !-> a3)(as_ !-> as_)(csp0 !-> csp0)(table_entry !-> table_entry)(tbl !-> tbl)(table_entry0 !-> table_entry);
    ; #share table_entry
    cmp r12, 0
    je lab72049
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72049:
    ; #move variables
    mov [rsp + 2032], r12
    mov [rsp + 2024], r13
    ; switch table_entry0 \{ ... \};
    lea rcx, [rel ConflictSet_72050]
    add rcx, [rsp + 2024]
    jmp rcx

ConflictSet_72050:
    jmp near ConflictSet_72050_Known
    jmp near ConflictSet_72050_Unknown

ConflictSet_72050_Known:
    ; #load from memory
    mov rcx, [rsp + 2032]
    ; ##check refcount
    cmp qword [rcx + 0], 0
    je lab72052
    ; ##either decrement refcount and share children...
    add qword [rcx + 0], -1
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2032], rcx
    cmp rcx, 0
    je lab72051
    ; ####increment refcount
    add qword [rcx + 0], 1

lab72051:
    mov rax, [rsp + 2040]
    jmp lab72053

lab72052:
    ; ##... or release blocks onto linear free list when loading
    mov [rsp + 2040], rax
    mov rax, [rsp + 2032]
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rcx, [rax + 56]
    mov [rsp + 2024], rcx
    mov rcx, [rax + 48]
    mov [rsp + 2032], rcx
    mov rax, [rsp + 2040]

lab72053:
    ; substitute (a !-> a)(a3 !-> a3)(as_ !-> as_)(table_entry !-> table_entry)(tbl !-> tbl);
    ; #erase csp0
    cmp r10, 0
    je lab72056
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab72054
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab72055

lab72054:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab72055:

lab72056:
    ; #erase vals
    cmp qword [rsp + 2032], 0
    je lab72059
    ; ######check refcount
    mov rcx, [rsp + 2032]
    cmp qword [rcx + 0], 0
    je lab72057
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72058

lab72057:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72058:

lab72059:
    ; #move variables
    mov r10, r12
    mov r11, r13
    mov r12, r14
    mov r13, r15
    ; jump share_lookup_cache_0_
    jmp share_lookup_cache_0_

ConflictSet_72050_Unknown:
    ; substitute (a !-> a)(a3 !-> a3)(as_ !-> as_)(csp0 !-> csp0)(tbl !-> tbl)(a10 !-> a)(as_0 !-> as_);
    ; #share a
    cmp rax, 0
    je lab72060
    ; ####increment refcount
    add qword [rax + 0], 1

lab72060:
    ; #share as_
    cmp r8, 0
    je lab72061
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72061:
    ; #erase table_entry
    cmp r12, 0
    je lab72064
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab72062
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab72063

lab72062:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab72063:

lab72064:
    ; #move variables
    mov r12, r14
    mov r14, rax
    mov r13, r15
    mov r15, rdx
    mov [rsp + 2032], r8
    mov [rsp + 2024], r9
    ; let x7: List[Assign] = Cons(a10, as_0);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72076
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab72077

lab72076:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72074
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72067
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72065
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72066

lab72065:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72066:

lab72067:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72070
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72068
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72069

lab72068:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72069:

lab72070:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72073
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72071
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72072

lab72071:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72072:

lab72073:
    jmp lab72075

lab72074:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72075:

lab72077:
    ; #load tag
    mov r15, 5
    ; substitute (x7 !-> x7)(csp0 !-> csp0)(as_ !-> as_)(a3 !-> a3)(tbl !-> tbl)(a !-> a);
    ; #move variables
    mov rcx, r14
    mov r14, rax
    mov rax, rcx
    mov rcx, r15
    mov r15, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; new a8: ConflictSet = (as_, a3, tbl, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72089
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72090

lab72089:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72087
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72080
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72078
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72079

lab72078:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72079:

lab72080:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72083
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72081
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72082

lab72081:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72082:

lab72083:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72086
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72084
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72085

lab72084:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72085:

lab72086:
    jmp lab72088

lab72087:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72088:

lab72090:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72102
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72103

lab72102:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72100
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72093
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72091
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72092

lab72091:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72092:

lab72093:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72096
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72094
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72095

lab72094:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72095:

lab72096:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72099
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72097
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72098

lab72097:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72098:

lab72099:
    jmp lab72101

lab72100:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72101:

lab72103:
    ; #load tag
    lea r9, [rel ConflictSet_72104]
    ; substitute (csp0 !-> csp0)(x7 !-> x7)(a8 !-> a8);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump check_complete_
    jmp check_complete_

ConflictSet_72104:
    jmp near ConflictSet_72104_Known
    jmp near ConflictSet_72104_Unknown

ConflictSet_72104_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab72109
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab72105
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72105:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab72106
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72106:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab72107
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72107:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab72108
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72108:
    jmp lab72110

lab72109:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab72110:
    ; substitute (a !-> a)(as_ !-> as_)(a3 !-> a3)(tbl !-> tbl)(vs0 !-> vs0);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    ; let cs: ConflictSet = Known(vs0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72122
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab72123

lab72122:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72120
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72113
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72111
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72112

lab72111:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72112:

lab72113:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72116
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72114
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72115

lab72114:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72115:

lab72116:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72119
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72117
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72118

lab72117:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72118:

lab72119:
    jmp lab72121

lab72120:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72121:

lab72123:
    ; #load tag
    mov r13, 0
    ; substitute (a !-> a)(a3 !-> a3)(as_ !-> as_)(cs !-> cs)(tbl !-> tbl);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rcx, r12
    mov r12, r10
    mov r10, rcx
    mov rcx, r13
    mov r13, r11
    mov r11, rcx
    ; jump share_lookup_cache_0_
    jmp share_lookup_cache_0_

ConflictSet_72104_Unknown:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72128
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab72124
    ; ####increment refcount
    add qword [rax + 0], 1

lab72124:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab72125
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72125:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab72126
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72126:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab72127
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72127:
    jmp lab72129

lab72128:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab72129:
    ; let cs: ConflictSet = Unknown();
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    mov r13, 5
    ; substitute (a !-> a)(a3 !-> a3)(as_ !-> as_)(cs !-> cs)(tbl !-> tbl);
    ; #move variables
    mov rcx, r10
    mov r10, r12
    mov r12, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, r13
    mov r13, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump share_lookup_cache_0_
    jmp share_lookup_cache_0_

share_lookup_cache_0_:
    ; substitute (tbl !-> tbl)(a3 !-> a3)(cs !-> cs)(a !-> a)(as_ !-> as_);
    ; #move variables
    mov rcx, r12
    mov r12, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x1: List[Assign] = Cons(a, as_);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72141
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72142

lab72141:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72139
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72132
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72130
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72131

lab72130:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72131:

lab72132:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72135
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72133
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72134

lab72133:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72134:

lab72135:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72138
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72136
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72137

lab72136:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72137:

lab72138:
    jmp lab72140

lab72139:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72140:

lab72142:
    ; #load tag
    mov r11, 5
    ; substitute (tbl !-> tbl)(a3 !-> a3)(x1 !-> x1)(cs !-> cs);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(x1, cs);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72154
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72155

lab72154:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72152
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72145
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72143
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72144

lab72143:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72144:

lab72145:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72148
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72146
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72147

lab72146:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72147:

lab72148:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72151
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72149
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72150

lab72149:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72150:

lab72151:
    jmp lab72153

lab72152:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72153:

lab72155:
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(tbl !-> tbl)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a3 Tup
    jmp r9

checks_map_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Node_List_Assign_72156]
    add rcx, r9
    jmp rcx

List_Node_List_Assign_72156:
    jmp near List_Node_List_Assign_72156_Nil
    jmp near List_Node_List_Assign_72156_Cons

List_Node_List_Assign_72156_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab72159
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab72157
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab72158

lab72157:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab72158:

lab72159:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_List_Assign_72156_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72162
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72160
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72160:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab72161
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72161:
    jmp lab72163

lab72162:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab72163:
    ; substitute (f0 !-> f)(n !-> n)(a0 !-> a0)(ns !-> ns)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab72164
    ; ####increment refcount
    add qword [rax + 0], 1

lab72164:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Node[Pair[List[Assign], List[List[ConflictSet]]]] = (a0, ns, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72176
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72177

lab72176:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72174
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72167
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72165
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72166

lab72165:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72166:

lab72167:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72170
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72168
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72169

lab72168:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72169:

lab72170:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72173
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72171
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72172

lab72171:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72172:

lab72173:
    jmp lab72175

lab72174:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72175:

lab72177:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_List_List_ConflictSet_72178]
    ; substitute (n !-> n)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Node_Pair_List_Assign_List_List_ConflictSet_72178:

Node_Pair_List_Assign_List_List_ConflictSet_72178_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72182
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab72179
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72179:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab72180
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72180:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab72181
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72181:
    jmp lab72183

lab72182:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab72183:
    ; substitute (f !-> f)(ns !-> ns)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], List[List[ConflictSet]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72195
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72196

lab72195:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72193
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72186
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72184
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72185

lab72184:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72185:

lab72186:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72189
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72187
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72188

lab72187:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72188:

lab72189:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72192
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72190
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72191

lab72190:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72191:

lab72192:
    jmp lab72194

lab72193:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72194:

lab72196:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72208
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72209

lab72208:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72206
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72199
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72197
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72198

lab72197:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72198:

lab72199:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72202
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72200
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72201

lab72200:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72201:

lab72202:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72205
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72203
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72204

lab72203:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72204:

lab72205:
    jmp lab72207

lab72206:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72207:

lab72209:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_List_List_ConflictSet_72210]
    ; jump checks_map_
    jmp checks_map_

List_Node_Pair_List_Assign_List_List_ConflictSet_72210:
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_72210_Nil
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_72210_Cons

List_Node_Pair_List_Assign_List_List_ConflictSet_72210_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72213
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab72211
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72211:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab72212
    ; ####increment refcount
    add qword [rax + 0], 1

lab72212:
    jmp lab72214

lab72213:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab72214:
    ; let x1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_List_List_ConflictSet_72210_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72217
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72215
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72215:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab72216
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72216:
    jmp lab72218

lab72217:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab72218:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72230
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72231

lab72230:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72228
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72221
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72219
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72220

lab72219:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72220:

lab72221:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72224
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72222
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72223

lab72222:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72223:

lab72224:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72227
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72225
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72226

lab72225:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72226:

lab72227:
    jmp lab72229

lab72228:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72229:

lab72231:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

checks_tail_:
    ; substitute (a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_ConflictSet_72232]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_72232:
    jmp near List_List_ConflictSet_72232_Nil
    jmp near List_List_ConflictSet_72232_Cons

List_List_ConflictSet_72232_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_72232_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab72235
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab72233
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72233:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab72234
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72234:
    jmp lab72236

lab72235:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab72236:
    ; substitute (a0 !-> a0)(ls0 !-> ls0);
    ; #erase l
    cmp rsi, 0
    je lab72239
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab72237
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab72238

lab72237:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab72238:

lab72239:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; switch ls0 \{ ... \};
    lea rcx, [rel List_List_ConflictSet_72240]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_72240:
    jmp near List_List_ConflictSet_72240_Nil
    jmp near List_List_ConflictSet_72240_Cons

List_List_ConflictSet_72240_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_72240_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab72243
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab72241
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72241:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab72242
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72242:
    jmp lab72244

lab72243:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab72244:
    ; substitute (a1 !-> a1)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

cache_checks_:
    ; substitute (csp !-> csp)(tbl !-> tbl)(a0 !-> a0)(n !-> n);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch n \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_List_Assign_72245:

Node_List_Assign_72245_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab72248
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab72246
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72246:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab72247
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72247:
    jmp lab72249

lab72248:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab72249:
    ; substitute (csp !-> csp)(tbl !-> tbl)(a0 !-> a0)(s !-> s)(cs !-> cs)(s0 !-> s)(tbl0 !-> tbl);
    ; #share s
    cmp r10, 0
    je lab72250
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72250:
    ; #share tbl
    cmp rsi, 0
    je lab72251
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72251:
    ; #move variables
    mov [rsp + 2032], rsi
    mov [rsp + 2024], rdi
    mov r14, r10
    mov r15, r11
    ; let x0: Pair[List[Assign], List[List[ConflictSet]]] = Tup(s0, tbl0);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72263
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab72264

lab72263:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72261
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72254
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72252
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72253

lab72252:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72253:

lab72254:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72257
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72255
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72256

lab72255:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72256:

lab72257:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72260
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72258
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72259

lab72258:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72259:

lab72260:
    jmp lab72262

lab72261:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72262:

lab72264:
    ; #load tag
    mov r15, 0
    ; substitute (csp !-> csp)(tbl !-> tbl)(cs !-> cs)(s !-> s)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, r12
    mov r12, r8
    mov r8, rcx
    mov rcx, r13
    mov r13, r9
    mov r9, rcx
    ; new a1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72276
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab72277

lab72276:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72274
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72267
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72265
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72266

lab72265:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72266:

lab72267:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72270
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72268
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72269

lab72268:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72269:

lab72270:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72273
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72271
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72272

lab72271:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72272:

lab72273:
    jmp lab72275

lab72274:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72275:

lab72277:
    ; #load tag
    lea r13, [rel List_Node_Pair_List_Assign_List_List_ConflictSet_72278]
    ; substitute (a1 !-> a1)(cs !-> cs)(tbl !-> tbl)(s !-> s)(csp !-> csp);
    ; #move variables
    mov rcx, r12
    mov r12, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new x2: Fun[Node[List[Assign]], Node[Pair[List[Assign], List[List[ConflictSet]]]]] = (tbl, s, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72290
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72291

lab72290:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72288
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72281
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72279
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72280

lab72279:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72280:

lab72281:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72284
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72282
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72283

lab72282:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72283:

lab72284:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72287
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72285
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72286

lab72285:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72286:

lab72287:
    jmp lab72289

lab72288:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72289:

lab72291:
    ; #load tag
    lea r9, [rel Fun_Node_List_Assign_Node_Pair_List_Assign_List_List_ConflictSet_72292]
    ; substitute (x2 !-> x2)(cs !-> cs)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump checks_map_
    jmp checks_map_

Fun_Node_List_Assign_Node_Pair_List_Assign_List_List_ConflictSet_72292:

Fun_Node_List_Assign_Node_Pair_List_Assign_List_List_ConflictSet_72292_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72296
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab72293
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72293:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab72294
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72294:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab72295
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72295:
    jmp lab72297

lab72296:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab72297:
    ; substitute (csp0 !-> csp)(s !-> s)(tbl !-> tbl)(a2 !-> a2)(csp !-> csp)(x !-> x);
    ; #share csp
    cmp r12, 0
    je lab72298
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72298:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    mov rax, r12
    mov rdx, r13
    ; new a3: List[List[ConflictSet]] = (a2, csp, x)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72310
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72311

lab72310:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72308
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72301
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72299
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72300

lab72299:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72300:

lab72301:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72304
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72302
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72303

lab72302:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72303:

lab72304:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72307
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72305
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72306

lab72305:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72306:

lab72307:
    jmp lab72309

lab72308:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72309:

lab72311:
    ; #load tag
    lea r11, [rel List_List_ConflictSet_72312]
    ; substitute (tbl !-> tbl)(s !-> s)(csp0 !-> csp0)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new a4: List[List[ConflictSet]] = (s, csp0, a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72324
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab72325

lab72324:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72322
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72315
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72313
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72314

lab72313:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72314:

lab72315:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72318
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72316
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72317

lab72316:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72317:

lab72318:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72321
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72319
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72320

lab72319:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72320:

lab72321:
    jmp lab72323

lab72322:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72323:

lab72325:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_72326]
    ; jump checks_tail_
    jmp checks_tail_

List_List_ConflictSet_72326:
    jmp near List_List_ConflictSet_72326_Nil
    jmp near List_List_ConflictSet_72326_Cons

List_List_ConflictSet_72326_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72330
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab72327
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72327:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab72328
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72328:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab72329
    ; ####increment refcount
    add qword [rax + 0], 1

lab72329:
    jmp lab72331

lab72330:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab72331:
    ; let x4: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (s !-> s)(csp0 !-> csp0)(x4 !-> x4)(a3 !-> a3);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; jump fill_table_
    jmp fill_table_

List_List_ConflictSet_72326_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72335
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab72332
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72332:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab72333
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72333:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab72334
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72334:
    jmp lab72336

lab72335:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab72336:
    ; substitute (a3 !-> a3)(csp0 !-> csp0)(s !-> s)(a7 !-> a7)(as2 !-> as2);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x4: List[List[ConflictSet]] = Cons(a7, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72348
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72349

lab72348:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72346
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72339
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72337
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72338

lab72337:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72338:

lab72339:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72342
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72340
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72341

lab72340:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72341:

lab72342:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72345
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72343
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72344

lab72343:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72344:

lab72345:
    jmp lab72347

lab72346:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72347:

lab72349:
    ; #load tag
    mov r11, 5
    ; substitute (s !-> s)(csp0 !-> csp0)(x4 !-> x4)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; jump fill_table_
    jmp fill_table_

List_List_ConflictSet_72312:
    jmp near List_List_ConflictSet_72312_Nil
    jmp near List_List_ConflictSet_72312_Cons

List_List_ConflictSet_72312_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72353
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab72350
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72350:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab72351
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72351:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab72352
    ; ####increment refcount
    add qword [rax + 0], 1

lab72352:
    jmp lab72354

lab72353:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab72354:
    ; let x3: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (csp !-> csp)(x3 !-> x3)(x !-> x)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; jump cache_checks_
    jmp cache_checks_

List_List_ConflictSet_72312_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72358
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab72355
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72355:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab72356
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72356:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab72357
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72357:
    jmp lab72359

lab72358:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab72359:
    ; substitute (x !-> x)(csp !-> csp)(a2 !-> a2)(a6 !-> a6)(as1 !-> as1);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x3: List[List[ConflictSet]] = Cons(a6, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72371
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72372

lab72371:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72369
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72362
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72360
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72361

lab72360:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72361:

lab72362:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72365
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72363
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72364

lab72363:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72364:

lab72365:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72368
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72366
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72367

lab72366:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72367:

lab72368:
    jmp lab72370

lab72369:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72370:

lab72372:
    ; #load tag
    mov r11, 5
    ; substitute (csp !-> csp)(x3 !-> x3)(x !-> x)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r10
    mov r10, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r11
    mov r11, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump cache_checks_
    jmp cache_checks_

List_Node_Pair_List_Assign_List_List_ConflictSet_72278:
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_72278_Nil
    jmp near List_Node_Pair_List_Assign_List_List_ConflictSet_72278_Cons

List_Node_Pair_List_Assign_List_List_ConflictSet_72278_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72375
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab72373
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72373:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab72374
    ; ####increment refcount
    add qword [rax + 0], 1

lab72374:
    jmp lab72376

lab72375:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab72376:
    ; let x1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    jmp r9

List_Node_Pair_List_Assign_List_List_ConflictSet_72278_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72379
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72377
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72377:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab72378
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72378:
    jmp lab72380

lab72379:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab72380:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a5 !-> a5)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], List[List[ConflictSet]]]]] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72392
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72393

lab72392:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72390
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72383
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72381
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72382

lab72381:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72382:

lab72383:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72386
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72384
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72385

lab72384:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72385:

lab72386:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72389
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72387
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72388

lab72387:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72388:

lab72389:
    jmp lab72391

lab72390:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72391:

lab72393:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    jmp r9

bm_fst_:
    ; substitute (a0 !-> a0)(x !-> x);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch x \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_72394:

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_72394_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab72397
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab72395
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72395:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab72396
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72396:
    jmp lab72398

lab72397:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab72398:
    ; substitute (a0 !-> a0)(p !-> p);
    ; #erase ls
    cmp r8, 0
    je lab72401
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab72399
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab72400

lab72399:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab72400:

lab72401:
    ; switch p \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_List_Assign_ConflictSet_72402:

Pair_List_Assign_ConflictSet_72402_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab72405
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab72403
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72403:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab72404
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72404:
    jmp lab72406

lab72405:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab72406:
    ; substitute (a1 !-> a1)(b0 !-> b0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Tup
    jmp r9

bm_map_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_72407]
    add rcx, r9
    jmp rcx

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_72407:
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_72407_Nil
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_72407_Cons

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_72407_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab72410
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab72408
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab72409

lab72408:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab72409:

lab72410:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_72407_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72413
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72411
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72411:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab72412
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72412:
    jmp lab72414

lab72413:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab72414:
    ; substitute (f0 !-> f)(n !-> n)(a0 !-> a0)(ns !-> ns)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab72415
    ; ####increment refcount
    add qword [rax + 0], 1

lab72415:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ns, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72427
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72428

lab72427:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72425
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72418
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72416
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72417

lab72416:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72417:

lab72418:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72421
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72419
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72420

lab72419:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72420:

lab72421:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72424
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72422
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72423

lab72422:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72423:

lab72424:
    jmp lab72426

lab72425:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72426:

lab72428:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_72429]
    ; substitute (n !-> n)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Node_Pair_List_Assign_ConflictSet_72429:

Node_Pair_List_Assign_ConflictSet_72429_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72433
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab72430
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72430:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab72431
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72431:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab72432
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72432:
    jmp lab72434

lab72433:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab72434:
    ; substitute (f !-> f)(ns !-> ns)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72446
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72447

lab72446:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72444
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72437
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72435
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72436

lab72435:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72436:

lab72437:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72440
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72438
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72439

lab72438:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72439:

lab72440:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72443
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72441
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72442

lab72441:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72442:

lab72443:
    jmp lab72445

lab72444:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72445:

lab72447:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72459
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72460

lab72459:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72457
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72450
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72448
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72449

lab72448:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72449:

lab72450:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72453
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72451
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72452

lab72451:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72452:

lab72453:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72456
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72454
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72455

lab72454:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72455:

lab72456:
    jmp lab72458

lab72457:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72458:

lab72460:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_72461]
    ; jump bm_map_
    jmp bm_map_

List_Node_Pair_List_Assign_ConflictSet_72461:
    jmp near List_Node_Pair_List_Assign_ConflictSet_72461_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_72461_Cons

List_Node_Pair_List_Assign_ConflictSet_72461_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72464
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab72462
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72462:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab72463
    ; ####increment refcount
    add qword [rax + 0], 1

lab72463:
    jmp lab72465

lab72464:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab72465:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_72461_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72468
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72466
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72466:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab72467
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72467:
    jmp lab72469

lab72468:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab72469:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72481
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72482

lab72481:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72479
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72472
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72470
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72471

lab72470:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72471:

lab72472:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72475
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72473
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72474

lab72473:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72474:

lab72475:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72478
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72476
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72477

lab72476:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72477:

lab72478:
    jmp lab72480

lab72479:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72480:

lab72482:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bm_map_tree_:
    ; substitute (f !-> f)(a0 !-> a0)(t !-> t);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch t \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_72483:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_72483_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72486
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72484
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72484:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab72485
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72485:
    jmp lab72487

lab72486:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab72487:
    ; substitute (f0 !-> f)(p !-> p)(a0 !-> a0)(ps !-> ps)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab72488
    ; ####increment refcount
    add qword [rax + 0], 1

lab72488:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Pair[List[Assign], ConflictSet] = (a0, ps, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72500
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72501

lab72500:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72498
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72491
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72489
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72490

lab72489:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72490:

lab72491:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72494
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72492
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72493

lab72492:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72493:

lab72494:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72497
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72495
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72496

lab72495:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72496:

lab72497:
    jmp lab72499

lab72498:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72499:

lab72501:
    ; #load tag
    lea r9, [rel Pair_List_Assign_ConflictSet_72502]
    ; substitute (p !-> p)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Pair_List_Assign_ConflictSet_72502:

Pair_List_Assign_ConflictSet_72502_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72506
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab72503
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72503:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab72504
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72504:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab72505
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72505:
    jmp lab72507

lab72506:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab72507:
    ; substitute (f !-> f)(ps !-> ps)(a0 !-> a0)(a5 !-> a5)(b0 !-> b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a5, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72519
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72520

lab72519:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72517
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72510
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72508
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72509

lab72508:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72509:

lab72510:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72513
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72511
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72512

lab72511:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72512:

lab72513:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72516
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72514
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72515

lab72514:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72515:

lab72516:
    jmp lab72518

lab72517:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72518:

lab72520:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72532
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72533

lab72532:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72530
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72523
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72521
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72522

lab72521:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72522:

lab72523:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72526
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72524
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72525

lab72524:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72525:

lab72526:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72529
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72527
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72528

lab72527:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72528:

lab72529:
    jmp lab72531

lab72530:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72531:

lab72533:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_72534]
    ; substitute (a2 !-> a2)(ps !-> ps)(f !-> f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new x2: Fun[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]], Node[Pair[List[Assign], ConflictSet]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72546
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72547

lab72546:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72544
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72537
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72535
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72536

lab72535:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72536:

lab72537:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72540
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72538
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72539

lab72538:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72539:

lab72540:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72543
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72541
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72542

lab72541:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72542:

lab72543:
    jmp lab72545

lab72544:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72545:

lab72547:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_72548]
    ; substitute (x2 !-> x2)(ps !-> ps)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bm_map_
    jmp bm_map_

Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_72548:

Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_72548_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72550
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab72549
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72549:
    jmp lab72551

lab72550:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab72551:
    ; substitute (f !-> f)(x !-> x)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bm_map_tree_
    jmp bm_map_tree_

List_Node_Pair_List_Assign_ConflictSet_72534:
    jmp near List_Node_Pair_List_Assign_ConflictSet_72534_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_72534_Cons

List_Node_Pair_List_Assign_ConflictSet_72534_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72554
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab72552
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72552:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab72553
    ; ####increment refcount
    add qword [rax + 0], 1

lab72553:
    jmp lab72555

lab72554:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab72555:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_72534_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72558
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72556
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72556:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab72557
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72557:
    jmp lab72559

lab72558:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab72559:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72571
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72572

lab72571:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72569
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72562
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72560
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72561

lab72560:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72561:

lab72562:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72565
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72563
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72564

lab72563:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72564:

lab72565:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72568
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72566
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72567

lab72566:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72567:

lab72568:
    jmp lab72570

lab72569:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72570:

lab72572:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    jmp r9

bm_:
    ; new x0: Fun[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]], Pair[List[Assign], ConflictSet]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_72573]
    ; new a2: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72585
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72586

lab72585:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72583
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72576
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72574
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72575

lab72574:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72575:

lab72576:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72579
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72577
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72578

lab72577:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72578:

lab72579:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72582
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72580
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72581

lab72580:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72581:

lab72582:
    jmp lab72584

lab72583:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72584:

lab72586:
    ; #load tag
    lea r9, [rel Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_72587]
    ; substitute (csp0 !-> csp)(t !-> t)(a2 !-> a2)(csp !-> csp);
    ; #share csp
    cmp rax, 0
    je lab72588
    ; ####increment refcount
    add qword [rax + 0], 1

lab72588:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; new a3: Node[Pair[List[Assign], List[List[ConflictSet]]]] = (a2, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72600
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72601

lab72600:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72598
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72591
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72589
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72590

lab72589:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72590:

lab72591:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72594
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72592
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72593

lab72592:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72593:

lab72594:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72597
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72595
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72596

lab72595:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72596:

lab72597:
    jmp lab72599

lab72598:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72599:

lab72601:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_List_List_ConflictSet_72602]
    ; substitute (csp00 !-> csp0)(t !-> t)(a3 !-> a3)(csp0 !-> csp0);
    ; #share csp0
    cmp rax, 0
    je lab72603
    ; ####increment refcount
    add qword [rax + 0], 1

lab72603:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; new a4: List[List[ConflictSet]] = (t, a3, csp0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72615
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab72616

lab72615:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72613
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72606
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72604
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72605

lab72604:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72605:

lab72606:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72609
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72607
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72608

lab72607:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72608:

lab72609:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72612
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72610
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72611

lab72610:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72611:

lab72612:
    jmp lab72614

lab72613:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72614:

lab72616:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_72617]
    ; jump empty_table_
    jmp empty_table_

List_List_ConflictSet_72617:
    jmp near List_List_ConflictSet_72617_Nil
    jmp near List_List_ConflictSet_72617_Cons

List_List_ConflictSet_72617_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72621
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab72618
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72618:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab72619
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72619:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab72620
    ; ####increment refcount
    add qword [rax + 0], 1

lab72620:
    jmp lab72622

lab72621:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab72622:
    ; let x3: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (csp0 !-> csp0)(x3 !-> x3)(t !-> t)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump cache_checks_
    jmp cache_checks_

List_List_ConflictSet_72617_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72626
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab72623
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72623:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab72624
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72624:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab72625
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72625:
    jmp lab72627

lab72626:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab72627:
    ; substitute (csp0 !-> csp0)(a3 !-> a3)(t !-> t)(a5 !-> a5)(as0 !-> as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x3: List[List[ConflictSet]] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72639
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72640

lab72639:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72637
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72630
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72628
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72629

lab72628:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72629:

lab72630:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72633
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72631
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72632

lab72631:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72632:

lab72633:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72636
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72634
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72635

lab72634:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72635:

lab72636:
    jmp lab72638

lab72637:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72638:

lab72640:
    ; #load tag
    mov r11, 5
    ; substitute (csp0 !-> csp0)(x3 !-> x3)(t !-> t)(a3 !-> a3);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump cache_checks_
    jmp cache_checks_

Node_Pair_List_Assign_List_List_ConflictSet_72602:

Node_Pair_List_Assign_List_List_ConflictSet_72602_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72643
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72641
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72641:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab72642
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72642:
    jmp lab72644

lab72643:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab72644:
    ; substitute (csp !-> csp)(a2 !-> a2)(lab1 !-> lab1)(children1 !-> children1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x2: Node[Pair[List[Assign], List[List[ConflictSet]]]] = Node(lab1, children1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72656
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72657

lab72656:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72654
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72647
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72645
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72646

lab72645:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72646:

lab72647:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72650
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72648
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72649

lab72648:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72649:

lab72650:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72653
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72651
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72652

lab72651:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72652:

lab72653:
    jmp lab72655

lab72654:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72655:

lab72657:
    ; #load tag
    mov r9, 0
    ; substitute (csp !-> csp)(x2 !-> x2)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lookup_cache_
    jmp lookup_cache_

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_72587:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_72587_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72660
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72658
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72658:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab72659
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72659:
    jmp lab72661

lab72660:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab72661:
    ; substitute (x0 !-> x0)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72673
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72674

lab72673:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72671
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72664
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72662
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72663

lab72662:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72663:

lab72664:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72667
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72665
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72666

lab72665:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72666:

lab72667:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72670
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72668
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72669

lab72668:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72669:

lab72670:
    jmp lab72672

lab72671:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72672:

lab72674:
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump bm_map_tree_
    jmp bm_map_tree_

Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_72573:

Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_72573_Ap:
    ; jump bm_fst_
    jmp bm_fst_

in_list_:
    ; substitute (i !-> i)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_72675]
    add rcx, r9
    jmp rcx

List_i64_72675:
    jmp near List_i64_72675_Nil
    jmp near List_i64_72675_Cons

List_i64_72675_Nil:
    ; substitute (a0 !-> a0);
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 False
    add rdx, 5
    jmp rdx

List_i64_72675_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72677
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72676
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72676:
    mov r9, [r8 + 40]
    jmp lab72678

lab72677:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab72678:
    ; if i == j \{ ... \}
    cmp rdx, r9
    je lab72679
    ; substitute (i !-> i)(js !-> js)(a0 !-> a0);
    ; #move variables
    mov r8, rsi
    mov r9, rdi
    mov rsi, r10
    mov rdi, r11
    ; jump in_list_
    jmp in_list_

lab72679:
    ; substitute (a0 !-> a0);
    ; #erase js
    cmp r10, 0
    je lab72682
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab72680
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab72681

lab72680:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab72681:

lab72682:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 True
    add rdx, 0
    jmp rdx

not_elem_:
    ; new a1: Bool = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72694
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72695

lab72694:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72692
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72685
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72683
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72684

lab72683:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72684:

lab72685:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72688
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72686
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72687

lab72686:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72687:

lab72688:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72691
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72689
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72690

lab72689:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72690:

lab72691:
    jmp lab72693

lab72692:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72693:

lab72695:
    ; #load tag
    lea r9, [rel Bool_72696]
    ; jump in_list_
    jmp in_list_

Bool_72696:
    jmp near Bool_72696_True
    jmp near Bool_72696_False

Bool_72696_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72698
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab72697
    ; ####increment refcount
    add qword [rax + 0], 1

lab72697:
    jmp lab72699

lab72698:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab72699:
    ; let x0: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_72696_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72701
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab72700
    ; ####increment refcount
    add qword [rax + 0], 1

lab72700:
    jmp lab72702

lab72701:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab72702:
    ; let x0: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

append_:
    ; substitute (a0 !-> a0)(l2 !-> l2)(l1 !-> l1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch l1 \{ ... \};
    lea rcx, [rel List_i64_72703]
    add rcx, r9
    jmp rcx

List_i64_72703:
    jmp near List_i64_72703_Nil
    jmp near List_i64_72703_Cons

List_i64_72703_Nil:
    ; switch l2 \{ ... \};
    lea rcx, [rel List_i64_72704]
    add rcx, rdi
    jmp rcx

List_i64_72704:
    jmp near List_i64_72704_Nil
    jmp near List_i64_72704_Cons

List_i64_72704_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_72704_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab72706
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab72705
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72705:
    mov rdi, [rsi + 40]
    jmp lab72707

lab72706:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab72707:
    ; substitute (a2 !-> a2)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_72703_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72709
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72708
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72708:
    mov r9, [r8 + 40]
    jmp lab72710

lab72709:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab72710:
    ; substitute (is !-> is)(l2 !-> l2)(i !-> i)(a0 !-> a0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; new a1: List[i64] = (i, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72722
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72723

lab72722:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72720
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72713
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72711
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72712

lab72711:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72712:

lab72713:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72716
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72714
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72715

lab72714:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72715:

lab72716:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72719
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72717
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72718

lab72717:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72718:

lab72719:
    jmp lab72721

lab72720:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72721:

lab72723:
    ; #load tag
    lea r9, [rel List_i64_72724]
    ; jump append_
    jmp append_

List_i64_72724:
    jmp near List_i64_72724_Nil
    jmp near List_i64_72724_Cons

List_i64_72724_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72726
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab72725
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72725:
    mov rdx, [rax + 40]
    jmp lab72727

lab72726:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab72727:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (i !-> i)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_72724_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72729
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72728
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72728:
    mov r9, [r8 + 40]
    jmp lab72730

lab72729:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab72730:
    ; substitute (a0 !-> a0)(i !-> i)(a3 !-> a3)(as1 !-> as1);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x0: List[i64] = Cons(a3, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72742
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72743

lab72742:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72740
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72733
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72731
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72732

lab72731:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72732:

lab72733:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72736
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72734
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72735

lab72734:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72735:

lab72736:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72739
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72737
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72738

lab72737:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72738:

lab72739:
    jmp lab72741

lab72740:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72741:

lab72743:
    ; #load tag
    mov r9, 5
    ; substitute (i !-> i)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

delete_by_:
    ; substitute (f !-> f)(x !-> x)(a0 !-> a0)(ys !-> ys);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch ys \{ ... \};
    lea rcx, [rel List_i64_72744]
    add rcx, r11
    jmp rcx

List_i64_72744:
    jmp near List_i64_72744_Nil
    jmp near List_i64_72744_Cons

List_i64_72744_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab72747
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab72745
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab72746

lab72745:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab72746:

lab72747:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_72744_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab72749
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab72748
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72748:
    mov r11, [r10 + 40]
    jmp lab72750

lab72749:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]

lab72750:
    ; substitute (f0 !-> f)(x1 !-> x)(y0 !-> y)(y !-> y)(ys0 !-> ys0)(f !-> f)(x !-> x)(a0 !-> a0);
    ; #share f
    cmp rax, 0
    je lab72751
    ; ####increment refcount
    add qword [rax + 0], 1

lab72751:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov [rsp + 2024], rdi
    mov [rsp + 2016], r8
    mov [rsp + 2008], r9
    mov r9, r11
    ; new a3: Bool = (y, ys0, f, x, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov qword [rbx + 32], 0
    mov [rbx + 24], r15
    mov [rbx + 16], r14
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72763
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab72764

lab72763:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72761
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72754
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72752
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72753

lab72752:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72753:

lab72754:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72757
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72755
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72756

lab72755:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72756:

lab72757:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72760
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72758
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72759

lab72758:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72759:

lab72760:
    jmp lab72762

lab72761:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72762:

lab72764:
    ; ##store link to previous block
    mov [rbx + 48], r14
    ; ##store values
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72776
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72777

lab72776:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72774
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72767
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72765
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72766

lab72765:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72766:

lab72767:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72770
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72768
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72769

lab72768:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72769:

lab72770:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72773
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72771
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72772

lab72771:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72772:

lab72773:
    jmp lab72775

lab72774:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72775:

lab72777:
    ; #load tag
    lea r11, [rel Bool_72778]
    ; let a2: Fun[i64, Bool] = Ap(y0, a3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72790
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72791

lab72790:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72788
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72781
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72779
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72780

lab72779:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72780:

lab72781:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72784
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72782
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72783

lab72782:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72783:

lab72784:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72787
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72785
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72786

lab72785:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72786:

lab72787:
    jmp lab72789

lab72788:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72789:

lab72791:
    ; #load tag
    mov r9, 0
    ; substitute (x1 !-> x1)(a2 !-> a2)(f0 !-> f0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Bool_72778:
    jmp near Bool_72778_True
    jmp near Bool_72778_False

Bool_72778_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72795
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab72792
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72792:
    mov rdx, [rax + 24]
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab72793
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72793:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab72794
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72794:
    jmp lab72796

lab72795:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab72796:
    ; substitute (a0 !-> a0)(ys0 !-> ys0);
    ; #erase f
    cmp r8, 0
    je lab72799
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab72797
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab72798

lab72797:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab72798:

lab72799:
    ; #move variables
    mov rax, r12
    mov rdx, r13
    ; switch ys0 \{ ... \};
    lea rcx, [rel List_i64_72800]
    add rcx, rdi
    jmp rcx

List_i64_72800:
    jmp near List_i64_72800_Nil
    jmp near List_i64_72800_Cons

List_i64_72800_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_72800_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab72802
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab72801
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72801:
    mov rdi, [rsi + 40]
    jmp lab72803

lab72802:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab72803:
    ; substitute (a4 !-> a4)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_72778_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72807
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab72804
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72804:
    mov rdx, [rax + 24]
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab72805
    ; ####increment refcount
    add qword [r12 + 0], 1

lab72805:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab72806
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72806:
    jmp lab72808

lab72807:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov r8, [rax + 48]
    ; ###load values
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab72808:
    ; substitute (x !-> x)(ys0 !-> ys0)(f !-> f)(y !-> y)(a0 !-> a0);
    ; #move variables
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; new a1: List[i64] = (y, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72820
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72821

lab72820:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72818
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72811
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72809
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72810

lab72809:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72810:

lab72811:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72814
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72812
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72813

lab72812:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72813:

lab72814:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72817
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72815
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72816

lab72815:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72816:

lab72817:
    jmp lab72819

lab72818:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72819:

lab72821:
    ; #load tag
    lea r11, [rel List_i64_72822]
    ; substitute (f !-> f)(x !-> x)(ys0 !-> ys0)(a1 !-> a1);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; jump delete_by_
    jmp delete_by_

List_i64_72822:
    jmp near List_i64_72822_Nil
    jmp near List_i64_72822_Cons

List_i64_72822_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72824
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab72823
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72823:
    mov rdx, [rax + 40]
    jmp lab72825

lab72824:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab72825:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (y !-> y)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_72822_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72827
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72826
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72826:
    mov r9, [r8 + 40]
    jmp lab72828

lab72827:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab72828:
    ; substitute (a0 !-> a0)(y !-> y)(a5 !-> a5)(as1 !-> as1);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x0: List[i64] = Cons(a5, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72840
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72841

lab72840:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72838
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72831
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72829
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72830

lab72829:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72830:

lab72831:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72834
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72832
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72833

lab72832:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72833:

lab72834:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72837
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72835
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72836

lab72835:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72836:

lab72837:
    jmp lab72839

lab72838:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72839:

lab72841:
    ; #load tag
    mov r9, 5
    ; substitute (y !-> y)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

nub_by_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_72842]
    add rcx, r9
    jmp rcx

List_i64_72842:
    jmp near List_i64_72842_Nil
    jmp near List_i64_72842_Cons

List_i64_72842_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab72845
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab72843
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab72844

lab72843:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab72844:

lab72845:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_72842_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72847
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72846
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72846:
    mov r9, [r8 + 40]
    jmp lab72848

lab72847:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab72848:
    ; substitute (f !-> f)(t !-> t)(h0 !-> h)(h !-> h)(a0 !-> a0);
    ; #move variables
    mov r12, rsi
    mov r13, rdi
    mov rdi, r11
    mov r11, r9
    mov rsi, r10
    ; new a1: List[i64] = (h, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72860
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72861

lab72860:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72858
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72851
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72849
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72850

lab72849:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72850:

lab72851:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72854
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72852
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72853

lab72852:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72853:

lab72854:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72857
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72855
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72856

lab72855:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72856:

lab72857:
    jmp lab72859

lab72858:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72859:

lab72861:
    ; #load tag
    lea r11, [rel List_i64_72862]
    ; substitute (f0 !-> f)(t !-> t)(h0 !-> h0)(a1 !-> a1)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab72863
    ; ####increment refcount
    add qword [rax + 0], 1

lab72863:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    ; new a2: List[i64] = (a1, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72875
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72876

lab72875:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72873
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72866
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72864
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72865

lab72864:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72865:

lab72866:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72869
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72867
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72868

lab72867:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72868:

lab72869:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72872
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72870
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72871

lab72870:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72871:

lab72872:
    jmp lab72874

lab72873:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72874:

lab72876:
    ; #load tag
    lea r11, [rel List_i64_72877]
    ; substitute (a2 !-> a2)(t !-> t)(h0 !-> h0)(f0 !-> f0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; new x2: Fun[i64, Bool] = (h0, f0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72889
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72890

lab72889:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72887
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72880
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72878
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72879

lab72878:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72879:

lab72880:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72883
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72881
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72882

lab72881:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72882:

lab72883:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72886
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72884
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72885

lab72884:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72885:

lab72886:
    jmp lab72888

lab72887:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72888:

lab72890:
    ; #load tag
    lea r9, [rel Fun_i64_Bool_72891]
    ; substitute (x2 !-> x2)(t !-> t)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump filter_union_
    jmp filter_union_

Fun_i64_Bool_72891:

Fun_i64_Bool_72891_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72893
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72892
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72892:
    mov r9, [r8 + 40]
    jmp lab72894

lab72893:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab72894:
    ; substitute (y !-> y)(f0 !-> f0)(h0 !-> h0)(a3 !-> a3);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; new a4: Bool = (a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72906
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72907

lab72906:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72904
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72897
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72895
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72896

lab72895:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72896:

lab72897:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72900
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72898
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72899

lab72898:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72899:

lab72900:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72903
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72901
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72902

lab72901:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72902:

lab72903:
    jmp lab72905

lab72904:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72905:

lab72907:
    ; #load tag
    lea r11, [rel Bool_72908]
    ; substitute (h0 !-> h0)(f0 !-> f0)(y !-> y)(a4 !-> a4);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; let a5: Fun[i64, Bool] = Ap(y, a4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72920
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72921

lab72920:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72918
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72911
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72909
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72910

lab72909:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72910:

lab72911:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72914
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72912
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72913

lab72912:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72913:

lab72914:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72917
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72915
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72916

lab72915:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72916:

lab72917:
    jmp lab72919

lab72918:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72919:

lab72921:
    ; #load tag
    mov r9, 0
    ; substitute (h0 !-> h0)(a5 !-> a5)(f0 !-> f0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke f0 Ap
    jmp r9

Bool_72908:
    jmp near Bool_72908_True
    jmp near Bool_72908_False

Bool_72908_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72923
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab72922
    ; ####increment refcount
    add qword [rax + 0], 1

lab72922:
    jmp lab72924

lab72923:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab72924:
    ; let x3: Bool = True();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x3 !-> x3)(a3 !-> a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

Bool_72908_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72926
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab72925
    ; ####increment refcount
    add qword [rax + 0], 1

lab72925:
    jmp lab72927

lab72926:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab72927:
    ; let x3: Bool = False();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 5
    ; substitute (x3 !-> x3)(a3 !-> a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump not_
    jmp not_

List_i64_72877:
    jmp near List_i64_72877_Nil
    jmp near List_i64_72877_Cons

List_i64_72877_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72930
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab72928
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72928:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab72929
    ; ####increment refcount
    add qword [rax + 0], 1

lab72929:
    jmp lab72931

lab72930:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab72931:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (f !-> f)(x1 !-> x1)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump nub_by_
    jmp nub_by_

List_i64_72877_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72934
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72932
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72932:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab72933
    ; ####increment refcount
    add qword [r8 + 0], 1

lab72933:
    jmp lab72935

lab72934:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab72935:
    ; substitute (f !-> f)(a1 !-> a1)(a7 !-> a7)(as1 !-> as1);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x1: List[i64] = Cons(a7, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72947
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72948

lab72947:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72945
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72938
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72936
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72937

lab72936:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72937:

lab72938:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72941
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72939
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72940

lab72939:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72940:

lab72941:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72944
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72942
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72943

lab72942:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72943:

lab72944:
    jmp lab72946

lab72945:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72946:

lab72948:
    ; #load tag
    mov r9, 5
    ; substitute (f !-> f)(x1 !-> x1)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump nub_by_
    jmp nub_by_

List_i64_72862:
    jmp near List_i64_72862_Nil
    jmp near List_i64_72862_Cons

List_i64_72862_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab72950
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab72949
    ; ####increment refcount
    add qword [rsi + 0], 1

lab72949:
    mov rdx, [rax + 40]
    jmp lab72951

lab72950:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab72951:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (h !-> h)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_72862_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72953
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72952
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72952:
    mov r9, [r8 + 40]
    jmp lab72954

lab72953:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab72954:
    ; substitute (a0 !-> a0)(h !-> h)(a6 !-> a6)(as0 !-> as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x0: List[i64] = Cons(a6, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72966
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab72967

lab72966:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72964
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72957
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72955
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72956

lab72955:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72956:

lab72957:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72960
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72958
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72959

lab72958:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72959:

lab72960:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72963
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72961
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72962

lab72961:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72962:

lab72963:
    jmp lab72965

lab72964:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72965:

lab72967:
    ; #load tag
    mov r9, 5
    ; substitute (h !-> h)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

filter_union_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_i64_72968]
    add rcx, r9
    jmp rcx

List_i64_72968:
    jmp near List_i64_72968_Nil
    jmp near List_i64_72968_Cons

List_i64_72968_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab72971
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab72969
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab72970

lab72969:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab72970:

lab72971:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_72968_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab72973
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab72972
    ; ####increment refcount
    add qword [r10 + 0], 1

lab72972:
    mov r9, [r8 + 40]
    jmp lab72974

lab72973:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab72974:
    ; substitute (f0 !-> f)(i0 !-> i)(i !-> i)(is !-> is)(f !-> f)(a0 !-> a0);
    ; #share f
    cmp rax, 0
    je lab72975
    ; ####increment refcount
    add qword [rax + 0], 1

lab72975:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov r14, rsi
    mov r15, rdi
    mov rdi, r9
    ; new a2: Bool = (i, is, f, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab72987
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab72988

lab72987:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72985
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72978
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72976
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72977

lab72976:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72977:

lab72978:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72981
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72979
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72980

lab72979:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72980:

lab72981:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72984
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72982
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72983

lab72982:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72983:

lab72984:
    jmp lab72986

lab72985:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72986:

lab72988:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73000
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73001

lab73000:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab72998
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab72991
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72989
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72990

lab72989:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72990:

lab72991:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab72994
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72992
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72993

lab72992:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72993:

lab72994:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab72997
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab72995
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab72996

lab72995:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab72996:

lab72997:
    jmp lab72999

lab72998:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab72999:

lab73001:
    ; #load tag
    lea r9, [rel Bool_73002]
    ; substitute (i0 !-> i0)(a2 !-> a2)(f0 !-> f0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Bool_73002:
    jmp near Bool_73002_True
    jmp near Bool_73002_False

Bool_73002_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73006
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab73003
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73003:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab73004
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73004:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab73005
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73005:
    jmp lab73007

lab73006:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab73007:
    ; substitute (f !-> f)(is !-> is)(i !-> i)(a0 !-> a0);
    ; #move variables
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r8
    ; new a1: List[i64] = (i, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73019
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73020

lab73019:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73017
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73010
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73008
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73009

lab73008:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73009:

lab73010:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73013
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73011
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73012

lab73011:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73012:

lab73013:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73016
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73014
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73015

lab73014:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73015:

lab73016:
    jmp lab73018

lab73017:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73018:

lab73020:
    ; #load tag
    lea r9, [rel List_i64_73021]
    ; jump filter_union_
    jmp filter_union_

List_i64_73021:
    jmp near List_i64_73021_Nil
    jmp near List_i64_73021_Cons

List_i64_73021_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73023
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab73022
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73022:
    mov rdx, [rax + 40]
    jmp lab73024

lab73023:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]

lab73024:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (i !-> i)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_73021_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73026
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73025
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73025:
    mov r9, [r8 + 40]
    jmp lab73027

lab73026:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab73027:
    ; substitute (a0 !-> a0)(i !-> i)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    ; let x0: List[i64] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73039
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73040

lab73039:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73037
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73030
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73028
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73029

lab73028:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73029:

lab73030:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73033
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73031
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73032

lab73031:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73032:

lab73033:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73036
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73034
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73035

lab73034:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73035:

lab73036:
    jmp lab73038

lab73037:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73038:

lab73040:
    ; #load tag
    mov r9, 5
    ; substitute (i !-> i)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_73002_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73044
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab73041
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73041:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab73042
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73042:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab73043
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73043:
    jmp lab73045

lab73044:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab73045:
    ; substitute (f !-> f)(is !-> is)(a0 !-> a0);
    ; #move variables
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; jump filter_union_
    jmp filter_union_

foldl_:
    ; substitute (f !-> f)(a !-> a)(a0 !-> a0)(xs !-> xs);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch xs \{ ... \};
    lea rcx, [rel List_i64_73046]
    add rcx, r11
    jmp rcx

List_i64_73046:
    jmp near List_i64_73046_Nil
    jmp near List_i64_73046_Cons

List_i64_73046_Nil:
    ; substitute (a0 !-> a0)(a !-> a);
    ; #erase f
    cmp rax, 0
    je lab73049
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab73047
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab73048

lab73047:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab73048:

lab73049:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; switch a \{ ... \};
    lea rcx, [rel List_i64_73050]
    add rcx, rdi
    jmp rcx

List_i64_73050:
    jmp near List_i64_73050_Nil
    jmp near List_i64_73050_Cons

List_i64_73050_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_73050_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab73052
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab73051
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73051:
    mov rdi, [rsi + 40]
    jmp lab73053

lab73052:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab73053:
    ; substitute (a3 !-> a3)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_73046_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab73055
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab73054
    ; ####increment refcount
    add qword [r12 + 0], 1

lab73054:
    mov r11, [r10 + 40]
    jmp lab73056

lab73055:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]

lab73056:
    ; substitute (f0 !-> f)(a !-> a)(h !-> h)(a0 !-> a0)(t !-> t)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab73057
    ; ####increment refcount
    add qword [rax + 0], 1

lab73057:
    ; #move variables
    mov r14, rax
    mov r15, rdx
    mov r10, r8
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; new a1: List[i64] = (a0, t, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73069
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73070

lab73069:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73067
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73060
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73058
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73059

lab73058:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73059:

lab73060:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73063
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73061
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73062

lab73061:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73062:

lab73063:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73066
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73064
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73065

lab73064:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73065:

lab73066:
    jmp lab73068

lab73067:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73068:

lab73070:
    ; #load tag
    lea r11, [rel List_i64_73071]
    ; let a2: Fun[i64, List[i64]] = Ap(h, a1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73083
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73084

lab73083:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73081
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73074
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73072
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73073

lab73072:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73073:

lab73074:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73077
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73075
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73076

lab73075:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73076:

lab73077:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73080
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73078
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73079

lab73078:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73079:

lab73080:
    jmp lab73082

lab73081:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73082:

lab73084:
    ; #load tag
    mov r9, 0
    ; substitute (a !-> a)(a2 !-> a2)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

List_i64_73071:
    jmp near List_i64_73071_Nil
    jmp near List_i64_73071_Cons

List_i64_73071_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73088
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab73085
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73085:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab73086
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73086:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab73087
    ; ####increment refcount
    add qword [rax + 0], 1

lab73087:
    jmp lab73089

lab73088:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab73089:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (f !-> f)(x0 !-> x0)(t !-> t)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; jump foldl_
    jmp foldl_

List_i64_73071_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73093
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab73090
    ; ####increment refcount
    add qword [r12 + 0], 1

lab73090:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab73091
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73091:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab73092
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73092:
    jmp lab73094

lab73093:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab73094:
    ; substitute (f !-> f)(t !-> t)(a0 !-> a0)(a4 !-> a4)(as1 !-> as1);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, rsi
    mov rsi, r10
    ; let x0: List[i64] = Cons(a4, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73106
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73107

lab73106:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73104
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73097
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73095
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73096

lab73095:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73096:

lab73097:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73100
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73098
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73099

lab73098:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73099:

lab73100:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73103
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73101
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73102

lab73101:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73102:

lab73103:
    jmp lab73105

lab73104:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73105:

lab73107:
    ; #load tag
    mov r11, 5
    ; substitute (f !-> f)(x0 !-> x0)(t !-> t)(a0 !-> a0);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump foldl_
    jmp foldl_

union_by_:
    ; substitute (f !-> f)(l10 !-> l1)(l2 !-> l2)(a0 !-> a0)(l1 !-> l1);
    ; #share l1
    cmp rsi, 0
    je lab73108
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73108:
    ; #move variables
    mov r12, rsi
    mov r13, rdi
    ; new a1: List[i64] = (a0, l1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73120
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73121

lab73120:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73118
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73111
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73109
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73110

lab73109:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73110:

lab73111:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73114
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73112
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73113

lab73112:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73113:

lab73114:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73117
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73115
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73116

lab73115:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73116:

lab73117:
    jmp lab73119

lab73118:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73119:

lab73121:
    ; #load tag
    lea r11, [rel List_i64_73122]
    ; substitute (f0 !-> f)(l10 !-> l10)(l2 !-> l2)(a1 !-> a1)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab73123
    ; ####increment refcount
    add qword [rax + 0], 1

lab73123:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    ; new x1: Fun[List[i64], Fun[i64, List[i64]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73135
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab73136

lab73135:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73133
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73126
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73124
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73125

lab73124:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73125:

lab73126:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73129
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73127
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73128

lab73127:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73128:

lab73129:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73132
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73130
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73131

lab73130:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73131:

lab73132:
    jmp lab73134

lab73133:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73134:

lab73136:
    ; #load tag
    lea r13, [rel Fun_List_i64_Fun_i64_List_i64_73137]
    ; substitute (f0 !-> f0)(l2 !-> l2)(l10 !-> l10)(a1 !-> a1)(x1 !-> x1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a4: List[i64] = (l10, a1, x1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73149
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73150

lab73149:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73147
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73140
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73138
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73139

lab73138:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73139:

lab73140:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73143
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73141
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73142

lab73141:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73142:

lab73143:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73146
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73144
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73145

lab73144:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73145:

lab73146:
    jmp lab73148

lab73147:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73148:

lab73150:
    ; #load tag
    lea r9, [rel List_i64_73151]
    ; jump nub_by_
    jmp nub_by_

List_i64_73151:
    jmp near List_i64_73151_Nil
    jmp near List_i64_73151_Cons

List_i64_73151_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73155
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab73152
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73152:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab73153
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73153:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab73154
    ; ####increment refcount
    add qword [rax + 0], 1

lab73154:
    jmp lab73156

lab73155:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab73156:
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (x1 !-> x1)(x2 !-> x2)(l10 !-> l10)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump foldl_
    jmp foldl_

List_i64_73151_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73160
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab73157
    ; ####increment refcount
    add qword [r12 + 0], 1

lab73157:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab73158
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73158:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab73159
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73159:
    jmp lab73161

lab73160:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab73161:
    ; substitute (x1 !-> x1)(a1 !-> a1)(l10 !-> l10)(a6 !-> a6)(as1 !-> as1);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, rsi
    mov rsi, r10
    ; let x2: List[i64] = Cons(a6, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73173
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73174

lab73173:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73171
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73164
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73162
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73163

lab73162:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73163:

lab73164:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73167
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73165
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73166

lab73165:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73166:

lab73167:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73170
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73168
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73169

lab73168:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73169:

lab73170:
    jmp lab73172

lab73171:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73172:

lab73174:
    ; #load tag
    mov r11, 5
    ; substitute (x1 !-> x1)(x2 !-> x2)(l10 !-> l10)(a1 !-> a1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump foldl_
    jmp foldl_

Fun_List_i64_Fun_i64_List_i64_73137:

Fun_List_i64_Fun_i64_List_i64_73137_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73176
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab73175
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73175:
    jmp lab73177

lab73176:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab73177:
    ; substitute (acc !-> acc)(f !-> f)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_i64_List_i64_73178:

Fun_i64_List_i64_73178_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73180
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73179
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73179:
    mov r9, [r8 + 40]
    jmp lab73181

lab73180:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]

lab73181:
    ; substitute (f !-> f)(y !-> y)(acc !-> acc)(a3 !-> a3);
    ; #move variables
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump delete_by_
    jmp delete_by_

List_i64_73122:
    jmp near List_i64_73122_Nil
    jmp near List_i64_73122_Cons

List_i64_73122_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73184
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab73182
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73182:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab73183
    ; ####increment refcount
    add qword [rax + 0], 1

lab73183:
    jmp lab73185

lab73184:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab73185:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (l1 !-> l1)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump append_
    jmp append_

List_i64_73122_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73188
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73186
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73186:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab73187
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73187:
    jmp lab73189

lab73188:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab73189:
    ; substitute (l1 !-> l1)(a0 !-> a0)(a5 !-> a5)(as0 !-> as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x0: List[i64] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73201
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73202

lab73201:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73199
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73192
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73190
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73191

lab73190:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73191:

lab73192:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73195
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73193
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73194

lab73193:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73194:

lab73195:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73198
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73196
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73197

lab73196:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73197:

lab73198:
    jmp lab73200

lab73199:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73200:

lab73202:
    ; #load tag
    mov r9, 5
    ; substitute (l1 !-> l1)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump append_
    jmp append_

union_:
    ; new x0: Fun[i64, Fun[i64, Bool]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_i64_Fun_i64_Bool_73203]
    ; substitute (x0 !-> x0)(l1 !-> l1)(l2 !-> l2)(a0 !-> a0);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump union_by_
    jmp union_by_

Fun_i64_Fun_i64_Bool_73203:

Fun_i64_Fun_i64_Bool_73203_Ap:
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_i64_Bool_73204:

Fun_i64_Bool_73204_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab73206
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab73205
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73205:
    mov rdi, [rsi + 40]
    jmp lab73207

lab73206:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab73207:
    ; jump eq_
    jmp eq_

combine_:
    ; substitute (a0 !-> a0)(acc !-> acc)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Pair_List_Assign_ConflictSet_73208]
    add rcx, r9
    jmp rcx

List_Pair_List_Assign_ConflictSet_73208:
    jmp near List_Pair_List_Assign_ConflictSet_73208_Nil
    jmp near List_Pair_List_Assign_ConflictSet_73208_Cons

List_Pair_List_Assign_ConflictSet_73208_Nil:
    ; switch acc \{ ... \};
    lea rcx, [rel List_i64_73209]
    add rcx, rdi
    jmp rcx

List_i64_73209:
    jmp near List_i64_73209_Nil
    jmp near List_i64_73209_Cons

List_i64_73209_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_73209_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab73211
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab73210
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73210:
    mov rdi, [rsi + 40]
    jmp lab73212

lab73211:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab73212:
    ; substitute (a4 !-> a4)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_List_Assign_ConflictSet_73208_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73215
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73213
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73213:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab73214
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73214:
    jmp lab73216

lab73215:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab73216:
    ; substitute (a0 !-> a0)(acc !-> acc)(css !-> css)(p !-> p);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; switch p \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_List_Assign_ConflictSet_73217:

Pair_List_Assign_ConflictSet_73217_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab73220
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab73218
    ; ####increment refcount
    add qword [r12 + 0], 1

lab73218:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab73219
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73219:
    jmp lab73221

lab73220:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab73221:
    ; switch cs \{ ... \};
    lea rcx, [rel ConflictSet_73222]
    add rcx, r13
    jmp rcx

ConflictSet_73222:
    jmp near ConflictSet_73222_Known
    jmp near ConflictSet_73222_Unknown

ConflictSet_73222_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [r12 + 0], 0
    je lab73224
    ; ##either decrement refcount and share children...
    add qword [r12 + 0], -1
    ; ###load values
    mov r13, [r12 + 56]
    mov r12, [r12 + 48]
    cmp r12, 0
    je lab73223
    ; ####increment refcount
    add qword [r12 + 0], 1

lab73223:
    jmp lab73225

lab73224:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r12 + 0], rbx
    mov rbx, r12
    ; ###load values
    mov r13, [r12 + 56]
    mov r12, [r12 + 48]

lab73225:
    ; substitute (s !-> s)(acc !-> acc)(css !-> css)(a0 !-> a0)(cs0 !-> cs0);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    ; new a2: _Cont = (acc, css, a0, cs0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73237
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73238

lab73237:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73235
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73228
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73226
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73227

lab73226:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73227:

lab73228:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73231
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73229
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73230

lab73229:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73230:

lab73231:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73234
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73232
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73233

lab73232:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73233:

lab73234:
    jmp lab73236

lab73235:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73236:

lab73238:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73250
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab73251

lab73250:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73248
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73241
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73239
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73240

lab73239:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73240:

lab73241:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73244
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73242
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73243

lab73242:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73243:

lab73244:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73247
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73245
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73246

lab73245:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73246:

lab73247:
    jmp lab73249

lab73248:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73249:

lab73251:
    ; #load tag
    lea rdi, [rel _Cont_73252]
    ; jump max_level_
    jmp max_level_

_Cont_73252:

_Cont_73252_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab73257
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab73253
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73253:
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab73254
    ; ####increment refcount
    add qword [r12 + 0], 1

lab73254:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab73255
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73255:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab73256
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73256:
    jmp lab73258

lab73257:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load link to next block
    mov r8, [rsi + 48]
    ; ###load values
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab73258:
    ; substitute (x0 !-> x0)(cs00 !-> cs0)(css !-> css)(a0 !-> a0)(cs0 !-> cs0)(acc !-> acc);
    ; #share cs0
    cmp r12, 0
    je lab73259
    ; ####increment refcount
    add qword [r12 + 0], 1

lab73259:
    ; #move variables
    mov r14, rsi
    mov r15, rdi
    mov rsi, r12
    mov rdi, r13
    ; new a3: Bool = (css, a0, cs0, acc)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    mov [rbx + 24], r11
    mov [rbx + 16], r10
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73271
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73272

lab73271:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73269
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73262
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73260
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73261

lab73260:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73261:

lab73262:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73265
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73263
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73264

lab73263:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73264:

lab73265:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73268
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73266
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73267

lab73266:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73267:

lab73268:
    jmp lab73270

lab73269:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73270:

lab73272:
    ; ##store link to previous block
    mov [rbx + 48], r10
    ; ##store values
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73284
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73285

lab73284:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73282
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73275
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73273
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73274

lab73273:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73274:

lab73275:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73278
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73276
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73277

lab73276:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73277:

lab73278:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73281
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73279
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73280

lab73279:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73280:

lab73281:
    jmp lab73283

lab73282:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73283:

lab73285:
    ; #load tag
    lea r9, [rel Bool_73286]
    ; jump not_elem_
    jmp not_elem_

Bool_73286:
    jmp near Bool_73286_True
    jmp near Bool_73286_False

Bool_73286_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73291
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab73287
    ; ####increment refcount
    add qword [rax + 0], 1

lab73287:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab73288
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73288:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab73289
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73289:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab73290
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73290:
    jmp lab73292

lab73291:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab73292:
    ; substitute (a0 !-> a0)(cs0 !-> cs0);
    ; #erase acc
    cmp r10, 0
    je lab73295
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab73293
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab73294

lab73293:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab73294:

lab73295:
    ; #erase css
    cmp rax, 0
    je lab73298
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab73296
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab73297

lab73296:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab73297:

lab73298:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    mov rsi, r8
    mov rdi, r9
    ; switch cs0 \{ ... \};
    lea rcx, [rel List_i64_73299]
    add rcx, rdi
    jmp rcx

List_i64_73299:
    jmp near List_i64_73299_Nil
    jmp near List_i64_73299_Cons

List_i64_73299_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_73299_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab73301
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab73300
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73300:
    mov rdi, [rsi + 40]
    jmp lab73302

lab73301:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab73302:
    ; substitute (a5 !-> a5)(as1 !-> as1)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_73286_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73307
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab73303
    ; ####increment refcount
    add qword [rax + 0], 1

lab73303:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab73304
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73304:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab73305
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73305:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab73306
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73306:
    jmp lab73308

lab73307:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab73308:
    ; substitute (acc !-> acc)(cs0 !-> cs0)(a0 !-> a0)(css !-> css);
    ; #move variables
    mov rcx, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: List[i64] = (a0, css)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73320
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73321

lab73320:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73318
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73311
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73309
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73310

lab73309:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73310:

lab73311:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73314
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73312
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73313

lab73312:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73313:

lab73314:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73317
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73315
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73316

lab73315:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73316:

lab73317:
    jmp lab73319

lab73318:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73319:

lab73321:
    ; #load tag
    lea r9, [rel List_i64_73322]
    ; substitute (cs0 !-> cs0)(acc !-> acc)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump union_
    jmp union_

List_i64_73322:
    jmp near List_i64_73322_Nil
    jmp near List_i64_73322_Cons

List_i64_73322_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73325
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab73323
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73323:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab73324
    ; ####increment refcount
    add qword [rax + 0], 1

lab73324:
    jmp lab73326

lab73325:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab73326:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (css !-> css)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump combine_
    jmp combine_

List_i64_73322_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73329
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73327
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73327:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab73328
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73328:
    jmp lab73330

lab73329:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab73330:
    ; substitute (css !-> css)(a0 !-> a0)(a6 !-> a6)(as2 !-> as2);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x1: List[i64] = Cons(a6, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73342
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73343

lab73342:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73340
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73333
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73331
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73332

lab73331:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73332:

lab73333:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73336
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73334
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73335

lab73334:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73335:

lab73336:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73339
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73337
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73338

lab73337:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73338:

lab73339:
    jmp lab73341

lab73340:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73341:

lab73343:
    ; #load tag
    mov r9, 5
    ; substitute (css !-> css)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump combine_
    jmp combine_

ConflictSet_73222_Unknown:
    ; substitute (a0 !-> a0)(acc !-> acc);
    ; #erase css
    cmp r8, 0
    je lab73346
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab73344
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab73345

lab73344:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab73345:

lab73346:
    ; #erase s
    cmp r10, 0
    je lab73349
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab73347
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab73348

lab73347:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab73348:

lab73349:
    ; switch acc \{ ... \};
    lea rcx, [rel List_i64_73350]
    add rcx, rdi
    jmp rcx

List_i64_73350:
    jmp near List_i64_73350_Nil
    jmp near List_i64_73350_Cons

List_i64_73350_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_i64_73350_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab73352
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab73351
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73351:
    mov rdi, [rsi + 40]
    jmp lab73353

lab73352:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab73353:
    ; substitute (a7 !-> a7)(as3 !-> as3)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bj__:
    ; substitute (a0 !-> a0)(t !-> t);
    ; #erase csp
    cmp rax, 0
    je lab73356
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab73354
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab73355

lab73354:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab73355:

lab73356:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; new f7: Fun[Pair[List[Assign], ConflictSet], Fun[List[Node[Pair[List[Assign], ConflictSet]]], Node[Pair[List[Assign], ConflictSet]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Pair_List_Assign_ConflictSet_Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_73357]
    ; substitute (f7 !-> f7)(t !-> t)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bj_fold_tree_
    jmp bj_fold_tree_

Fun_Pair_List_Assign_ConflictSet_Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_73357:

Fun_Pair_List_Assign_ConflictSet_Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_73357_Ap:
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_73358:

Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_73358_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab73361
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab73359
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73359:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab73360
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73360:
    jmp lab73362

lab73361:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab73362:
    ; substitute (a2 !-> a2)(chs !-> chs)(tp2 !-> tp2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch tp2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_List_Assign_ConflictSet_73363:

Pair_List_Assign_ConflictSet_73363_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73366
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73364
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73364:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab73365
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73365:
    jmp lab73367

lab73366:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab73367:
    ; switch conf \{ ... \};
    lea rcx, [rel ConflictSet_73368]
    add rcx, r11
    jmp rcx

ConflictSet_73368:
    jmp near ConflictSet_73368_Known
    jmp near ConflictSet_73368_Unknown

ConflictSet_73368_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab73370
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]
    cmp r10, 0
    je lab73369
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73369:
    jmp lab73371

lab73370:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]

lab73371:
    ; let x1: ConflictSet = Known(cs);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73383
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73384

lab73383:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73381
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73374
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73372
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73373

lab73372:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73373:

lab73374:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73377
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73375
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73376

lab73375:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73376:

lab73377:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73380
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73378
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73379

lab73378:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73379:

lab73380:
    jmp lab73382

lab73381:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73382:

lab73384:
    ; #load tag
    mov r11, 0
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a, x1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73396
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73397

lab73396:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73394
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73387
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73385
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73386

lab73385:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73386:

lab73387:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73390
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73388
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73389

lab73388:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73389:

lab73390:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73393
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73391
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73392

lab73391:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73392:

lab73393:
    jmp lab73395

lab73394:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73395:

lab73397:
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(chs !-> chs)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a2 Node
    jmp r9

ConflictSet_73368_Unknown:
    ; substitute (chs0 !-> chs)(chs !-> chs)(a !-> a)(a2 !-> a2);
    ; #share chs
    cmp rsi, 0
    je lab73398
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73398:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rax, rsi
    mov rdx, rdi
    ; new a3: List[i64] = (chs, a, a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73410
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab73411

lab73410:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73408
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73401
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73399
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73400

lab73399:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73400:

lab73401:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73404
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73402
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73403

lab73402:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73403:

lab73404:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73407
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73405
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73406

lab73405:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73406:

lab73407:
    jmp lab73409

lab73408:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73409:

lab73411:
    ; #load tag
    lea rdi, [rel List_i64_73412]
    ; new a4: List[Pair[List[Assign], ConflictSet]] = (a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73424
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab73425

lab73424:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73422
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73415
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73413
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73414

lab73413:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73414:

lab73415:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73418
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73416
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73417

lab73416:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73417:

lab73418:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73421
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73419
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73420

lab73419:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73420:

lab73421:
    jmp lab73423

lab73422:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73423:

lab73425:
    ; #load tag
    lea rdi, [rel List_Pair_List_Assign_ConflictSet_73426]
    ; new x4: Fun[Node[Pair[List[Assign], ConflictSet]], Pair[List[Assign], ConflictSet]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_73427]
    ; substitute (x4 !-> x4)(chs0 !-> chs0)(a4 !-> a4);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bj_map_
    jmp bj_map_

Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_73427:

Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_73427_Ap:
    ; jump bj_label_
    jmp bj_label_

List_Pair_List_Assign_ConflictSet_73426:
    jmp near List_Pair_List_Assign_ConflictSet_73426_Nil
    jmp near List_Pair_List_Assign_ConflictSet_73426_Cons

List_Pair_List_Assign_ConflictSet_73426_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73429
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab73428
    ; ####increment refcount
    add qword [rax + 0], 1

lab73428:
    jmp lab73430

lab73429:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab73430:
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; jump lift_bj__1_
    jmp lift_bj__1_

List_Pair_List_Assign_ConflictSet_73426_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73432
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab73431
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73431:
    jmp lab73433

lab73432:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab73433:
    ; substitute (a3 !-> a3)(a8 !-> a8)(as1 !-> as1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x3: List[Pair[List[Assign], ConflictSet]] = Cons(a8, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73445
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab73446

lab73445:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73443
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73436
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73434
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73435

lab73434:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73435:

lab73436:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73439
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73437
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73438

lab73437:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73438:

lab73439:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73442
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73440
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73441

lab73440:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73441:

lab73442:
    jmp lab73444

lab73443:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73444:

lab73446:
    ; #load tag
    mov rdi, 5
    ; jump lift_bj__1_
    jmp lift_bj__1_

List_i64_73412:
    jmp near List_i64_73412_Nil
    jmp near List_i64_73412_Cons

List_i64_73412_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73450
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab73447
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73447:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab73448
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73448:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab73449
    ; ####increment refcount
    add qword [rax + 0], 1

lab73449:
    jmp lab73451

lab73450:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab73451:
    ; let x2: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a !-> a)(a2 !-> a2)(chs !-> chs)(x2 !-> x2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_bj__0_
    jmp lift_bj__0_

List_i64_73412_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73455
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab73452
    ; ####increment refcount
    add qword [r12 + 0], 1

lab73452:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab73453
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73453:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab73454
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73454:
    jmp lab73456

lab73455:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab73456:
    ; substitute (a2 !-> a2)(a !-> a)(chs !-> chs)(a7 !-> a7)(as0 !-> as0);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, rsi
    mov rsi, r10
    ; let x2: List[i64] = Cons(a7, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73468
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73469

lab73468:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73466
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73459
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73457
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73458

lab73457:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73458:

lab73459:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73462
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73460
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73461

lab73460:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73461:

lab73462:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73465
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73463
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73464

lab73463:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73464:

lab73465:
    jmp lab73467

lab73466:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73467:

lab73469:
    ; #load tag
    mov r11, 5
    ; substitute (a !-> a)(a2 !-> a2)(chs !-> chs)(x2 !-> x2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_bj__0_
    jmp lift_bj__0_

lift_bj__1_:
    ; let x5: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x3 !-> x3)(x5 !-> x5)(a3 !-> a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump combine_
    jmp combine_

lift_bj__0_:
    ; let cs_: ConflictSet = Known(x2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73481
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73482

lab73481:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73479
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73472
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73470
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73471

lab73470:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73471:

lab73472:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73475
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73473
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73474

lab73473:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73474:

lab73475:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73478
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73476
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73477

lab73476:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73477:

lab73478:
    jmp lab73480

lab73479:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73480:

lab73482:
    ; #load tag
    mov r11, 0
    ; substitute (cs_0 !-> cs_)(a2 !-> a2)(chs !-> chs)(cs_ !-> cs_)(a !-> a);
    ; #share cs_
    cmp r10, 0
    je lab73483
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73483:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rax, r10
    mov rdx, r11
    ; new a6: Bool = (a2, chs, cs_, a)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73495
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73496

lab73495:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73493
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73486
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73484
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73485

lab73484:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73485:

lab73486:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73489
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73487
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73488

lab73487:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73488:

lab73489:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73492
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73490
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73491

lab73490:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73491:

lab73492:
    jmp lab73494

lab73493:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73494:

lab73496:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73508
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab73509

lab73508:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73506
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73499
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73497
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73498

lab73497:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73498:

lab73499:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73502
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73500
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73501

lab73500:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73501:

lab73502:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73505
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73503
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73504

lab73503:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73504:

lab73505:
    jmp lab73507

lab73506:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73507:

lab73509:
    ; #load tag
    lea rdi, [rel Bool_73510]
    ; jump known_conflict_
    jmp known_conflict_

Bool_73510:
    jmp near Bool_73510_True
    jmp near Bool_73510_False

Bool_73510_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73515
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab73511
    ; ####increment refcount
    add qword [rax + 0], 1

lab73511:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab73512
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73512:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab73513
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73513:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab73514
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73514:
    jmp lab73516

lab73515:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab73516:
    ; substitute (a2 !-> a2)(a !-> a)(cs_ !-> cs_);
    ; #erase chs
    cmp rsi, 0
    je lab73519
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab73517
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab73518

lab73517:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab73518:

lab73519:
    ; #move variables
    mov rsi, r10
    mov rdi, r11
    ; let x6: Pair[List[Assign], ConflictSet] = Tup(a, cs_);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73531
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab73532

lab73531:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73529
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73522
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73520
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73521

lab73520:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73521:

lab73522:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73525
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73523
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73524

lab73523:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73524:

lab73525:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73528
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73526
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73527

lab73526:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73527:

lab73528:
    jmp lab73530

lab73529:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73530:

lab73532:
    ; #load tag
    mov rdi, 0
    ; let x7: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x6 !-> x6)(x7 !-> x7)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a2 Node
    jmp r9

Bool_73510_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73537
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab73533
    ; ####increment refcount
    add qword [rax + 0], 1

lab73533:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab73534
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73534:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab73535
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73535:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab73536
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73536:
    jmp lab73538

lab73537:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab73538:
    ; substitute (a2 !-> a2)(chs !-> chs)(a !-> a)(cs_ !-> cs_);
    ; #move variables
    mov rcx, r10
    mov r10, r8
    mov r8, rcx
    mov rcx, r11
    mov r11, r9
    mov r9, rcx
    ; let x8: Pair[List[Assign], ConflictSet] = Tup(a, cs_);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73550
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73551

lab73550:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73548
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73541
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73539
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73540

lab73539:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73540:

lab73541:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73544
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73542
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73543

lab73542:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73543:

lab73544:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73547
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73545
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73546

lab73545:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73546:

lab73547:
    jmp lab73549

lab73548:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73549:

lab73551:
    ; #load tag
    mov r9, 0
    ; substitute (x8 !-> x8)(chs !-> chs)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a2 Node
    jmp r9

bj_label_:
    ; substitute (a0 !-> a0)(n !-> n);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch n \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_Pair_List_Assign_ConflictSet_73552:

Node_Pair_List_Assign_ConflictSet_73552_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab73555
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab73553
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73553:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab73554
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73554:
    jmp lab73556

lab73555:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab73556:
    ; substitute (a0 !-> a0)(l !-> l);
    ; #erase cs
    cmp r8, 0
    je lab73559
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab73557
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab73558

lab73557:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab73558:

lab73559:
    ; switch l \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_List_Assign_ConflictSet_73560:

Pair_List_Assign_ConflictSet_73560_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab73563
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab73561
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73561:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab73562
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73562:
    jmp lab73564

lab73563:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab73564:
    ; substitute (a1 !-> a1)(b0 !-> b0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Tup
    jmp r9

bj_map_:
    ; substitute (f !-> f)(a0 !-> a0)(l !-> l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_73565]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_73565:
    jmp near List_Node_Pair_List_Assign_ConflictSet_73565_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_73565_Cons

List_Node_Pair_List_Assign_ConflictSet_73565_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab73568
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab73566
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab73567

lab73566:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab73567:

lab73568:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_73565_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73571
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73569
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73569:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab73570
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73570:
    jmp lab73572

lab73571:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab73572:
    ; substitute (f0 !-> f)(n !-> n)(a0 !-> a0)(ns !-> ns)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab73573
    ; ####increment refcount
    add qword [rax + 0], 1

lab73573:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Pair[List[Assign], ConflictSet] = (a0, ns, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73585
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73586

lab73585:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73583
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73576
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73574
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73575

lab73574:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73575:

lab73576:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73579
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73577
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73578

lab73577:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73578:

lab73579:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73582
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73580
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73581

lab73580:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73581:

lab73582:
    jmp lab73584

lab73583:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73584:

lab73586:
    ; #load tag
    lea r9, [rel Pair_List_Assign_ConflictSet_73587]
    ; substitute (n !-> n)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Pair_List_Assign_ConflictSet_73587:

Pair_List_Assign_ConflictSet_73587_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73591
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab73588
    ; ####increment refcount
    add qword [r12 + 0], 1

lab73588:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab73589
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73589:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab73590
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73590:
    jmp lab73592

lab73591:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab73592:
    ; substitute (f !-> f)(ns !-> ns)(a0 !-> a0)(a4 !-> a4)(b0 !-> b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a4, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73604
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73605

lab73604:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73602
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73595
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73593
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73594

lab73593:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73594:

lab73595:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73598
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73596
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73597

lab73596:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73597:

lab73598:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73601
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73599
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73600

lab73599:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73600:

lab73601:
    jmp lab73603

lab73602:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73603:

lab73605:
    ; #load tag
    mov r11, 0
    ; new a2: List[Pair[List[Assign], ConflictSet]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73617
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73618

lab73617:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73615
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73608
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73606
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73607

lab73606:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73607:

lab73608:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73611
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73609
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73610

lab73609:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73610:

lab73611:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73614
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73612
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73613

lab73612:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73613:

lab73614:
    jmp lab73616

lab73615:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73616:

lab73618:
    ; #load tag
    lea r9, [rel List_Pair_List_Assign_ConflictSet_73619]
    ; jump bj_map_
    jmp bj_map_

List_Pair_List_Assign_ConflictSet_73619:
    jmp near List_Pair_List_Assign_ConflictSet_73619_Nil
    jmp near List_Pair_List_Assign_ConflictSet_73619_Cons

List_Pair_List_Assign_ConflictSet_73619_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73622
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab73620
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73620:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab73621
    ; ####increment refcount
    add qword [rax + 0], 1

lab73621:
    jmp lab73623

lab73622:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab73623:
    ; let x1: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Pair_List_Assign_ConflictSet_73619_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73626
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73624
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73624:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab73625
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73625:
    jmp lab73627

lab73626:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab73627:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Pair[List[Assign], ConflictSet]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73639
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73640

lab73639:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73637
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73630
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73628
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73629

lab73628:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73629:

lab73630:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73633
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73631
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73632

lab73631:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73632:

lab73633:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73636
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73634
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73635

lab73634:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73635:

lab73636:
    jmp lab73638

lab73637:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73638:

lab73640:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bj_map2_:
    ; substitute (f !-> f)(a0 !-> a0)(l !-> l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Node_Pair_List_Assign_ConflictSet_73641]
    add rcx, r9
    jmp rcx

List_Node_Pair_List_Assign_ConflictSet_73641:
    jmp near List_Node_Pair_List_Assign_ConflictSet_73641_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_73641_Cons

List_Node_Pair_List_Assign_ConflictSet_73641_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab73644
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab73642
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab73643

lab73642:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab73643:

lab73644:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_List_Assign_ConflictSet_73641_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73647
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73645
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73645:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab73646
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73646:
    jmp lab73648

lab73647:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab73648:
    ; substitute (f0 !-> f)(n !-> n)(a0 !-> a0)(ns !-> ns)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab73649
    ; ####increment refcount
    add qword [rax + 0], 1

lab73649:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ns, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73661
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73662

lab73661:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73659
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73652
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73650
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73651

lab73650:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73651:

lab73652:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73655
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73653
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73654

lab73653:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73654:

lab73655:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73658
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73656
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73657

lab73656:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73657:

lab73658:
    jmp lab73660

lab73659:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73660:

lab73662:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_73663]
    ; substitute (n !-> n)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Node_Pair_List_Assign_ConflictSet_73663:

Node_Pair_List_Assign_ConflictSet_73663_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73667
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab73664
    ; ####increment refcount
    add qword [r12 + 0], 1

lab73664:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab73665
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73665:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab73666
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73666:
    jmp lab73668

lab73667:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab73668:
    ; substitute (f !-> f)(ns !-> ns)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73680
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73681

lab73680:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73678
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73671
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73669
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73670

lab73669:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73670:

lab73671:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73674
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73672
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73673

lab73672:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73673:

lab73674:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73677
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73675
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73676

lab73675:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73676:

lab73677:
    jmp lab73679

lab73678:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73679:

lab73681:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73693
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73694

lab73693:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73691
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73684
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73682
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73683

lab73682:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73683:

lab73684:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73687
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73685
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73686

lab73685:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73686:

lab73687:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73690
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73688
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73689

lab73688:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73689:

lab73690:
    jmp lab73692

lab73691:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73692:

lab73694:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_73695]
    ; jump bj_map2_
    jmp bj_map2_

List_Node_Pair_List_Assign_ConflictSet_73695:
    jmp near List_Node_Pair_List_Assign_ConflictSet_73695_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_73695_Cons

List_Node_Pair_List_Assign_ConflictSet_73695_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73698
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab73696
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73696:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab73697
    ; ####increment refcount
    add qword [rax + 0], 1

lab73697:
    jmp lab73699

lab73698:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab73699:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_73695_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73702
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73700
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73700:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab73701
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73701:
    jmp lab73703

lab73702:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab73703:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73715
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73716

lab73715:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73713
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73706
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73704
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73705

lab73704:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73705:

lab73706:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73709
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73707
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73708

lab73707:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73708:

lab73709:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73712
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73710
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73711

lab73710:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73711:

lab73712:
    jmp lab73714

lab73713:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73714:

lab73716:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

bj_fold_tree_:
    ; substitute (f !-> f)(a0 !-> a0)(t !-> t);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch t \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_Pair_List_Assign_ConflictSet_73717:

Node_Pair_List_Assign_ConflictSet_73717_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73720
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73718
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73718:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab73719
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73719:
    jmp lab73721

lab73720:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab73721:
    ; substitute (f0 !-> f)(c !-> c)(l !-> l)(a0 !-> a0)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab73722
    ; ####increment refcount
    add qword [rax + 0], 1

lab73722:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; new a1: List[Node[Pair[List[Assign], ConflictSet]]] = (l, a0, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73734
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73735

lab73734:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73732
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73725
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73723
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73724

lab73723:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73724:

lab73725:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73728
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73726
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73727

lab73726:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73727:

lab73728:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73731
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73729
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73730

lab73729:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73730:

lab73731:
    jmp lab73733

lab73732:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73733:

lab73735:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_73736]
    ; substitute (a1 !-> a1)(c !-> c)(f0 !-> f0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new x1: Fun[Node[Pair[List[Assign], ConflictSet]], Node[Pair[List[Assign], ConflictSet]]] = (f0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73748
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73749

lab73748:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73746
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73739
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73737
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73738

lab73737:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73738:

lab73739:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73742
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73740
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73741

lab73740:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73741:

lab73742:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73745
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73743
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73744

lab73743:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73744:

lab73745:
    jmp lab73747

lab73746:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73747:

lab73749:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_73750]
    ; substitute (x1 !-> x1)(c !-> c)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bj_map2_
    jmp bj_map2_

Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_73750:

Fun_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_73750_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73752
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab73751
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73751:
    jmp lab73753

lab73752:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab73753:
    ; substitute (f0 !-> f0)(x !-> x)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bj_fold_tree_
    jmp bj_fold_tree_

List_Node_Pair_List_Assign_ConflictSet_73736:
    jmp near List_Node_Pair_List_Assign_ConflictSet_73736_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_73736_Cons

List_Node_Pair_List_Assign_ConflictSet_73736_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73757
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab73754
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73754:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab73755
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73755:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab73756
    ; ####increment refcount
    add qword [rax + 0], 1

lab73756:
    jmp lab73758

lab73757:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab73758:
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 !-> a0)(f !-> f)(l !-> l)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_bj_fold_tree_0_
    jmp lift_bj_fold_tree_0_

List_Node_Pair_List_Assign_ConflictSet_73736_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73762
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab73759
    ; ####increment refcount
    add qword [r12 + 0], 1

lab73759:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab73760
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73760:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab73761
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73761:
    jmp lab73763

lab73762:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab73763:
    ; substitute (f !-> f)(a0 !-> a0)(l !-> l)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73775
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73776

lab73775:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73773
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73766
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73764
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73765

lab73764:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73765:

lab73766:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73769
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73767
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73768

lab73767:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73768:

lab73769:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73772
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73770
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73771

lab73770:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73771:

lab73772:
    jmp lab73774

lab73773:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73774:

lab73776:
    ; #load tag
    mov r11, 5
    ; substitute (a0 !-> a0)(f !-> f)(l !-> l)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_bj_fold_tree_0_
    jmp lift_bj_fold_tree_0_

lift_bj_fold_tree_0_:
    ; substitute (l !-> l)(f !-> f)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, r11
    mov r11, rdx
    mov rdx, rcx
    ; let a3: Fun[List[Node[Pair[List[Assign], ConflictSet]]], Node[Pair[List[Assign], ConflictSet]]] = Ap(x0, a0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73788
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73789

lab73788:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73786
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73779
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73777
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73778

lab73777:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73778:

lab73779:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73782
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73780
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73781

lab73780:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73781:

lab73782:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73785
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73783
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73784

lab73783:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73784:

lab73785:
    jmp lab73787

lab73786:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73787:

lab73789:
    ; #load tag
    mov r9, 0
    ; substitute (l !-> l)(a3 !-> a3)(f !-> f);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke f Ap
    jmp r9

bj_:
    ; substitute (a0 !-> a0)(t !-> t);
    ; #erase csp
    cmp rax, 0
    je lab73792
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab73790
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab73791

lab73790:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab73791:

lab73792:
    ; #move variables
    mov rax, r8
    mov rdx, r9
    ; new f6: Fun[Pair[List[Assign], ConflictSet], Fun[List[Node[Pair[List[Assign], ConflictSet]]], Node[Pair[List[Assign], ConflictSet]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Pair_List_Assign_ConflictSet_Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_73793]
    ; substitute (f6 !-> f6)(t !-> t)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump bj_fold_tree_
    jmp bj_fold_tree_

Fun_Pair_List_Assign_ConflictSet_Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_73793:

Fun_Pair_List_Assign_ConflictSet_Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_73793_Ap:
    ; switch a1 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_73794:

Fun_List_Node_Pair_List_Assign_ConflictSet_Node_Pair_List_Assign_ConflictSet_73794_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab73797
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab73795
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73795:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab73796
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73796:
    jmp lab73798

lab73797:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab73798:
    ; substitute (a2 !-> a2)(chs !-> chs)(tp2 !-> tp2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch tp2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_List_Assign_ConflictSet_73799:

Pair_List_Assign_ConflictSet_73799_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73802
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73800
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73800:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab73801
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73801:
    jmp lab73803

lab73802:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab73803:
    ; switch conf \{ ... \};
    lea rcx, [rel ConflictSet_73804]
    add rcx, r11
    jmp rcx

ConflictSet_73804:
    jmp near ConflictSet_73804_Known
    jmp near ConflictSet_73804_Unknown

ConflictSet_73804_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab73806
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]
    cmp r10, 0
    je lab73805
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73805:
    jmp lab73807

lab73806:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r11, [r10 + 56]
    mov r10, [r10 + 48]

lab73807:
    ; let x1: ConflictSet = Known(cs);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73819
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73820

lab73819:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73817
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73810
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73808
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73809

lab73808:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73809:

lab73810:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73813
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73811
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73812

lab73811:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73812:

lab73813:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73816
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73814
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73815

lab73814:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73815:

lab73816:
    jmp lab73818

lab73817:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73818:

lab73820:
    ; #load tag
    mov r11, 0
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a, x1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73832
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73833

lab73832:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73830
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73823
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73821
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73822

lab73821:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73822:

lab73823:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73826
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73824
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73825

lab73824:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73825:

lab73826:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73829
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73827
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73828

lab73827:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73828:

lab73829:
    jmp lab73831

lab73830:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73831:

lab73833:
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(chs !-> chs)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a2 Node
    jmp r9

ConflictSet_73804_Unknown:
    ; substitute (chs0 !-> chs)(chs !-> chs)(a !-> a)(a2 !-> a2);
    ; #share chs
    cmp rsi, 0
    je lab73834
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73834:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    mov rax, rsi
    mov rdx, rdi
    ; new a3: List[i64] = (chs, a, a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73846
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab73847

lab73846:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73844
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73837
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73835
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73836

lab73835:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73836:

lab73837:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73840
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73838
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73839

lab73838:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73839:

lab73840:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73843
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73841
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73842

lab73841:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73842:

lab73843:
    jmp lab73845

lab73844:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73845:

lab73847:
    ; #load tag
    lea rdi, [rel List_i64_73848]
    ; new a4: List[Pair[List[Assign], ConflictSet]] = (a3)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73860
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab73861

lab73860:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73858
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73851
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73849
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73850

lab73849:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73850:

lab73851:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73854
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73852
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73853

lab73852:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73853:

lab73854:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73857
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73855
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73856

lab73855:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73856:

lab73857:
    jmp lab73859

lab73858:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73859:

lab73861:
    ; #load tag
    lea rdi, [rel List_Pair_List_Assign_ConflictSet_73862]
    ; new x6: Fun[Node[Pair[List[Assign], ConflictSet]], Pair[List[Assign], ConflictSet]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_73863]
    ; substitute (x6 !-> x6)(chs0 !-> chs0)(a4 !-> a4);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump bj_map_
    jmp bj_map_

Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_73863:

Fun_Node_Pair_List_Assign_ConflictSet_Pair_List_Assign_ConflictSet_73863_Ap:
    ; jump bj_label_
    jmp bj_label_

List_Pair_List_Assign_ConflictSet_73862:
    jmp near List_Pair_List_Assign_ConflictSet_73862_Nil
    jmp near List_Pair_List_Assign_ConflictSet_73862_Cons

List_Pair_List_Assign_ConflictSet_73862_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73865
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab73864
    ; ####increment refcount
    add qword [rax + 0], 1

lab73864:
    jmp lab73866

lab73865:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab73866:
    ; let x5: List[Pair[List[Assign], ConflictSet]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; jump lift_bj_1_
    jmp lift_bj_1_

List_Pair_List_Assign_ConflictSet_73862_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73868
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab73867
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73867:
    jmp lab73869

lab73868:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab73869:
    ; substitute (a3 !-> a3)(a7 !-> a7)(as1 !-> as1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x5: List[Pair[List[Assign], ConflictSet]] = Cons(a7, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73881
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab73882

lab73881:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73879
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73872
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73870
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73871

lab73870:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73871:

lab73872:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73875
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73873
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73874

lab73873:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73874:

lab73875:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73878
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73876
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73877

lab73876:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73877:

lab73878:
    jmp lab73880

lab73879:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73880:

lab73882:
    ; #load tag
    mov rdi, 5
    ; jump lift_bj_1_
    jmp lift_bj_1_

List_i64_73848:
    jmp near List_i64_73848_Nil
    jmp near List_i64_73848_Cons

List_i64_73848_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab73886
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab73883
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73883:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab73884
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73884:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab73885
    ; ####increment refcount
    add qword [rax + 0], 1

lab73885:
    jmp lab73887

lab73886:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab73887:
    ; let x4: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a !-> a)(a2 !-> a2)(chs !-> chs)(x4 !-> x4);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_bj_0_
    jmp lift_bj_0_

List_i64_73848_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73891
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab73888
    ; ####increment refcount
    add qword [r12 + 0], 1

lab73888:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab73889
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73889:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab73890
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73890:
    jmp lab73892

lab73891:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab73892:
    ; substitute (a2 !-> a2)(a !-> a)(chs !-> chs)(a6 !-> a6)(as0 !-> as0);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov rax, r12
    mov r12, rsi
    mov rsi, r10
    ; let x4: List[i64] = Cons(a6, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73904
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73905

lab73904:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73902
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73895
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73893
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73894

lab73893:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73894:

lab73895:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73898
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73896
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73897

lab73896:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73897:

lab73898:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73901
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73899
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73900

lab73899:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73900:

lab73901:
    jmp lab73903

lab73902:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73903:

lab73905:
    ; #load tag
    mov r11, 5
    ; substitute (a !-> a)(a2 !-> a2)(chs !-> chs)(x4 !-> x4);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_bj_0_
    jmp lift_bj_0_

lift_bj_1_:
    ; let x7: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x5 !-> x5)(x7 !-> x7)(a3 !-> a3);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump combine_
    jmp combine_

lift_bj_0_:
    ; let x3: ConflictSet = Known(x4);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73917
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab73918

lab73917:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73915
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73908
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73906
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73907

lab73906:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73907:

lab73908:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73911
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73909
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73910

lab73909:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73910:

lab73911:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73914
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73912
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73913

lab73912:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73913:

lab73914:
    jmp lab73916

lab73915:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73916:

lab73918:
    ; #load tag
    mov r11, 0
    ; substitute (chs !-> chs)(a2 !-> a2)(a !-> a)(x3 !-> x3);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x2: Pair[List[Assign], ConflictSet] = Tup(a, x3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73930
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73931

lab73930:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73928
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73921
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73919
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73920

lab73919:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73920:

lab73921:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73924
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73922
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73923

lab73922:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73923:

lab73924:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73927
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73925
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73926

lab73925:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73926:

lab73927:
    jmp lab73929

lab73928:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73929:

lab73931:
    ; #load tag
    mov r9, 0
    ; substitute (x2 !-> x2)(chs !-> chs)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a2 Node
    jmp r9

bjbt_:
    ; substitute (csp0 !-> csp)(t !-> t)(a0 !-> a0)(csp !-> csp);
    ; #share csp
    cmp rax, 0
    je lab73932
    ; ####increment refcount
    add qword [rax + 0], 1

lab73932:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; new a1: Node[Pair[List[Assign], ConflictSet]] = (a0, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73944
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73945

lab73944:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73942
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73935
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73933
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73934

lab73933:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73934:

lab73935:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73938
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73936
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73937

lab73936:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73937:

lab73938:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73941
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73939
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73940

lab73939:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73940:

lab73941:
    jmp lab73943

lab73942:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73943:

lab73945:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_73946]
    ; jump bt_
    jmp bt_

Node_Pair_List_Assign_ConflictSet_73946:

Node_Pair_List_Assign_ConflictSet_73946_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73949
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73947
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73947:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab73948
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73948:
    jmp lab73950

lab73949:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab73950:
    ; substitute (csp !-> csp)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73962
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73963

lab73962:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73960
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73953
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73951
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73952

lab73951:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73952:

lab73953:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73956
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73954
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73955

lab73954:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73955:

lab73956:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73959
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73957
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73958

lab73957:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73958:

lab73959:
    jmp lab73961

lab73960:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73961:

lab73963:
    ; #load tag
    mov r9, 0
    ; substitute (csp !-> csp)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump bj_
    jmp bj_

bjbt__:
    ; substitute (csp0 !-> csp)(t !-> t)(a0 !-> a0)(csp !-> csp);
    ; #share csp
    cmp rax, 0
    je lab73964
    ; ####increment refcount
    add qword [rax + 0], 1

lab73964:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; new a1: Node[Pair[List[Assign], ConflictSet]] = (a0, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73976
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73977

lab73976:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73974
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73967
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73965
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73966

lab73965:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73966:

lab73967:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73970
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73968
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73969

lab73968:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73969:

lab73970:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73973
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73971
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73972

lab73971:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73972:

lab73973:
    jmp lab73975

lab73974:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73975:

lab73977:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_73978]
    ; jump bt_
    jmp bt_

Node_Pair_List_Assign_ConflictSet_73978:

Node_Pair_List_Assign_ConflictSet_73978_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab73981
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab73979
    ; ####increment refcount
    add qword [r10 + 0], 1

lab73979:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab73980
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73980:
    jmp lab73982

lab73981:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab73982:
    ; substitute (csp !-> csp)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab73994
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab73995

lab73994:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab73992
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab73985
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73983
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73984

lab73983:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73984:

lab73985:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab73988
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73986
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73987

lab73986:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73987:

lab73988:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab73991
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab73989
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab73990

lab73989:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab73990:

lab73991:
    jmp lab73993

lab73992:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab73993:

lab73995:
    ; #load tag
    mov r9, 0
    ; substitute (csp !-> csp)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump bj__
    jmp bj__

collect_:
    ; substitute (a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_ConflictSet_73996]
    add rcx, rdi
    jmp rcx

List_ConflictSet_73996:
    jmp near List_ConflictSet_73996_Nil
    jmp near List_ConflictSet_73996_Cons

List_ConflictSet_73996_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_ConflictSet_73996_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab73999
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab73997
    ; ####increment refcount
    add qword [r8 + 0], 1

lab73997:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab73998
    ; ####increment refcount
    add qword [rsi + 0], 1

lab73998:
    jmp lab74000

lab73999:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab74000:
    ; substitute (a0 !-> a0)(css !-> css)(conf !-> conf);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch conf \{ ... \};
    lea rcx, [rel ConflictSet_74001]
    add rcx, r9
    jmp rcx

ConflictSet_74001:
    jmp near ConflictSet_74001_Known
    jmp near ConflictSet_74001_Unknown

ConflictSet_74001_Known:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74003
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab74002
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74002:
    jmp lab74004

lab74003:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab74004:
    ; substitute (css !-> css)(a0 !-> a0)(cs !-> cs);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; new a1: List[i64] = (a0, cs)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74016
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74017

lab74016:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74014
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74007
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74005
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74006

lab74005:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74006:

lab74007:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74010
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74008
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74009

lab74008:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74009:

lab74010:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74013
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74011
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74012

lab74011:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74012:

lab74013:
    jmp lab74015

lab74014:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74015:

lab74017:
    ; #load tag
    lea rdi, [rel List_i64_74018]
    ; jump collect_
    jmp collect_

List_i64_74018:
    jmp near List_i64_74018_Nil
    jmp near List_i64_74018_Cons

List_i64_74018_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74021
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab74019
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74019:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab74020
    ; ####increment refcount
    add qword [rax + 0], 1

lab74020:
    jmp lab74022

lab74021:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab74022:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (cs !-> cs)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump union_
    jmp union_

List_i64_74018_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74025
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab74023
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74023:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab74024
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74024:
    jmp lab74026

lab74025:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab74026:
    ; substitute (cs !-> cs)(a0 !-> a0)(a2 !-> a2)(as0 !-> as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x0: List[i64] = Cons(a2, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74038
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74039

lab74038:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74036
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74029
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74027
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74028

lab74027:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74028:

lab74029:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74032
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74030
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74031

lab74030:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74031:

lab74032:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74035
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74033
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74034

lab74033:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74034:

lab74035:
    jmp lab74037

lab74036:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74037:

lab74039:
    ; #load tag
    mov r9, 5
    ; substitute (cs !-> cs)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump union_
    jmp union_

ConflictSet_74001_Unknown:
    ; substitute (a0 !-> a0);
    ; #erase css
    cmp rsi, 0
    je lab74042
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab74040
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab74041

lab74040:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab74041:

lab74042:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

wipe_all_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_ConflictSet_74043]
    add rcx, r9
    jmp rcx

List_ConflictSet_74043:
    jmp near List_ConflictSet_74043_Nil
    jmp near List_ConflictSet_74043_Cons

List_ConflictSet_74043_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab74046
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab74044
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab74045

lab74044:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab74045:

lab74046:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 True
    add rdx, 0
    jmp rdx

List_ConflictSet_74043_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74049
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab74047
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74047:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab74048
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74048:
    jmp lab74050

lab74049:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab74050:
    ; substitute (f0 !-> f)(c !-> c)(a0 !-> a0)(cs !-> cs)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab74051
    ; ####increment refcount
    add qword [rax + 0], 1

lab74051:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Bool = (a0, cs, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74063
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74064

lab74063:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74061
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74054
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74052
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74053

lab74052:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74053:

lab74054:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74057
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74055
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74056

lab74055:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74056:

lab74057:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74060
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74058
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74059

lab74058:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74059:

lab74060:
    jmp lab74062

lab74061:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74062:

lab74064:
    ; #load tag
    lea r9, [rel Bool_74065]
    ; substitute (c !-> c)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Bool_74065:
    jmp near Bool_74065_True
    jmp near Bool_74065_False

Bool_74065_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74069
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab74066
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74066:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab74067
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74067:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab74068
    ; ####increment refcount
    add qword [rax + 0], 1

lab74068:
    jmp lab74070

lab74069:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab74070:
    ; substitute (f !-> f)(cs !-> cs)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump wipe_all_
    jmp wipe_all_

Bool_74065_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74074
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab74071
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74071:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab74072
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74072:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab74073
    ; ####increment refcount
    add qword [rax + 0], 1

lab74073:
    jmp lab74075

lab74074:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab74075:
    ; substitute (a0 !-> a0);
    ; #erase cs
    cmp rsi, 0
    je lab74078
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab74076
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab74077

lab74076:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab74077:

lab74078:
    ; #erase f
    cmp r8, 0
    je lab74081
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab74079
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab74080

lab74079:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab74080:

lab74081:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

wipe_lscomp1_:
    ; substitute (a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_ConflictSet_74082]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_74082:
    jmp near List_List_ConflictSet_74082_Nil
    jmp near List_List_ConflictSet_74082_Cons

List_List_ConflictSet_74082_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_74082_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74085
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab74083
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74083:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab74084
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74084:
    jmp lab74086

lab74085:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab74086:
    ; new x0: Fun[ConflictSet, Bool] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_ConflictSet_Bool_74087]
    ; substitute (x0 !-> x0)(vs0 !-> vs)(t1 !-> t1)(vs !-> vs)(a0 !-> a0);
    ; #share vs
    cmp rsi, 0
    je lab74088
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74088:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rax, r10
    mov r10, rsi
    mov rdx, r11
    mov r11, rdi
    ; new a3: Bool = (t1, vs, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74100
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74101

lab74100:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74098
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74091
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74089
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74090

lab74089:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74090:

lab74091:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74094
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74092
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74093

lab74092:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74093:

lab74094:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74097
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74095
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74096

lab74095:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74096:

lab74097:
    jmp lab74099

lab74098:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74099:

lab74101:
    ; #load tag
    lea r9, [rel Bool_74102]
    ; jump wipe_all_
    jmp wipe_all_

Bool_74102:
    jmp near Bool_74102_True
    jmp near Bool_74102_False

Bool_74102_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74106
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab74103
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74103:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab74104
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74104:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab74105
    ; ####increment refcount
    add qword [rax + 0], 1

lab74105:
    jmp lab74107

lab74106:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab74107:
    ; new a1: List[List[ConflictSet]] = (vs, a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74119
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74120

lab74119:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74117
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74110
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74108
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74109

lab74108:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74109:

lab74110:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74113
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74111
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74112

lab74111:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74112:

lab74113:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74116
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74114
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74115

lab74114:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74115:

lab74116:
    jmp lab74118

lab74117:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74118:

lab74120:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_74121]
    ; jump wipe_lscomp1_
    jmp wipe_lscomp1_

List_List_ConflictSet_74121:
    jmp near List_List_ConflictSet_74121_Nil
    jmp near List_List_ConflictSet_74121_Cons

List_List_ConflictSet_74121_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74124
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab74122
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74122:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab74123
    ; ####increment refcount
    add qword [rax + 0], 1

lab74123:
    jmp lab74125

lab74124:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab74125:
    ; let x1: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (vs !-> vs)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_List_ConflictSet_74121_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74128
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab74126
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74126:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab74127
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74127:
    jmp lab74129

lab74128:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab74129:
    ; substitute (a0 !-> a0)(vs !-> vs)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[List[ConflictSet]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74141
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74142

lab74141:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74139
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74132
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74130
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74131

lab74130:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74131:

lab74132:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74135
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74133
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74134

lab74133:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74134:

lab74135:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74138
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74136
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74137

lab74136:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74137:

lab74138:
    jmp lab74140

lab74139:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74140:

lab74142:
    ; #load tag
    mov r9, 5
    ; substitute (vs !-> vs)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

Bool_74102_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74146
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab74143
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74143:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab74144
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74144:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab74145
    ; ####increment refcount
    add qword [rax + 0], 1

lab74145:
    jmp lab74147

lab74146:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab74147:
    ; substitute (t1 !-> t1)(a0 !-> a0);
    ; #erase vs
    cmp rsi, 0
    je lab74150
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab74148
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab74149

lab74148:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab74149:

lab74150:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; jump wipe_lscomp1_
    jmp wipe_lscomp1_

Fun_ConflictSet_Bool_74087:

Fun_ConflictSet_Bool_74087_Ap:
    ; jump known_conflict_
    jmp known_conflict_

wipe_null__:
    ; substitute (a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_ConflictSet_74151]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_74151:
    jmp near List_List_ConflictSet_74151_Nil
    jmp near List_List_ConflictSet_74151_Cons

List_List_ConflictSet_74151_Nil:
    ; invoke a0 True
    add rdx, 0
    jmp rdx

List_List_ConflictSet_74151_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74154
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab74152
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74152:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab74153
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74153:
    jmp lab74155

lab74154:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab74155:
    ; substitute (a0 !-> a0);
    ; #erase l
    cmp rsi, 0
    je lab74158
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab74156
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab74157

lab74156:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab74157:

lab74158:
    ; #erase ls0
    cmp r8, 0
    je lab74161
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab74159
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab74160

lab74159:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab74160:

lab74161:
    ; invoke a0 False
    add rdx, 5
    jmp rdx

wipe_head_:
    ; substitute (a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_List_ConflictSet_74162]
    add rcx, rdi
    jmp rcx

List_List_ConflictSet_74162:
    jmp near List_List_ConflictSet_74162_Nil
    jmp near List_List_ConflictSet_74162_Cons

List_List_ConflictSet_74162_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_List_ConflictSet_74162_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74165
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab74163
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74163:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab74164
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74164:
    jmp lab74166

lab74165:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab74166:
    ; substitute (a0 !-> a0)(l !-> l);
    ; #erase ls0
    cmp r8, 0
    je lab74169
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab74167
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab74168

lab74167:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab74168:

lab74169:
    ; switch l \{ ... \};
    lea rcx, [rel List_ConflictSet_74170]
    add rcx, rdi
    jmp rcx

List_ConflictSet_74170:
    jmp near List_ConflictSet_74170_Nil
    jmp near List_ConflictSet_74170_Cons

List_ConflictSet_74170_Nil:
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_ConflictSet_74170_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74173
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab74171
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74171:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab74172
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74172:
    jmp lab74174

lab74173:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab74174:
    ; substitute (a1 !-> a1)(as0 !-> as0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

wipe_map_:
    ; substitute (f !-> f)(a0 !-> a0)(ls !-> ls);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch ls \{ ... \};
    lea rcx, [rel List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_74175]
    add rcx, r9
    jmp rcx

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_74175:
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_74175_Nil
    jmp near List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_74175_Cons

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_74175_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab74178
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab74176
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab74177

lab74176:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab74177:

lab74178:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_74175_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74181
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab74179
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74179:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab74180
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74180:
    jmp lab74182

lab74181:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab74182:
    ; substitute (f0 !-> f)(n !-> n)(a0 !-> a0)(ns !-> ns)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab74183
    ; ####increment refcount
    add qword [rax + 0], 1

lab74183:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Node[Pair[List[Assign], ConflictSet]] = (a0, ns, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74195
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74196

lab74195:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74193
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74186
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74184
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74185

lab74184:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74185:

lab74186:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74189
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74187
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74188

lab74187:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74188:

lab74189:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74192
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74190
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74191

lab74190:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74191:

lab74192:
    jmp lab74194

lab74193:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74194:

lab74196:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_ConflictSet_74197]
    ; substitute (n !-> n)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Node_Pair_List_Assign_ConflictSet_74197:

Node_Pair_List_Assign_ConflictSet_74197_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74201
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab74198
    ; ####increment refcount
    add qword [r12 + 0], 1

lab74198:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab74199
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74199:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab74200
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74200:
    jmp lab74202

lab74201:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab74202:
    ; substitute (f !-> f)(ns !-> ns)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[List[Assign], ConflictSet]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74214
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab74215

lab74214:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74212
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74205
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74203
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74204

lab74203:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74204:

lab74205:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74208
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74206
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74207

lab74206:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74207:

lab74208:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74211
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74209
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74210

lab74209:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74210:

lab74211:
    jmp lab74213

lab74212:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74213:

lab74215:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74227
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74228

lab74227:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74225
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74218
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74216
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74217

lab74216:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74217:

lab74218:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74221
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74219
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74220

lab74219:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74220:

lab74221:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74224
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74222
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74223

lab74222:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74223:

lab74224:
    jmp lab74226

lab74225:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74226:

lab74228:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_74229]
    ; jump wipe_map_
    jmp wipe_map_

List_Node_Pair_List_Assign_ConflictSet_74229:
    jmp near List_Node_Pair_List_Assign_ConflictSet_74229_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_74229_Cons

List_Node_Pair_List_Assign_ConflictSet_74229_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74232
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab74230
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74230:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab74231
    ; ####increment refcount
    add qword [rax + 0], 1

lab74231:
    jmp lab74233

lab74232:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab74233:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_74229_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74236
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab74234
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74234:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab74235
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74235:
    jmp lab74237

lab74236:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab74237:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74249
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74250

lab74249:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74247
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74240
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74238
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74239

lab74238:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74239:

lab74240:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74243
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74241
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74242

lab74241:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74242:

lab74243:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74246
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74244
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74245

lab74244:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74245:

lab74246:
    jmp lab74248

lab74247:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74248:

lab74250:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

wipe_map_tree_:
    ; substitute (f !-> f)(a0 !-> a0)(t !-> t);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch t \{ ... \};
    ; #if there is only one clause, we can just fall through

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_74251:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_74251_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74254
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab74252
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74252:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab74253
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74253:
    jmp lab74255

lab74254:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab74255:
    ; substitute (f0 !-> f)(l !-> l)(a0 !-> a0)(c !-> c)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab74256
    ; ####increment refcount
    add qword [rax + 0], 1

lab74256:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: Pair[List[Assign], ConflictSet] = (a0, c, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74268
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74269

lab74268:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74266
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74259
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74257
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74258

lab74257:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74258:

lab74259:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74262
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74260
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74261

lab74260:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74261:

lab74262:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74265
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74263
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74264

lab74263:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74264:

lab74265:
    jmp lab74267

lab74266:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74267:

lab74269:
    ; #load tag
    lea r9, [rel Pair_List_Assign_ConflictSet_74270]
    ; substitute (l !-> l)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

Pair_List_Assign_ConflictSet_74270:

Pair_List_Assign_ConflictSet_74270_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74274
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab74271
    ; ####increment refcount
    add qword [r12 + 0], 1

lab74271:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab74272
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74272:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab74273
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74273:
    jmp lab74275

lab74274:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab74275:
    ; substitute (f !-> f)(c !-> c)(a0 !-> a0)(a5 !-> a5)(b0 !-> b0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x0: Pair[List[Assign], ConflictSet] = Tup(a5, b0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74287
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab74288

lab74287:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74285
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74278
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74276
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74277

lab74276:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74277:

lab74278:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74281
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74279
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74280

lab74279:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74280:

lab74281:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74284
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74282
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74283

lab74282:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74283:

lab74284:
    jmp lab74286

lab74285:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74286:

lab74288:
    ; #load tag
    mov r11, 0
    ; new a2: List[Node[Pair[List[Assign], ConflictSet]]] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74300
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74301

lab74300:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74298
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74291
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74289
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74290

lab74289:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74290:

lab74291:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74294
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74292
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74293

lab74292:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74293:

lab74294:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74297
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74295
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74296

lab74295:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74296:

lab74297:
    jmp lab74299

lab74298:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74299:

lab74301:
    ; #load tag
    lea r9, [rel List_Node_Pair_List_Assign_ConflictSet_74302]
    ; substitute (a2 !-> a2)(c !-> c)(f !-> f);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; new x2: Fun[Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]], Node[Pair[List[Assign], ConflictSet]]] = (f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74314
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74315

lab74314:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74312
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74305
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74303
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74304

lab74303:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74304:

lab74305:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74308
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74306
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74307

lab74306:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74307:

lab74308:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74311
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74309
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74310

lab74309:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74310:

lab74311:
    jmp lab74313

lab74312:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74313:

lab74315:
    ; #load tag
    lea r9, [rel Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_74316]
    ; substitute (x2 !-> x2)(c !-> c)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump wipe_map_
    jmp wipe_map_

Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_74316:

Fun_Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Node_Pair_List_Assign_ConflictSet_74316_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74318
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab74317
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74317:
    jmp lab74319

lab74318:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab74319:
    ; substitute (f !-> f)(x !-> x)(a3 !-> a3);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump wipe_map_tree_
    jmp wipe_map_tree_

List_Node_Pair_List_Assign_ConflictSet_74302:
    jmp near List_Node_Pair_List_Assign_ConflictSet_74302_Nil
    jmp near List_Node_Pair_List_Assign_ConflictSet_74302_Cons

List_Node_Pair_List_Assign_ConflictSet_74302_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74322
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab74320
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74320:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab74321
    ; ####increment refcount
    add qword [rax + 0], 1

lab74321:
    jmp lab74323

lab74322:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab74323:
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Node
    jmp r9

List_Node_Pair_List_Assign_ConflictSet_74302_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74326
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab74324
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74324:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab74325
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74325:
    jmp lab74327

lab74326:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab74327:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: List[Node[Pair[List[Assign], ConflictSet]]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74339
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74340

lab74339:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74337
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74330
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74328
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74329

lab74328:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74329:

lab74330:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74333
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74331
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74332

lab74331:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74332:

lab74333:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74336
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74334
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74335

lab74334:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74335:

lab74336:
    jmp lab74338

lab74337:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74338:

lab74340:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Node
    jmp r9

domain_wipeout_:
    ; substitute (a0 !-> a0)(t !-> t)(csp !-> csp);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; switch csp \{ ... \};
    ; #if there is only one clause, we can just fall through

CSP_74341:

CSP_74341_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74343
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab74342
    ; ####increment refcount
    add qword [r12 + 0], 1

lab74342:
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]
    jmp lab74344

lab74343:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r9, [r8 + 24]

lab74344:
    ; substitute (a0 !-> a0)(t !-> t);
    ; #erase rel
    cmp r12, 0
    je lab74347
    ; ######check refcount
    cmp qword [r12 + 0], 0
    je lab74345
    ; ######either decrement refcount ...
    add qword [r12 + 0], -1
    jmp lab74346

lab74345:
    ; ######... or add block to lazy free list
    mov [r12 + 0], rbp
    mov rbp, r12

lab74346:

lab74347:
    ; new f8: Fun[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]], Pair[List[Assign], ConflictSet]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_74348]
    ; substitute (f8 !-> f8)(t !-> t)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump wipe_map_tree_
    jmp wipe_map_tree_

Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_74348:

Fun_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_Pair_List_Assign_ConflictSet_74348_Ap:
    ; substitute (a1 !-> a1)(tp2 !-> tp2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch tp2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_74349:

Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_74349_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74352
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab74350
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74350:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab74351
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74351:
    jmp lab74353

lab74352:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab74353:
    ; substitute (a1 !-> a1)(tbl !-> tbl)(p !-> p);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch p \{ ... \};
    ; #if there is only one clause, we can just fall through

Pair_List_Assign_ConflictSet_74354:

Pair_List_Assign_ConflictSet_74354_Tup:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74357
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab74355
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74355:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab74356
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74356:
    jmp lab74358

lab74357:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab74358:
    ; substitute (tbl !-> tbl)(a1 !-> a1)(as_ !-> as_)(cs !-> cs);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; new a4: List[List[ConflictSet]] = (a1, as_, cs)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74370
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74371

lab74370:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74368
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74361
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74359
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74360

lab74359:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74360:

lab74361:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74364
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74362
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74363

lab74362:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74363:

lab74364:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74367
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74365
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74366

lab74365:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74366:

lab74367:
    jmp lab74369

lab74368:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74369:

lab74371:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_74372]
    ; jump wipe_lscomp1_
    jmp wipe_lscomp1_

List_List_ConflictSet_74372:
    jmp near List_List_ConflictSet_74372_Nil
    jmp near List_List_ConflictSet_74372_Cons

List_List_ConflictSet_74372_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74376
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab74373
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74373:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab74374
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74374:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab74375
    ; ####increment refcount
    add qword [rax + 0], 1

lab74375:
    jmp lab74377

lab74376:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab74377:
    ; let wiped_domains: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; jump lift_domain_wipeout_0_
    jmp lift_domain_wipeout_0_

List_List_ConflictSet_74372_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74381
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab74378
    ; ####increment refcount
    add qword [r12 + 0], 1

lab74378:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab74379
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74379:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab74380
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74380:
    jmp lab74382

lab74381:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab74382:
    ; substitute (cs !-> cs)(as_ !-> as_)(a1 !-> a1)(a8 !-> a8)(as2 !-> as2);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let wiped_domains: List[List[ConflictSet]] = Cons(a8, as2);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74394
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab74395

lab74394:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74392
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74385
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74383
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74384

lab74383:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74384:

lab74385:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74388
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74386
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74387

lab74386:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74387:

lab74388:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74391
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74389
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74390

lab74389:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74390:

lab74391:
    jmp lab74393

lab74392:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74393:

lab74395:
    ; #load tag
    mov r11, 5
    ; substitute (a1 !-> a1)(as_ !-> as_)(cs !-> cs)(wiped_domains !-> wiped_domains);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump lift_domain_wipeout_0_
    jmp lift_domain_wipeout_0_

lift_domain_wipeout_0_:
    ; substitute (wiped_domains0 !-> wiped_domains)(as_ !-> as_)(cs !-> cs)(wiped_domains !-> wiped_domains)(a1 !-> a1);
    ; #share wiped_domains
    cmp r10, 0
    je lab74396
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74396:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rax, r10
    mov rdx, r11
    ; new a5: Bool = (as_, cs, wiped_domains, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74408
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74409

lab74408:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74406
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74399
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74397
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74398

lab74397:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74398:

lab74399:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74402
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74400
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74401

lab74400:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74401:

lab74402:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74405
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74403
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74404

lab74403:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74404:

lab74405:
    jmp lab74407

lab74406:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74407:

lab74409:
    ; ##store link to previous block
    mov [rbx + 48], r8
    ; ##store values
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74421
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74422

lab74421:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74419
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74412
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74410
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74411

lab74410:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74411:

lab74412:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74415
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74413
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74414

lab74413:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74414:

lab74415:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74418
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74416
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74417

lab74416:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74417:

lab74418:
    jmp lab74420

lab74419:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74420:

lab74422:
    ; #load tag
    lea rdi, [rel Bool_74423]
    ; jump wipe_null__
    jmp wipe_null__

Bool_74423:
    jmp near Bool_74423_True
    jmp near Bool_74423_False

Bool_74423_True:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74428
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab74424
    ; ####increment refcount
    add qword [rax + 0], 1

lab74424:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab74425
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74425:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab74426
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74426:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab74427
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74427:
    jmp lab74429

lab74428:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab74429:
    ; substitute (a1 !-> a1)(as_ !-> as_)(cs !-> cs);
    ; #erase wiped_domains
    cmp r8, 0
    je lab74432
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab74430
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab74431

lab74430:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab74431:

lab74432:
    ; #move variables
    mov r8, rsi
    mov rsi, rax
    mov r9, rdi
    mov rdi, rdx
    mov rax, r10
    mov rdx, r11
    ; jump share_domain_wipeout_0_
    jmp share_domain_wipeout_0_

Bool_74423_False:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74437
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab74433
    ; ####increment refcount
    add qword [rax + 0], 1

lab74433:
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab74434
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74434:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab74435
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74435:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab74436
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74436:
    jmp lab74438

lab74437:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load link to next block
    mov rsi, [rax + 48]
    ; ###load values
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab74438:
    ; substitute (wiped_domains !-> wiped_domains)(as_ !-> as_)(a1 !-> a1);
    ; #erase cs
    cmp rsi, 0
    je lab74441
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab74439
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab74440

lab74439:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab74440:

lab74441:
    ; #move variables
    mov rsi, rax
    mov rdi, rdx
    mov rax, r8
    mov rdx, r9
    mov r8, r10
    mov r9, r11
    ; new a2: List[i64] = (as_, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74453
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74454

lab74453:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74451
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74444
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74442
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74443

lab74442:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74443:

lab74444:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74447
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74445
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74446

lab74445:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74446:

lab74447:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74450
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74448
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74449

lab74448:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74449:

lab74450:
    jmp lab74452

lab74451:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74452:

lab74454:
    ; #load tag
    lea rdi, [rel List_i64_74455]
    ; new a3: List[ConflictSet] = (a2)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74467
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74468

lab74467:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74465
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74458
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74456
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74457

lab74456:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74457:

lab74458:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74461
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74459
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74460

lab74459:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74460:

lab74461:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74464
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74462
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74463

lab74462:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74463:

lab74464:
    jmp lab74466

lab74465:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74466:

lab74468:
    ; #load tag
    lea rdi, [rel List_ConflictSet_74469]
    ; jump wipe_head_
    jmp wipe_head_

List_ConflictSet_74469:
    jmp near List_ConflictSet_74469_Nil
    jmp near List_ConflictSet_74469_Cons

List_ConflictSet_74469_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74471
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab74470
    ; ####increment refcount
    add qword [rax + 0], 1

lab74470:
    jmp lab74472

lab74471:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab74472:
    ; let x1: List[ConflictSet] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x1 !-> x1)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump collect_
    jmp collect_

List_ConflictSet_74469_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74474
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab74473
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74473:
    jmp lab74475

lab74474:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab74475:
    ; substitute (a2 !-> a2)(a7 !-> a7)(as1 !-> as1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x1: List[ConflictSet] = Cons(a7, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74487
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74488

lab74487:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74485
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74478
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74476
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74477

lab74476:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74477:

lab74478:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74481
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74479
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74480

lab74479:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74480:

lab74481:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74484
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74482
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74483

lab74482:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74483:

lab74484:
    jmp lab74486

lab74485:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74486:

lab74488:
    ; #load tag
    mov rdi, 5
    ; substitute (x1 !-> x1)(a2 !-> a2);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump collect_
    jmp collect_

List_i64_74455:
    jmp near List_i64_74455_Nil
    jmp near List_i64_74455_Cons

List_i64_74455_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74491
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    cmp rsi, 0
    je lab74489
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74489:
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab74490
    ; ####increment refcount
    add qword [rax + 0], 1

lab74490:
    jmp lab74492

lab74491:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rsi, [rax + 48]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab74492:
    ; let x0: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (a1 !-> a1)(as_ !-> as_)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump lift_domain_wipeout_1_
    jmp lift_domain_wipeout_1_

List_i64_74455_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74495
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab74493
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74493:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab74494
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74494:
    jmp lab74496

lab74495:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab74496:
    ; substitute (a1 !-> a1)(as_ !-> as_)(a6 !-> a6)(as0 !-> as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, r10
    mov r10, rsi
    mov rsi, r8
    ; let x0: List[i64] = Cons(a6, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74508
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74509

lab74508:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74506
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74499
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74497
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74498

lab74497:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74498:

lab74499:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74502
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74500
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74501

lab74500:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74501:

lab74502:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74505
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74503
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74504

lab74503:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74504:

lab74505:
    jmp lab74507

lab74506:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74507:

lab74509:
    ; #load tag
    mov r9, 5
    ; jump lift_domain_wipeout_1_
    jmp lift_domain_wipeout_1_

lift_domain_wipeout_1_:
    ; let cs_: ConflictSet = Known(x0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74521
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74522

lab74521:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74519
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74512
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74510
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74511

lab74510:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74511:

lab74512:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74515
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74513
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74514

lab74513:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74514:

lab74515:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74518
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74516
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74517

lab74516:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74517:

lab74518:
    jmp lab74520

lab74519:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74520:

lab74522:
    ; #load tag
    mov r9, 0
    ; jump share_domain_wipeout_0_
    jmp share_domain_wipeout_0_

share_domain_wipeout_0_:
    ; substitute (as_ !-> as_)(cs_ !-> cs_)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a1 Tup
    jmp r9

fc_:
    ; substitute (csp0 !-> csp)(t !-> t)(a0 !-> a0)(csp !-> csp);
    ; #share csp
    cmp rax, 0
    je lab74523
    ; ####increment refcount
    add qword [rax + 0], 1

lab74523:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; new a1: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = (a0, csp)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74535
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74536

lab74535:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74533
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74526
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74524
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74525

lab74524:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74525:

lab74526:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74529
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74527
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74528

lab74527:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74528:

lab74529:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74532
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74530
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74531

lab74530:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74531:

lab74532:
    jmp lab74534

lab74533:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74534:

lab74536:
    ; #load tag
    lea r9, [rel Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_74537]
    ; substitute (csp00 !-> csp0)(t !-> t)(a1 !-> a1)(csp0 !-> csp0);
    ; #share csp0
    cmp rax, 0
    je lab74538
    ; ####increment refcount
    add qword [rax + 0], 1

lab74538:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; new a2: Node[Pair[List[Assign], List[List[ConflictSet]]]] = (a1, csp0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74550
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74551

lab74550:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74548
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74541
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74539
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74540

lab74539:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74540:

lab74541:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74544
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74542
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74543

lab74542:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74543:

lab74544:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74547
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74545
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74546

lab74545:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74546:

lab74547:
    jmp lab74549

lab74548:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74549:

lab74551:
    ; #load tag
    lea r9, [rel Node_Pair_List_Assign_List_List_ConflictSet_74552]
    ; substitute (csp000 !-> csp00)(t !-> t)(a2 !-> a2)(csp00 !-> csp00);
    ; #share csp00
    cmp rax, 0
    je lab74553
    ; ####increment refcount
    add qword [rax + 0], 1

lab74553:
    ; #move variables
    mov r10, rax
    mov r11, rdx
    ; new a3: List[List[ConflictSet]] = (t, a2, csp00)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov [rbx + 16], rsi
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74565
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74566

lab74565:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74563
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74556
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74554
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74555

lab74554:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74555:

lab74556:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74559
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74557
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74558

lab74557:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74558:

lab74559:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74562
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74560
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74561

lab74560:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74561:

lab74562:
    jmp lab74564

lab74563:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74564:

lab74566:
    ; #load tag
    lea rdi, [rel List_List_ConflictSet_74567]
    ; jump empty_table_
    jmp empty_table_

List_List_ConflictSet_74567:
    jmp near List_List_ConflictSet_74567_Nil
    jmp near List_List_ConflictSet_74567_Cons

List_List_ConflictSet_74567_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74571
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    cmp r8, 0
    je lab74568
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74568:
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab74569
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74569:
    mov rdx, [rax + 24]
    mov rax, [rax + 16]
    cmp rax, 0
    je lab74570
    ; ####increment refcount
    add qword [rax + 0], 1

lab74570:
    jmp lab74572

lab74571:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov r8, [rax + 48]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]
    mov rax, [rax + 16]

lab74572:
    ; let x2: List[List[ConflictSet]] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (csp00 !-> csp00)(x2 !-> x2)(t !-> t)(a2 !-> a2);
    ; #move variables
    mov rcx, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump cache_checks_
    jmp cache_checks_

List_List_ConflictSet_74567_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74576
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    cmp r12, 0
    je lab74573
    ; ####increment refcount
    add qword [r12 + 0], 1

lab74573:
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab74574
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74574:
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]
    cmp r8, 0
    je lab74575
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74575:
    jmp lab74577

lab74576:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r12, [r8 + 48]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]
    mov r8, [r8 + 16]

lab74577:
    ; substitute (csp00 !-> csp00)(a2 !-> a2)(t !-> t)(a4 !-> a4)(as0 !-> as0);
    ; #move variables
    mov rcx, r12
    mov r12, rsi
    mov rsi, r10
    mov r10, rax
    mov rax, rcx
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    ; let x2: List[List[ConflictSet]] = Cons(a4, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74589
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab74590

lab74589:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74587
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74580
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74578
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74579

lab74578:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74579:

lab74580:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74583
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74581
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74582

lab74581:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74582:

lab74583:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74586
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74584
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74585

lab74584:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74585:

lab74586:
    jmp lab74588

lab74587:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74588:

lab74590:
    ; #load tag
    mov r11, 5
    ; substitute (csp00 !-> csp00)(x2 !-> x2)(t !-> t)(a2 !-> a2);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    ; jump cache_checks_
    jmp cache_checks_

Node_Pair_List_Assign_List_List_ConflictSet_74552:

Node_Pair_List_Assign_List_List_ConflictSet_74552_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74593
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab74591
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74591:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab74592
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74592:
    jmp lab74594

lab74593:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab74594:
    ; substitute (csp0 !-> csp0)(a1 !-> a1)(lab1 !-> lab1)(children1 !-> children1);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x1: Node[Pair[List[Assign], List[List[ConflictSet]]]] = Node(lab1, children1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74606
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74607

lab74606:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74604
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74597
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74595
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74596

lab74595:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74596:

lab74597:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74600
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74598
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74599

lab74598:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74599:

lab74600:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74603
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74601
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74602

lab74601:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74602:

lab74603:
    jmp lab74605

lab74604:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74605:

lab74607:
    ; #load tag
    mov r9, 0
    ; substitute (csp0 !-> csp0)(x1 !-> x1)(a1 !-> a1);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump lookup_cache_
    jmp lookup_cache_

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_74537:

Node_Pair_Pair_List_Assign_ConflictSet_List_List_ConflictSet_74537_Node:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74610
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab74608
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74608:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab74609
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74609:
    jmp lab74611

lab74610:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab74611:
    ; substitute (csp !-> csp)(a0 !-> a0)(lab0 !-> lab0)(children0 !-> children0);
    ; #move variables
    mov rcx, r10
    mov r10, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; let x0: Node[Pair[Pair[List[Assign], ConflictSet], List[List[ConflictSet]]]] = Node(lab0, children0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74623
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74624

lab74623:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74621
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74614
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74612
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74613

lab74612:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74613:

lab74614:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74617
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74615
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74616

lab74615:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74616:

lab74617:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74620
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74618
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74619

lab74618:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74619:

lab74620:
    jmp lab74622

lab74621:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74622:

lab74624:
    ; #load tag
    mov r9, 0
    ; substitute (csp !-> csp)(x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; jump domain_wipeout_
    jmp domain_wipeout_

list_len_:
    ; substitute (a0 !-> a0)(l !-> l);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_List_Assign_74625]
    add rcx, rdi
    jmp rcx

List_List_Assign_74625:
    jmp near List_List_Assign_74625_Nil
    jmp near List_List_Assign_74625_Cons

List_List_Assign_74625_Nil:
    ; lit x2 <- 0;
    mov rdi, 0
    ; substitute (x2 !-> x2)(a0 !-> a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    jmp rdi

List_List_Assign_74625_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74628
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab74626
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74626:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab74627
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74627:
    jmp lab74629

lab74628:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab74629:
    ; substitute (a0 !-> a0)(ls !-> ls);
    ; #erase l0
    cmp rsi, 0
    je lab74632
    ; ######check refcount
    cmp qword [rsi + 0], 0
    je lab74630
    ; ######either decrement refcount ...
    add qword [rsi + 0], -1
    jmp lab74631

lab74630:
    ; ######... or add block to lazy free list
    mov [rsi + 0], rbp
    mov rbp, rsi

lab74631:

lab74632:
    ; #move variables
    mov rsi, r8
    mov rdi, r9
    ; lit x0 <- 1;
    mov r9, 1
    ; substitute (ls !-> ls)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; new a1: _Cont = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov qword [rbx + 48], 0
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74644
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74645

lab74644:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74642
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74635
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74633
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74634

lab74633:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74634:

lab74635:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74638
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74636
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74637

lab74636:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74637:

lab74638:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74641
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74639
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74640

lab74639:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74640:

lab74641:
    jmp lab74643

lab74642:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74643:

lab74645:
    ; #load tag
    lea rdi, [rel _Cont_74646]
    ; jump list_len_
    jmp list_len_

_Cont_74646:

_Cont_74646_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74648
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab74647
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74647:
    jmp lab74649

lab74648:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab74649:
    ; x3 <- x0 + x1;
    mov r11, r9
    add r11, rdx
    ; substitute (x3 !-> x3)(a0 !-> a0);
    ; #move variables
    mov rdx, r11
    ; invoke a0 Ret
    jmp rdi

try__:
    ; new a1: List[List[Assign]] = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74661
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74662

lab74661:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74659
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74652
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74650
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74651

lab74650:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74651:

lab74652:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74655
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74653
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74654

lab74653:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74654:

lab74655:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74658
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74656
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74657

lab74656:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74657:

lab74658:
    jmp lab74660

lab74659:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74660:

lab74662:
    ; #load tag
    lea r9, [rel List_List_Assign_74663]
    ; new a2: CSP = (algorithm, a1)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74675
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74676

lab74675:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74673
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74666
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74664
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74665

lab74664:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74665:

lab74666:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74669
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74667
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74668

lab74667:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74668:

lab74669:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74672
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74670
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74671

lab74670:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74671:

lab74672:
    jmp lab74674

lab74673:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74674:

lab74676:
    ; #load tag
    lea rdi, [rel CSP_74677]
    ; jump queens_
    jmp queens_

CSP_74677:

CSP_74677_CSP:
    ; #load from memory
    ; ##check refcount
    cmp qword [r10 + 0], 0
    je lab74680
    ; ##either decrement refcount and share children...
    add qword [r10 + 0], -1
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    cmp r12, 0
    je lab74678
    ; ####increment refcount
    add qword [r12 + 0], 1

lab74678:
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]
    cmp r10, 0
    je lab74679
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74679:
    jmp lab74681

lab74680:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r10 + 0], rbx
    mov rbx, r10
    ; ###load values
    mov r13, [r10 + 56]
    mov r12, [r10 + 48]
    mov r11, [r10 + 40]
    mov r10, [r10 + 32]

lab74681:
    ; substitute (a1 !-> a1)(algorithm !-> algorithm)(vars0 !-> vars0)(vals0 !-> vals0)(rel0 !-> rel0);
    ; #move variables
    mov rcx, r13
    mov r13, r9
    mov r9, rdx
    mov rdx, rcx
    mov rcx, r11
    mov r11, rdi
    mov rdi, rcx
    mov rax, r12
    mov r12, r8
    mov rsi, r10
    ; let x1: CSP = CSP(vars0, vals0, rel0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    mov [rbx + 24], r9
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74693
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74694

lab74693:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74691
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74684
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74682
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74683

lab74682:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74683:

lab74684:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74687
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74685
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74686

lab74685:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74686:

lab74687:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74690
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74688
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74689

lab74688:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74689:

lab74690:
    jmp lab74692

lab74691:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74692:

lab74694:
    ; #load tag
    mov r9, 0
    ; substitute (algorithm !-> algorithm)(x1 !-> x1)(a1 !-> a1);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump search_
    jmp search_

List_List_Assign_74663:
    jmp near List_List_Assign_74663_Nil
    jmp near List_List_Assign_74663_Cons

List_List_Assign_74663_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74696
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab74695
    ; ####increment refcount
    add qword [rax + 0], 1

lab74695:
    jmp lab74697

lab74696:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab74697:
    ; let x0: List[List[Assign]] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; substitute (x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump list_len_
    jmp list_len_

List_List_Assign_74663_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74699
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab74698
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74698:
    jmp lab74700

lab74699:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab74700:
    ; substitute (a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; let x0: List[List[Assign]] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov [rbx + 32], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74712
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74713

lab74712:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74710
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74703
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74701
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74702

lab74701:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74702:

lab74703:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74706
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74704
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74705

lab74704:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74705:

lab74706:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74709
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74707
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74708

lab74707:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74708:

lab74709:
    jmp lab74711

lab74710:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74711:

lab74713:
    ; #load tag
    mov rdi, 5
    ; substitute (x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump list_len_
    jmp list_len_

test_map_:
    ; substitute (f !-> f)(a0 !-> a0)(l !-> l);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74714]
    add rcx, r9
    jmp rcx

List_Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74714:
    jmp near List_Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74714_Nil
    jmp near List_Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74714_Cons

List_Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74714_Nil:
    ; substitute (a0 !-> a0);
    ; #erase f
    cmp rax, 0
    je lab74717
    ; ######check refcount
    cmp qword [rax + 0], 0
    je lab74715
    ; ######either decrement refcount ...
    add qword [rax + 0], -1
    jmp lab74716

lab74715:
    ; ######... or add block to lazy free list
    mov [rax + 0], rbp
    mov rbp, rax

lab74716:

lab74717:
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; invoke a0 Nil
    add rdx, 0
    jmp rdx

List_Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74714_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74720
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    cmp r10, 0
    je lab74718
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74718:
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab74719
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74719:
    jmp lab74721

lab74720:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r10, [r8 + 48]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab74721:
    ; substitute (f0 !-> f)(g !-> g)(a0 !-> a0)(gs !-> gs)(f !-> f);
    ; #share f
    cmp rax, 0
    je lab74722
    ; ####increment refcount
    add qword [rax + 0], 1

lab74722:
    ; #move variables
    mov r12, rax
    mov r13, rdx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; new a1: _Cont = (a0, gs, f)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    mov [rbx + 24], r9
    mov [rbx + 16], r8
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74734
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74735

lab74734:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74732
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74725
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74723
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74724

lab74723:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74724:

lab74725:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74728
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74726
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74727

lab74726:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74727:

lab74728:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74731
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74729
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74730

lab74729:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74730:

lab74731:
    jmp lab74733

lab74732:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74733:

lab74735:
    ; #load tag
    lea r9, [rel _Cont_74736]
    ; substitute (g !-> g)(a1 !-> a1)(f0 !-> f0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke f0 Ap
    jmp r9

_Cont_74736:

_Cont_74736_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74740
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    cmp r10, 0
    je lab74737
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74737:
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    cmp r8, 0
    je lab74738
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74738:
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]
    cmp rsi, 0
    je lab74739
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74739:
    jmp lab74741

lab74740:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r11, [rsi + 56]
    mov r10, [rsi + 48]
    mov r9, [rsi + 40]
    mov r8, [rsi + 32]
    mov rdi, [rsi + 24]
    mov rsi, [rsi + 16]

lab74741:
    ; substitute (f !-> f)(gs !-> gs)(a0 !-> a0)(x0 !-> x0);
    ; #move variables
    mov rcx, r11
    mov r11, rdx
    mov rdx, rcx
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    mov rax, r10
    ; new a2: List[i64] = (a0, x0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74753
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74754

lab74753:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74751
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74744
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74742
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74743

lab74742:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74743:

lab74744:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74747
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74745
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74746

lab74745:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74746:

lab74747:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74750
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74748
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74749

lab74748:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74749:

lab74750:
    jmp lab74752

lab74751:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74752:

lab74754:
    ; #load tag
    lea r9, [rel List_i64_74755]
    ; jump test_map_
    jmp test_map_

List_i64_74755:
    jmp near List_i64_74755_Nil
    jmp near List_i64_74755_Cons

List_i64_74755_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74757
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]
    cmp rax, 0
    je lab74756
    ; ####increment refcount
    add qword [rax + 0], 1

lab74756:
    jmp lab74758

lab74757:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdi, [rax + 56]
    mov rdx, [rax + 40]
    mov rax, [rax + 32]

lab74758:
    ; let x1: List[i64] = Nil();
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    mov r9, 0
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rsi, r8
    mov r8, rax
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

List_i64_74755_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74760
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]
    cmp r8, 0
    je lab74759
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74759:
    jmp lab74761

lab74760:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r11, [r8 + 56]
    mov r9, [r8 + 40]
    mov r8, [r8 + 32]

lab74761:
    ; substitute (x0 !-> x0)(a0 !-> a0)(a3 !-> a3)(as0 !-> as0);
    ; #move variables
    mov rcx, r11
    mov r11, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov r10, rsi
    mov rsi, r8
    ; let x1: List[i64] = Cons(a3, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74773
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74774

lab74773:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74771
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74764
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74762
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74763

lab74762:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74763:

lab74764:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74767
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74765
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74766

lab74765:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74766:

lab74767:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74770
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74768
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74769

lab74768:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74769:

lab74770:
    jmp lab74772

lab74771:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74772:

lab74774:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, r8
    mov r8, rsi
    mov rsi, rcx
    mov rcx, r9
    mov r9, rdi
    mov rdi, rcx
    ; invoke a0 Cons
    add r9, 5
    jmp r9

test_constraints_nofib_:
    ; substitute (a0 !-> a0)(n !-> n);
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; new x0: Fun[Fun[CSP, Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]], i64] = (n)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov qword [rbx + 48], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74786
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74787

lab74786:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74784
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74777
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74775
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74776

lab74775:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74776:

lab74777:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74780
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74778
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74779

lab74778:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74779:

lab74780:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74783
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74781
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74782

lab74781:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74782:

lab74783:
    jmp lab74785

lab74784:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74785:

lab74787:
    ; #load tag
    lea rdi, [rel Fun_Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_i64_74788]
    ; new x2: Fun[CSP, Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r8, 0
    ; #load tag
    lea r9, [rel Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74789]
    ; new x4: Fun[CSP, Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    lea r11, [rel Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74790]
    ; new x6: Fun[CSP, Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r12, 0
    ; #load tag
    lea r13, [rel Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74791]
    ; new x8: Fun[CSP, Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = ()\{ ... \};
    ; #mark no allocation
    mov r14, 0
    ; #load tag
    lea r15, [rel Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74792]
    ; new x10: Fun[CSP, Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]] = ()\{ ... \};
    ; #mark no allocation
    mov qword [rsp + 2032], 0
    ; #load tag
    lea rcx, [rel Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74793]
    mov [rsp + 2024], rcx
    ; let x11: List[Fun[CSP, Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]]] = Nil();
    ; #mark no allocation
    mov qword [rsp + 2016], 0
    ; #load tag
    mov qword [rsp + 2008], 0
    ; let x9: List[Fun[CSP, Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]]] = Cons(x10, x11);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2008]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2016]
    mov [rbx + 48], rcx
    mov rcx, [rsp + 2024]
    mov [rbx + 40], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 32], rcx
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rcx, rbx
    mov [rsp + 2032], rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74805
    ; ####initialize refcount of just acquired block
    mov qword [rcx + 0], 0
    jmp lab74806

lab74805:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74803
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74796
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74794
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74795

lab74794:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74795:

lab74796:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74799
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74797
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74798

lab74797:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74798:

lab74799:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74802
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74800
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74801

lab74800:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74801:

lab74802:
    jmp lab74804

lab74803:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74804:

lab74806:
    ; #load tag
    mov qword [rsp + 2024], 5
    ; let x7: List[Fun[CSP, Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]]] = Cons(x8, x9);
    ; #allocate memory
    ; ##store values
    mov rcx, [rsp + 2024]
    mov [rbx + 56], rcx
    mov rcx, [rsp + 2032]
    mov [rbx + 48], rcx
    mov [rbx + 40], r15
    mov [rbx + 32], r14
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r14, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74818
    ; ####initialize refcount of just acquired block
    mov qword [r14 + 0], 0
    jmp lab74819

lab74818:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74816
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74809
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74807
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74808

lab74807:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74808:

lab74809:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74812
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74810
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74811

lab74810:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74811:

lab74812:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74815
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74813
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74814

lab74813:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74814:

lab74815:
    jmp lab74817

lab74816:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74817:

lab74819:
    ; #load tag
    mov r15, 5
    ; let x5: List[Fun[CSP, Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]]] = Cons(x6, x7);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r15
    mov [rbx + 48], r14
    mov [rbx + 40], r13
    mov [rbx + 32], r12
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r12, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74831
    ; ####initialize refcount of just acquired block
    mov qword [r12 + 0], 0
    jmp lab74832

lab74831:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74829
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74822
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74820
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74821

lab74820:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74821:

lab74822:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74825
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74823
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74824

lab74823:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74824:

lab74825:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74828
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74826
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74827

lab74826:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74827:

lab74828:
    jmp lab74830

lab74829:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74830:

lab74832:
    ; #load tag
    mov r13, 5
    ; let x3: List[Fun[CSP, Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]]] = Cons(x4, x5);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov [rbx + 32], r10
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74844
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab74845

lab74844:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74842
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74835
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74833
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74834

lab74833:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74834:

lab74835:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74838
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74836
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74837

lab74836:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74837:

lab74838:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74841
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74839
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74840

lab74839:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74840:

lab74841:
    jmp lab74843

lab74842:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74843:

lab74845:
    ; #load tag
    mov r11, 5
    ; let x1: List[Fun[CSP, Fun[Node[List[Assign]], Node[Pair[List[Assign], ConflictSet]]]]] = Cons(x2, x3);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov [rbx + 48], r10
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r8, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74857
    ; ####initialize refcount of just acquired block
    mov qword [r8 + 0], 0
    jmp lab74858

lab74857:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74855
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74848
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74846
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74847

lab74846:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74847:

lab74848:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74851
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74849
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74850

lab74849:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74850:

lab74851:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74854
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74852
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74853

lab74852:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74853:

lab74854:
    jmp lab74856

lab74855:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74856:

lab74858:
    ; #load tag
    mov r9, 5
    ; substitute (x0 !-> x0)(x1 !-> x1)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, r8
    mov r8, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    ; jump test_map_
    jmp test_map_

Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74793:

Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74793_Ap:
    ; switch a10 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74859:

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74859_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74862
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab74860
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74860:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab74861
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74861:
    jmp lab74863

lab74862:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab74863:
    ; jump fc_
    jmp fc_

Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74792:

Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74792_Ap:
    ; switch a8 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74864:

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74864_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74867
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab74865
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74865:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab74866
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74866:
    jmp lab74868

lab74867:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab74868:
    ; jump bjbt__
    jmp bjbt__

Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74791:

Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74791_Ap:
    ; switch a6 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74869:

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74869_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74872
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab74870
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74870:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab74871
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74871:
    jmp lab74873

lab74872:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab74873:
    ; jump bjbt_
    jmp bjbt_

Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74790:

Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74790_Ap:
    ; switch a4 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74874:

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74874_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74877
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab74875
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74875:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab74876
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74876:
    jmp lab74878

lab74877:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab74878:
    ; jump bm_
    jmp bm_

Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74789:

Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74789_Ap:
    ; switch a2 \{ ... \};
    ; #if there is only one clause, we can just fall through

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74879:

Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_74879_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74882
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab74880
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74880:
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]
    cmp rsi, 0
    je lab74881
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74881:
    jmp lab74883

lab74882:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]
    mov rsi, [rsi + 32]

lab74883:
    ; jump bt_
    jmp bt_

Fun_Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_i64_74788:

Fun_Fun_CSP_Fun_Node_List_Assign_Node_Pair_List_Assign_ConflictSet_i64_74788_Ap:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74884
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    jmp lab74885

lab74884:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]

lab74885:
    ; substitute (n !-> n)(x !-> x)(a1 !-> a1);
    ; #move variables
    mov r8, rsi
    mov rsi, rax
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; jump try__
    jmp try__

head_:
    ; substitute (a0 !-> a0)(l !-> l);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; switch l \{ ... \};
    lea rcx, [rel List_i64_74886]
    add rcx, rdi
    jmp rcx

List_i64_74886:
    jmp near List_i64_74886_Nil
    jmp near List_i64_74886_Cons

List_i64_74886_Nil:
    ; lit x0 <- -1;
    mov rdi, -1
    ; substitute (x0 !-> x0)(a0 !-> a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    jmp rdi

List_i64_74886_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74888
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    cmp r8, 0
    je lab74887
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74887:
    mov rdi, [rsi + 40]
    jmp lab74889

lab74888:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov r9, [rsi + 56]
    mov r8, [rsi + 48]
    mov rdi, [rsi + 40]

lab74889:
    ; substitute (x !-> x)(a0 !-> a0);
    ; #erase xs
    cmp r8, 0
    je lab74892
    ; ######check refcount
    cmp qword [r8 + 0], 0
    je lab74890
    ; ######either decrement refcount ...
    add qword [r8 + 0], -1
    jmp lab74891

lab74890:
    ; ######... or add block to lazy free list
    mov [r8 + 0], rbp
    mov rbp, r8

lab74891:

lab74892:
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    jmp rdi

main_loop_:
    ; lit x0 <- 1;
    mov r11, 1
    ; if iters == x0 \{ ... \}
    cmp rdx, r11
    je lab74893
    ; substitute (n0 !-> n)(n !-> n)(a0 !-> a0)(iters !-> iters);
    ; #move variables
    mov r11, rdx
    mov rdx, rdi
    ; new a4: List[i64] = (n, a0, iters)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r11
    mov qword [rbx + 48], 0
    mov [rbx + 40], r9
    mov [rbx + 32], r8
    mov [rbx + 24], rdi
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74905
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74906

lab74905:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74903
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74896
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74894
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74895

lab74894:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74895:

lab74896:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74899
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74897
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74898

lab74897:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74898:

lab74899:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74902
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74900
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74901

lab74900:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74901:

lab74902:
    jmp lab74904

lab74903:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74904:

lab74906:
    ; #load tag
    lea rdi, [rel List_i64_74907]
    ; jump test_constraints_nofib_
    jmp test_constraints_nofib_

List_i64_74907:
    jmp near List_i64_74907_Nil
    jmp near List_i64_74907_Cons

List_i64_74907_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74909
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov r9, [rax + 56]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    cmp rsi, 0
    je lab74908
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74908:
    mov rdx, [rax + 24]
    jmp lab74910

lab74909:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov r9, [rax + 56]
    mov rdi, [rax + 40]
    mov rsi, [rax + 32]
    mov rdx, [rax + 24]

lab74910:
    ; let res: List[i64] = Nil();
    ; #mark no allocation
    mov r10, 0
    ; #load tag
    mov r11, 0
    ; substitute (a0 !-> a0)(iters !-> iters)(n !-> n);
    ; #erase res
    cmp r10, 0
    je lab74913
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab74911
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab74912

lab74911:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab74912:

lab74913:
    ; #move variables
    mov rcx, rdi
    mov rdi, r9
    mov r9, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump lift_main_loop_1_
    jmp lift_main_loop_1_

List_i64_74907_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74915
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    cmp r10, 0
    je lab74914
    ; ####increment refcount
    add qword [r10 + 0], 1

lab74914:
    mov r9, [r8 + 24]
    jmp lab74916

lab74915:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r13, [r8 + 56]
    mov r11, [r8 + 40]
    mov r10, [r8 + 32]
    mov r9, [r8 + 24]

lab74916:
    ; substitute (iters !-> iters)(a0 !-> a0)(n !-> n)(a6 !-> a6)(as1 !-> as1);
    ; #move variables
    mov rcx, r13
    mov r13, rdi
    mov rdi, r11
    mov r11, rdx
    mov rdx, rcx
    mov r12, rsi
    mov rsi, r10
    ; let res: List[i64] = Cons(a6, as1);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r13
    mov [rbx + 48], r12
    mov [rbx + 40], r11
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov r10, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74928
    ; ####initialize refcount of just acquired block
    mov qword [r10 + 0], 0
    jmp lab74929

lab74928:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74926
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74919
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74917
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74918

lab74917:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74918:

lab74919:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74922
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74920
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74921

lab74920:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74921:

lab74922:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74925
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74923
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74924

lab74923:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74924:

lab74925:
    jmp lab74927

lab74926:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74927:

lab74929:
    ; #load tag
    mov r11, 5
    ; substitute (a0 !-> a0)(iters !-> iters)(n !-> n);
    ; #erase res
    cmp r10, 0
    je lab74932
    ; ######check refcount
    cmp qword [r10 + 0], 0
    je lab74930
    ; ######either decrement refcount ...
    add qword [r10 + 0], -1
    jmp lab74931

lab74930:
    ; ######... or add block to lazy free list
    mov [r10 + 0], rbp
    mov rbp, r10

lab74931:

lab74932:
    ; #move variables
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, rsi
    ; jump lift_main_loop_1_
    jmp lift_main_loop_1_

lab74893:
    ; substitute (n !-> n)(a0 !-> a0);
    ; #move variables
    mov rdx, rdi
    mov rsi, r8
    mov rdi, r9
    ; new a3: List[i64] = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74944
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74945

lab74944:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74942
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74935
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74933
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74934

lab74933:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74934:

lab74935:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74938
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74936
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74937

lab74936:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74937:

lab74938:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74941
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74939
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74940

lab74939:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74940:

lab74941:
    jmp lab74943

lab74942:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74943:

lab74945:
    ; #load tag
    lea rdi, [rel List_i64_74946]
    ; jump test_constraints_nofib_
    jmp test_constraints_nofib_

List_i64_74946:
    jmp near List_i64_74946_Nil
    jmp near List_i64_74946_Cons

List_i64_74946_Nil:
    ; #load from memory
    ; ##check refcount
    cmp qword [rax + 0], 0
    je lab74948
    ; ##either decrement refcount and share children...
    add qword [rax + 0], -1
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]
    cmp rax, 0
    je lab74947
    ; ####increment refcount
    add qword [rax + 0], 1

lab74947:
    jmp lab74949

lab74948:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rax + 0], rbx
    mov rbx, rax
    ; ###load values
    mov rdx, [rax + 56]
    mov rax, [rax + 48]

lab74949:
    ; let res: List[i64] = Nil();
    ; #mark no allocation
    mov rsi, 0
    ; #load tag
    mov rdi, 0
    ; jump lift_main_loop_0_
    jmp lift_main_loop_0_

List_i64_74946_Cons:
    ; #load from memory
    ; ##check refcount
    cmp qword [r8 + 0], 0
    je lab74951
    ; ##either decrement refcount and share children...
    add qword [r8 + 0], -1
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]
    cmp r8, 0
    je lab74950
    ; ####increment refcount
    add qword [r8 + 0], 1

lab74950:
    jmp lab74952

lab74951:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [r8 + 0], rbx
    mov rbx, r8
    ; ###load values
    mov r9, [r8 + 56]
    mov r8, [r8 + 48]

lab74952:
    ; substitute (a0 !-> a0)(a5 !-> a5)(as0 !-> as0);
    ; #move variables
    mov rcx, r9
    mov r9, rdi
    mov rdi, rdx
    mov rdx, rcx
    mov rax, r8
    mov r8, rsi
    ; let res: List[i64] = Cons(a5, as0);
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], r9
    mov [rbx + 48], r8
    mov [rbx + 40], rdi
    mov qword [rbx + 32], 0
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74964
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74965

lab74964:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74962
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74955
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74953
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74954

lab74953:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74954:

lab74955:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74958
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74956
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74957

lab74956:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74957:

lab74958:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74961
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74959
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74960

lab74959:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74960:

lab74961:
    jmp lab74963

lab74962:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74963:

lab74965:
    ; #load tag
    mov rdi, 5
    ; jump lift_main_loop_0_
    jmp lift_main_loop_0_

lift_main_loop_1_:
    ; lit x2 <- 1;
    mov r11, 1
    ; x3 <- iters - x2;
    mov r13, rdi
    sub r13, r11
    ; substitute (x3 !-> x3)(n !-> n)(a0 !-> a0);
    ; #move variables
    mov r8, rax
    mov rdi, r9
    mov r9, rdx
    mov rdx, r13
    ; jump main_loop_
    jmp main_loop_

lift_main_loop_0_:
    ; substitute (res !-> res)(a0 !-> a0);
    ; #move variables
    mov rcx, rsi
    mov rsi, rax
    mov rax, rcx
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; new a1: _Cont = (a0)\{ ... \};
    ; #allocate memory
    ; ##store values
    mov [rbx + 56], rdi
    mov [rbx + 48], rsi
    ; ##mark unused fields with null
    mov qword [rbx + 16], 0
    mov qword [rbx + 32], 0
    ; ##acquire free block from heap register
    mov rsi, rbx
    ; ##get next free block into heap register
    ; ###(1) check linear free list for next block
    mov rbx, [rbx + 0]
    cmp rbx, 0
    je lab74977
    ; ####initialize refcount of just acquired block
    mov qword [rsi + 0], 0
    jmp lab74978

lab74977:
    ; ###(2) check non-linear lazy free list for next block
    mov rbx, rbp
    mov rbp, [rbp + 0]
    cmp rbp, 0
    je lab74975
    ; ####mark linear free list empty
    mov qword [rbx + 0], 0
    ; ####erase children of next block
    ; #####check child 1 for erasure
    mov rcx, [rbx + 16]
    cmp rcx, 0
    je lab74968
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74966
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74967

lab74966:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74967:

lab74968:
    ; #####check child 2 for erasure
    mov rcx, [rbx + 32]
    cmp rcx, 0
    je lab74971
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74969
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74970

lab74969:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74970:

lab74971:
    ; #####check child 3 for erasure
    mov rcx, [rbx + 48]
    cmp rcx, 0
    je lab74974
    ; ######check refcount
    cmp qword [rcx + 0], 0
    je lab74972
    ; ######either decrement refcount ...
    add qword [rcx + 0], -1
    jmp lab74973

lab74972:
    ; ######... or add block to lazy free list
    mov [rcx + 0], rbp
    mov rbp, rcx

lab74973:

lab74974:
    jmp lab74976

lab74975:
    ; ###(3) fall back to bump allocation
    mov rbp, rbx
    add rbp, 64

lab74976:

lab74978:
    ; #load tag
    lea rdi, [rel _Cont_74979]
    ; jump head_
    jmp head_

_Cont_74979:

_Cont_74979_Ret:
    ; #load from memory
    ; ##check refcount
    cmp qword [rsi + 0], 0
    je lab74981
    ; ##either decrement refcount and share children...
    add qword [rsi + 0], -1
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]
    cmp rsi, 0
    je lab74980
    ; ####increment refcount
    add qword [rsi + 0], 1

lab74980:
    jmp lab74982

lab74981:
    ; ##... or release blocks onto linear free list when loading
    ; ###release block
    mov [rsi + 0], rbx
    mov rbx, rsi
    ; ###load values
    mov rdi, [rsi + 56]
    mov rsi, [rsi + 48]

lab74982:
    ; println_i64 x1;
    ; #save caller-save registers
    mov r12, rdx
    mov r13, rsi
    mov r14, rdi
    sub rsp, 8
    ; #move argument into place
    mov rdi, rdx
    call println_i64
    ; #restore caller-save registers
    mov rdx, r12
    mov rsi, r13
    mov rdi, r14
    add rsp, 8
    ; substitute (a0 !-> a0);
    ; #move variables
    mov rax, rsi
    mov rdx, rdi
    ; lit x4 <- 0;
    mov rdi, 0
    ; substitute (x4 !-> x4)(a0 !-> a0);
    ; #move variables
    mov rsi, rax
    mov rcx, rdi
    mov rdi, rdx
    mov rdx, rcx
    ; invoke a0 Ret
    jmp rdi
    ; cleanup

cleanup:
    ; free space for register spills
    add rsp, 2048
    ; restore registers
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbp
    pop rbx
    ret