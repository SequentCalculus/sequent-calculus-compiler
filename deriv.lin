type Bool { True, False }
tyxpe Expr {
    Add(sums: prd List[Expr]),
    Sub(subs: prd List[Expr]),
    Mul(muls: prd List[Expr]),
    Div(divs: prd List[Expr]),
    Num(i: ext i64),
    X
}
type List[Expr] { Nil, Cons(x: prd Expr, xs: prd List[Expr]) }
type _Cont { Ret(x: ext i64) }
type Fun[Expr, Expr] { apply(x: prd Expr, a0: cns Expr) }

def main(iters: ext i64, n: ext i64, m: ext i64) {
    create a0: _Cont = (){ Ret(x0: ext i64) => exit x0 };
    main_loop(iters: ext i64, n: ext i64, m: ext i64, a0: cns _Cont)
}

def map_list(f: cns Fun[Expr, Expr], l: prd List[Expr], a0: cns List[Expr]) {
    substitute (f := f), (a0 := a0), (l := l);
    switch l {
        Nil =>
            substitute (a0 := a0);
            invoke a0 Nil,
        Cons(x: prd Expr, xs: prd List[Expr]) =>
            substitute (f0 := f), (x := x), (a0 := a0), (xs := xs), (f := f);
            create a1: Expr = (a0: cns List[Expr], xs: prd List[Expr], f: cns Fun[Expr, Expr]){
                Add(sums0: prd List[Expr]) =>
                    substitute (f := f), (a0 := a0), (xs := xs), (sums0 := sums0);
                    let x0: Expr = Add(sums0: prd List[Expr]);
                    substitute (a0 := a0), (f := f), (x0 := x0), (xs := xs);
                    lift_map_list_0(
                        a0: cns List[Expr],
                        f: cns Fun[Expr, Expr],
                        x0: prd Expr,
                        xs: prd List[Expr]
                    ),
                Sub(subs0: prd List[Expr]) =>
                    substitute (f := f), (a0 := a0), (xs := xs), (subs0 := subs0);
                    let x0: Expr = Sub(subs0: prd List[Expr]);
                    substitute (a0 := a0), (f := f), (x0 := x0), (xs := xs);
                    lift_map_list_0(
                        a0: cns List[Expr],
                        f: cns Fun[Expr, Expr],
                        x0: prd Expr,
                        xs: prd List[Expr]
                    ),
                Mul(muls0: prd List[Expr]) =>
                    substitute (f := f), (a0 := a0), (xs := xs), (muls0 := muls0);
                    let x0: Expr = Mul(muls0: prd List[Expr]);
                    substitute (a0 := a0), (f := f), (x0 := x0), (xs := xs);
                    lift_map_list_0(
                        a0: cns List[Expr],
                        f: cns Fun[Expr, Expr],
                        x0: prd Expr,
                        xs: prd List[Expr]
                    ),
                Div(divs0: prd List[Expr]) =>
                    substitute (f := f), (a0 := a0), (xs := xs), (divs0 := divs0);
                    let x0: Expr = Div(divs0: prd List[Expr]);
                    substitute (a0 := a0), (f := f), (x0 := x0), (xs := xs);
                    lift_map_list_0(
                        a0: cns List[Expr],
                        f: cns Fun[Expr, Expr],
                        x0: prd Expr,
                        xs: prd List[Expr]
                    ),
                Num(i0: ext i64) =>
                    substitute (f := f), (a0 := a0), (xs := xs), (i0 := i0);
                    let x0: Expr = Num(i0: ext i64);
                    substitute (a0 := a0), (f := f), (x0 := x0), (xs := xs);
                    lift_map_list_0(
                        a0: cns List[Expr],
                        f: cns Fun[Expr, Expr],
                        x0: prd Expr,
                        xs: prd List[Expr]
                    ),
                X =>
                    let x0: Expr = X;
                    substitute (a0 := a0), (f := f), (x0 := x0), (xs := xs);
                    lift_map_list_0(
                        a0: cns List[Expr],
                        f: cns Fun[Expr, Expr],
                        x0: prd Expr,
                        xs: prd List[Expr]
                    )
            };
            substitute (x := x), (a1 := a1), (f0 := f0);
            invoke f0 apply(x: prd Expr, a1: cns Expr)
    }
}

def lift_map_list_0(a0: cns List[Expr], f: cns Fun[Expr, Expr], x0: prd Expr, xs: prd List[Expr]) {
    substitute (xs := xs), (f := f), (x0 := x0), (a0 := a0);
    create a2: List[Expr] = (x0: prd Expr, a0: cns List[Expr]){
        Nil =>
            let x1: List[Expr] = Nil;
            substitute (x0 := x0), (x1 := x1), (a0 := a0);
            invoke a0 Cons(x0: prd Expr, x1: prd List[Expr]),
        Cons(x2: prd Expr, xs0: prd List[Expr]) =>
            substitute (a0 := a0), (x0 := x0), (x2 := x2), (xs0 := xs0);
            let x1: List[Expr] = Cons(x2: prd Expr, xs0: prd List[Expr]);
            substitute (x0 := x0), (x1 := x1), (a0 := a0);
            invoke a0 Cons(x0: prd Expr, x1: prd List[Expr])
    };
    substitute (f := f), (xs := xs), (a2 := a2);
    map_list(f: cns Fun[Expr, Expr], xs: prd List[Expr], a2: cns List[Expr])
}

def map_expr(f: cns Fun[Expr, Expr], e: prd Expr, a0: cns Expr) {
    substitute (f := f), (a0 := a0), (e := e);
    switch e {
        Add(sums: prd List[Expr]) =>
            substitute (f := f), (sums := sums), (a0 := a0);
            create a1: List[Expr] = (a0: cns Expr){
                Nil =>
                    let x0: List[Expr] = Nil;
                    substitute (x0 := x0), (a0 := a0);
                    invoke a0 Add(x0: prd List[Expr]),
                Cons(x6: prd Expr, xs0: prd List[Expr]) =>
                    substitute (a0 := a0), (x6 := x6), (xs0 := xs0);
                    let x0: List[Expr] = Cons(x6: prd Expr, xs0: prd List[Expr]);
                    substitute (x0 := x0), (a0 := a0);
                    invoke a0 Add(x0: prd List[Expr])
            };
            map_list(f: cns Fun[Expr, Expr], sums: prd List[Expr], a1: cns List[Expr]),
        Sub(subs: prd List[Expr]) =>
            substitute (f := f), (subs := subs), (a0 := a0);
            create a2: List[Expr] = (a0: cns Expr){
                Nil =>
                    let x1: List[Expr] = Nil;
                    substitute (x1 := x1), (a0 := a0);
                    invoke a0 Sub(x1: prd List[Expr]),
                Cons(x7: prd Expr, xs1: prd List[Expr]) =>
                    substitute (a0 := a0), (x7 := x7), (xs1 := xs1);
                    let x1: List[Expr] = Cons(x7: prd Expr, xs1: prd List[Expr]);
                    substitute (x1 := x1), (a0 := a0);
                    invoke a0 Sub(x1: prd List[Expr])
            };
            map_list(f: cns Fun[Expr, Expr], subs: prd List[Expr], a2: cns List[Expr]),
        Mul(muls: prd List[Expr]) =>
            substitute (f := f), (muls := muls), (a0 := a0);
            create a3: List[Expr] = (a0: cns Expr){
                Nil =>
                    let x2: List[Expr] = Nil;
                    substitute (x2 := x2), (a0 := a0);
                    invoke a0 Mul(x2: prd List[Expr]),
                Cons(x8: prd Expr, xs2: prd List[Expr]) =>
                    substitute (a0 := a0), (x8 := x8), (xs2 := xs2);
                    let x2: List[Expr] = Cons(x8: prd Expr, xs2: prd List[Expr]);
                    substitute (x2 := x2), (a0 := a0);
                    invoke a0 Mul(x2: prd List[Expr])
            };
            map_list(f: cns Fun[Expr, Expr], muls: prd List[Expr], a3: cns List[Expr]),
        Div(divs: prd List[Expr]) =>
            substitute (f := f), (divs := divs), (a0 := a0);
            create a4: List[Expr] = (a0: cns Expr){
                Nil =>
                    let x3: List[Expr] = Nil;
                    substitute (x3 := x3), (a0 := a0);
                    invoke a0 Div(x3: prd List[Expr]),
                Cons(x9: prd Expr, xs3: prd List[Expr]) =>
                    substitute (a0 := a0), (x9 := x9), (xs3 := xs3);
                    let x3: List[Expr] = Cons(x9: prd Expr, xs3: prd List[Expr]);
                    substitute (x3 := x3), (a0 := a0);
                    invoke a0 Div(x3: prd List[Expr])
            };
            map_list(f: cns Fun[Expr, Expr], divs: prd List[Expr], a4: cns List[Expr]),
        Num(i: ext i64) =>
            let x4: Expr = Num(i: ext i64);
            substitute (x4 := x4), (a0 := a0), (f := f);
            invoke f apply(x4: prd Expr, a0: cns Expr),
        X =>
            let x5: Expr = X;
            substitute (x5 := x5), (a0 := a0), (f := f);
            invoke f apply(x5: prd Expr, a0: cns Expr)
    }
}

def equal_list(l1: prd List[Expr], l2: prd List[Expr], a0: cns Bool) {
    substitute (a0 := a0), (l2 := l2), (l1 := l1);
    switch l1 {
        Nil =>
            substitute (a0 := a0), (l2 := l2);
            switch l2 {
                Nil =>
                    substitute (a0 := a0);
                    invoke a0 True,
                Cons(e: prd Expr, es: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False
            },
        Cons(e1: prd Expr, es1: prd List[Expr]) =>
            substitute (a0 := a0), (es1 := es1), (e1 := e1), (l2 := l2);
            switch l2 {
                Nil =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Cons(e2: prd Expr, es2: prd List[Expr]) =>
                    substitute (e2 := e2), (e1 := e1), (es1 := es1), (a0 := a0), (es2 := es2);
                    create a1: Bool = (es1: prd List[Expr], a0: cns Bool, es2: prd List[Expr]){
                        True =>
                            substitute (es1 := es1), (es2 := es2), (a0 := a0);
                            equal_list(es1: prd List[Expr], es2: prd List[Expr], a0: cns Bool),
                        False =>
                            substitute (a0 := a0);
                            invoke a0 False
                    };
                    substitute (e1 := e1), (e2 := e2), (a1 := a1);
                    equal(e1: prd Expr, e2: prd Expr, a1: cns Bool)
            }
    }
}

def equal(exp1: prd Expr, exp2: prd Expr, a0: cns Bool) {
    substitute (a0 := a0), (exp2 := exp2), (exp1 := exp1);
    switch exp1 {
        Add(sums1: prd List[Expr]) =>
            substitute (a0 := a0), (sums1 := sums1), (exp2 := exp2);
            switch exp2 {
                Add(sums2: prd List[Expr]) =>
                    substitute (sums1 := sums1), (sums2 := sums2), (a0 := a0);
                    equal_list(sums1: prd List[Expr], sums2: prd List[Expr], a0: cns Bool),
                Sub(subs: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Mul(muls: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Div(divs: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Num(i: ext i64) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                X =>
                    substitute (a0 := a0);
                    invoke a0 False
            },
        Sub(subs1: prd List[Expr]) =>
            substitute (a0 := a0), (subs1 := subs1), (exp2 := exp2);
            switch exp2 {
                Add(sums: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Sub(subs2: prd List[Expr]) =>
                    substitute (subs1 := subs1), (subs2 := subs2), (a0 := a0);
                    equal_list(subs1: prd List[Expr], subs2: prd List[Expr], a0: cns Bool),
                Mul(muls: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Div(divs: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Num(i: ext i64) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                X =>
                    substitute (a0 := a0);
                    invoke a0 False
            },
        Mul(muls1: prd List[Expr]) =>
            substitute (a0 := a0), (muls1 := muls1), (exp2 := exp2);
            switch exp2 {
                Add(sums: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Sub(subs: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Mul(muls2: prd List[Expr]) =>
                    substitute (muls1 := muls1), (muls2 := muls2), (a0 := a0);
                    equal_list(muls1: prd List[Expr], muls2: prd List[Expr], a0: cns Bool),
                Div(divs: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Num(i: ext i64) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                X =>
                    substitute (a0 := a0);
                    invoke a0 False
            },
        Div(divs1: prd List[Expr]) =>
            substitute (a0 := a0), (divs1 := divs1), (exp2 := exp2);
            switch exp2 {
                Add(sums: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Sub(subs: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Mul(muls: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Div(divs2: prd List[Expr]) =>
                    substitute (divs1 := divs1), (divs2 := divs2), (a0 := a0);
                    equal_list(divs1: prd List[Expr], divs2: prd List[Expr], a0: cns Bool),
                Num(i: ext i64) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                X =>
                    substitute (a0 := a0);
                    invoke a0 False
            },
        Num(i1: ext i64) =>
            substitute (a0 := a0), (i1 := i1), (exp2 := exp2);
            switch exp2 {
                Add(sums: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Sub(subs: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Mul(muls: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Div(divs: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Num(i2: ext i64) =>
                    if i1 == i2 {
                        substitute (a0 := a0);
                        invoke a0 True
                    } else {
                        substitute (a0 := a0);
                        invoke a0 False
                    },
                X =>
                    substitute (a0 := a0);
                    invoke a0 False
            },
        X =>
            substitute (a0 := a0), (exp2 := exp2);
            switch exp2 {
                Add(sums: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Sub(subs: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Mul(muls: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Div(divs: prd List[Expr]) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                Num(i: ext i64) =>
                    substitute (a0 := a0);
                    invoke a0 False,
                X =>
                    substitute (a0 := a0);
                    invoke a0 True
            }
    }
}

def deriv(e: prd Expr, a0: cns Expr) {
    substitute (e := e), (a0 := a0), (e := e);
    switch e0 {
        Add(sums: prd List[Expr]) =>
            substitute (sums := sums), (a0 := a0);
            create a1: List[Expr] = (a0: cns Expr){
                Nil =>
                    let x0: List[Expr] = Nil;
                    substitute (x0 := x0), (a0 := a0);
                    invoke a0 Add(x0: prd List[Expr]),
                Cons(x34: prd Expr, xs0: prd List[Expr]) =>
                    substitute (a0 := a0), (x34 := x34), (xs0 := xs0);
                    let x0: List[Expr] = Cons(x34: prd Expr, xs0: prd List[Expr]);
                    substitute (x0 := x0), (a0 := a0);
                    invoke a0 Add(x0: prd List[Expr])
            };
            create x1: Fun[Expr, Expr] = (){
                apply(x: prd Expr, a2: cns Expr) =>
                    deriv(x: prd Expr, a2: cns Expr)
            };
            substitute (x1 := x1), (sums := sums), (a1 := a1);
            map_list(x1: cns Fun[Expr, Expr], sums: prd List[Expr], a1: cns List[Expr]),
        Sub(subs: prd List[Expr]) =>
            substitute (subs := subs), (a0 := a0);
            create a3: List[Expr] = (a0: cns Expr){
                Nil =>
                    let x2: List[Expr] = Nil;
                    substitute (x2 := x2), (a0 := a0);
                    invoke a0 Sub(x2: prd List[Expr]),
                Cons(x35: prd Expr, xs1: prd List[Expr]) =>
                    substitute (a0 := a0), (x35 := x35), (xs1 := xs1);
                    let x2: List[Expr] = Cons(x35: prd Expr, xs1: prd List[Expr]);
                    substitute (x2 := x2), (a0 := a0);
                    invoke a0 Sub(x2: prd List[Expr])
            };
            create x3: Fun[Expr, Expr] = (){
                apply(x: prd Expr, a4: cns Expr) =>
                    deriv(x: prd Expr, a4: cns Expr)
            };
            substitute (x3 := x3), (subs := subs), (a3 := a3);
            map_list(x3: cns Fun[Expr, Expr], subs: prd List[Expr], a3: cns List[Expr]),
        Mul(muls: prd List[Expr]) =>
            substitute (muls := muls), (a0 := a0), (e := e);
            create a5: List[Expr] = (a0: cns Expr, e: prd Expr){
                Nil =>
                    let x4: List[Expr] = Nil;
                    lift_deriv_0(a0: cns Expr, e: prd Expr, x4: prd List[Expr]),
                Cons(x36: prd Expr, xs2: prd List[Expr]) =>
                    substitute (e := e), (a0 := a0), (x36 := x36), (xs2 := xs2);
                    let x4: List[Expr] = Cons(x36: prd Expr, xs2: prd List[Expr]);
                    substitute (a0 := a0), (e := e), (x4 := x4);
                    lift_deriv_0(a0: cns Expr, e: prd Expr, x4: prd List[Expr])
            };
            create x5: Fun[Expr, Expr] = (){
                apply(x: prd Expr, a6: cns Expr) =>
                    substitute (x37 := x), (a6 := a6), (x := x);
                    create a7: Expr = (a6: cns Expr, x: prd Expr){
                        Add(sums0: prd List[Expr]) =>
                            substitute (x := x), (a6 := a6), (sums0 := sums0);
                            let x6: Expr = Add(sums0: prd List[Expr]);
                            substitute (a6 := a6), (x := x), (x6 := x6);
                            lift_deriv_1(a6: cns Expr, x: prd Expr, x6: prd Expr),
                        Sub(subs0: prd List[Expr]) =>
                            substitute (x := x), (a6 := a6), (subs0 := subs0);
                            let x6: Expr = Sub(subs0: prd List[Expr]);
                            substitute (a6 := a6), (x := x), (x6 := x6);
                            lift_deriv_1(a6: cns Expr, x: prd Expr, x6: prd Expr),
                        Mul(muls0: prd List[Expr]) =>
                            substitute (x := x), (a6 := a6), (muls0 := muls0);
                            let x6: Expr = Mul(muls0: prd List[Expr]);
                            substitute (a6 := a6), (x := x), (x6 := x6);
                            lift_deriv_1(a6: cns Expr, x: prd Expr, x6: prd Expr),
                        Div(divs0: prd List[Expr]) =>
                            substitute (x := x), (a6 := a6), (divs0 := divs0);
                            let x6: Expr = Div(divs0: prd List[Expr]);
                            substitute (a6 := a6), (x := x), (x6 := x6);
                            lift_deriv_1(a6: cns Expr, x: prd Expr, x6: prd Expr),
                        Num(i0: ext i64) =>
                            substitute (x := x), (a6 := a6), (i0 := i0);
                            let x6: Expr = Num(i0: ext i64);
                            substitute (a6 := a6), (x := x), (x6 := x6);
                            lift_deriv_1(a6: cns Expr, x: prd Expr, x6: prd Expr),
                        X =>
                            let x6: Expr = X;
                            lift_deriv_1(a6: cns Expr, x: prd Expr, x6: prd Expr)
                    };
                    deriv(x37: prd Expr, a7: cns Expr)
            };
            substitute (x5 := x5), (muls := muls), (a5 := a5);
            map_list(x5: cns Fun[Expr, Expr], muls: prd List[Expr], a5: cns List[Expr]),
        Div(divs: prd List[Expr]) =>
            substitute (a0 := a0), (divs := divs);
            switch divs {
                Nil =>
                    substitute (a0 := a0);
                    invoke a0 X,
                Cons(x: prd Expr, xs: prd List[Expr]) =>
                    substitute (a0 := a0), (x := x), (xs := xs);
                    switch xs {
                        Nil =>
                            substitute (a0 := a0);
                            invoke a0 X,
                        Cons(y: prd Expr, ys: prd List[Expr]) =>
                            substitute (a0 := a0), (x := x), (y := y), (ys := ys);
                            switch ys {
                                Nil =>
                                    substitute (x38 := x), (x := x), (y := y), (a0 := a0);
                                    create a8: Expr = (x: prd Expr, y: prd Expr, a0: cns Expr){
                                        Add(sums2: prd List[Expr]) =>
                                            substitute
                                                (a0 := a0),
                                                (x := x),
                                                (y := y),
                                                (sums2 := sums2);
                                            let x14: Expr = Add(sums2: prd List[Expr]);
                                            substitute (a0 := a0), (x := x), (x14 := x14), (y := y);
                                            lift_deriv_2(
                                                a0: cns Expr,
                                                x: prd Expr,
                                                x14: prd Expr,
                                                y: prd Expr
                                            ),
                                        Sub(subs2: prd List[Expr]) =>
                                            substitute
                                                (a0 := a0),
                                                (x := x),
                                                (y := y),
                                                (subs2 := subs2);
                                            let x14: Expr = Sub(subs2: prd List[Expr]);
                                            substitute (a0 := a0), (x := x), (x14 := x14), (y := y);
                                            lift_deriv_2(
                                                a0: cns Expr,
                                                x: prd Expr,
                                                x14: prd Expr,
                                                y: prd Expr
                                            ),
                                        Mul(muls2: prd List[Expr]) =>
                                            substitute
                                                (a0 := a0),
                                                (x := x),
                                                (y := y),
                                                (muls2 := muls2);
                                            let x14: Expr = Mul(muls2: prd List[Expr]);
                                            substitute (a0 := a0), (x := x), (x14 := x14), (y := y);
                                            lift_deriv_2(
                                                a0: cns Expr,
                                                x: prd Expr,
                                                x14: prd Expr,
                                                y: prd Expr
                                            ),
                                        Div(divs2: prd List[Expr]) =>
                                            substitute
                                                (a0 := a0),
                                                (x := x),
                                                (y := y),
                                                (divs2 := divs2);
                                            let x14: Expr = Div(divs2: prd List[Expr]);
                                            substitute (a0 := a0), (x := x), (x14 := x14), (y := y);
                                            lift_deriv_2(
                                                a0: cns Expr,
                                                x: prd Expr,
                                                x14: prd Expr,
                                                y: prd Expr
                                            ),
                                        Num(i2: ext i64) =>
                                            substitute (a0 := a0), (x := x), (y := y), (i2 := i2);
                                            let x14: Expr = Num(i2: ext i64);
                                            substitute (a0 := a0), (x := x), (x14 := x14), (y := y);
                                            lift_deriv_2(
                                                a0: cns Expr,
                                                x: prd Expr,
                                                x14: prd Expr,
                                                y: prd Expr
                                            ),
                                        X =>
                                            let x14: Expr = X;
                                            substitute (a0 := a0), (x := x), (x14 := x14), (y := y);
                                            lift_deriv_2(
                                                a0: cns Expr,
                                                x: prd Expr,
                                                x14: prd Expr,
                                                y: prd Expr
                                            )
                                    };
                                    deriv(x38: prd Expr, a8: cns Expr),
                                Cons(z: prd Expr, zs: prd List[Expr]) =>
                                    substitute (a0 := a0);
                                    invoke a0 X
                            }
                    }
            },
        Num(i: ext i64) =>
            substitute (a0 := a0);
            lit x32 <- 0;
            substitute (x32 := x32), (a0 := a0);
            invoke a0 Num(x32: ext i64),
        X =>
            substitute (a0 := a0);
            lit x33 <- 1;
            substitute (x33 := x33), (a0 := a0);
            invoke a0 Num(x33: ext i64)
    }
}

def lift_deriv_2(a0: cns Expr, x: prd Expr, x14: prd Expr, y: prd Expr) {
    let x15: List[Expr] = Nil;
    substitute (a0 := a0), (x := x), (x14 := x14), (y := y), (y0 := y), (x15 := x15);
    let x16: List[Expr] = Cons(y0: prd Expr, x15: prd List[Expr]);
    substitute (a0 := a0), (x := x), (y := y), (x14 := x14), (x16 := x16);
    let x17: List[Expr] = Cons(x14: prd Expr, x16: prd List[Expr]);
    let x18: Expr = Div(x17: prd List[Expr]);
    substitute (y1 := y), (x := x), (y := y), (x18 := x18), (a0 := a0);
    create a9: Expr = (x: prd Expr, y: prd Expr, x18: prd Expr, a0: cns Expr){
        Add(sums1: prd List[Expr]) =>
            substitute (a0 := a0), (x := x), (y := y), (x18 := x18), (sums1 := sums1);
            let x19: Expr = Add(sums1: prd List[Expr]);
            substitute (a0 := a0), (x := x), (x18 := x18), (x19 := x19), (y := y);
            lift_deriv_3(a0: cns Expr, x: prd Expr, x18: prd Expr, x19: prd Expr, y: prd Expr),
        Sub(subs1: prd List[Expr]) =>
            substitute (a0 := a0), (x := x), (y := y), (x18 := x18), (subs1 := subs1);
            let x19: Expr = Sub(subs1: prd List[Expr]);
            substitute (a0 := a0), (x := x), (x18 := x18), (x19 := x19), (y := y);
            lift_deriv_3(a0: cns Expr, x: prd Expr, x18: prd Expr, x19: prd Expr, y: prd Expr),
        Mul(muls1: prd List[Expr]) =>
            substitute (a0 := a0), (x := x), (y := y), (x18 := x18), (muls1 := muls1);
            let x19: Expr = Mul(muls1: prd List[Expr]);
            substitute (a0 := a0), (x := x), (x18 := x18), (x19 := x19), (y := y);
            lift_deriv_3(a0: cns Expr, x: prd Expr, x18: prd Expr, x19: prd Expr, y: prd Expr),
        Div(divs1: prd List[Expr]) =>
            substitute (a0 := a0), (x := x), (y := y), (x18 := x18), (divs1 := divs1);
            let x19: Expr = Div(divs1: prd List[Expr]);
            substitute (a0 := a0), (x := x), (x18 := x18), (x19 := x19), (y := y);
            lift_deriv_3(a0: cns Expr, x: prd Expr, x18: prd Expr, x19: prd Expr, y: prd Expr),
        Num(i1: ext i64) =>
            substitute (a0 := a0), (x := x), (y := y), (x18 := x18), (i1 := i1);
            let x19: Expr = Num(i1: ext i64);
            substitute (a0 := a0), (x := x), (x18 := x18), (x19 := x19), (y := y);
            lift_deriv_3(a0: cns Expr, x: prd Expr, x18: prd Expr, x19: prd Expr, y: prd Expr),
        X =>
            let x19: Expr = X;
            substitute (a0 := a0), (x := x), (x18 := x18), (x19 := x19), (y := y);
            lift_deriv_3(a0: cns Expr, x: prd Expr, x18: prd Expr, x19: prd Expr, y: prd Expr)
    };
    deriv(y1: prd Expr, a9: cns Expr)
}

def lift_deriv_3(a0: cns Expr, x: prd Expr, x18: prd Expr, x19: prd Expr, y: prd Expr) {
    let x20: List[Expr] = Nil;
    substitute (a0 := a0), (x := x), (x18 := x18), (y := y), (x19 := x19), (x20 := x20);
    let x21: List[Expr] = Cons(x19: prd Expr, x20: prd List[Expr]);
    substitute (a0 := a0), (x := x), (x18 := x18), (y := y), (y0 := y), (x21 := x21);
    let x22: List[Expr] = Cons(y0: prd Expr, x21: prd List[Expr]);
    let x23: List[Expr] = Cons(y: prd Expr, x22: prd List[Expr]);
    let x24: Expr = Mul(x23: prd List[Expr]);
    let x25: List[Expr] = Nil;
    let x26: List[Expr] = Cons(x24: prd Expr, x25: prd List[Expr]);
    substitute (a0 := a0), (x18 := x18), (x := x), (x26 := x26);
    let x27: List[Expr] = Cons(x: prd Expr, x26: prd List[Expr]);
    let x28: Expr = Div(x27: prd List[Expr]);
    let x29: List[Expr] = Nil;
    let x30: List[Expr] = Cons(x28: prd Expr, x29: prd List[Expr]);
    let x31: List[Expr] = Cons(x18: prd Expr, x30: prd List[Expr]);
    substitute (x31 := x31), (a0 := a0);
    invoke a0 Sub(x31: prd List[Expr])
}

def lift_deriv_1(a6: cns Expr, x: prd Expr, x6: prd Expr) {
    let x7: List[Expr] = Nil;
    substitute (a6 := a6), (x6 := x6), (x := x), (x7 := x7);
    let x8: List[Expr] = Cons(x: prd Expr, x7: prd List[Expr]);
    let x9: List[Expr] = Cons(x6: prd Expr, x8: prd List[Expr]);
    substitute (x9 := x9), (a6 := a6);
    invoke a6 Div(x9: prd List[Expr])
}

def lift_deriv_0(a0: cns Expr, e: prd Expr, x4: prd List[Expr]) {
    let x10: Expr = Add(x4: prd List[Expr]);
    let x11: List[Expr] = Nil;
    let x12: List[Expr] = Cons(x10: prd Expr, x11: prd List[Expr]);
    let x13: List[Expr] = Cons(e: prd Expr, x12: prd List[Expr]);
    substitute (x13 := x13), (a0 := a0);
    invoke a0 Mul(x13: prd List[Expr])
}

def mk_exp(a: prd Expr, b: prd Expr, a0: cns Expr) {
    lit x0 <- 3;
    substitute (a := a), (b := b), (a0 := a0), (x0 := x0);
    let x1: Expr = Num(x0: ext i64);
    let x2: Expr = X;
    let x3: Expr = X;
    let x4: List[Expr] = Nil;
    let x5: List[Expr] = Cons(x3: prd Expr, x4: prd List[Expr]);
    let x6: List[Expr] = Cons(x2: prd Expr, x5: prd List[Expr]);
    let x7: List[Expr] = Cons(x1: prd Expr, x6: prd List[Expr]);
    let x8: Expr = Mul(x7: prd List[Expr]);
    let x9: Expr = X;
    let x10: Expr = X;
    let x11: List[Expr] = Nil;
    let x12: List[Expr] = Cons(x10: prd Expr, x11: prd List[Expr]);
    let x13: List[Expr] = Cons(x9: prd Expr, x12: prd List[Expr]);
    substitute (x8 := x8), (b := b), (a0 := a0), (a := a), (x13 := x13);
    let x14: List[Expr] = Cons(a: prd Expr, x13: prd List[Expr]);
    let x15: Expr = Mul(x14: prd List[Expr]);
    let x16: Expr = X;
    let x17: List[Expr] = Nil;
    let x18: List[Expr] = Cons(x16: prd Expr, x17: prd List[Expr]);
    substitute (x8 := x8), (x15 := x15), (a0 := a0), (b := b), (x18 := x18);
    let x19: List[Expr] = Cons(b: prd Expr, x18: prd List[Expr]);
    let x20: Expr = Mul(x19: prd List[Expr]);
    lit x21 <- 5;
    substitute (x8 := x8), (x15 := x15), (a0 := a0), (x20 := x20), (x21 := x21);
    let x22: Expr = Num(x21: ext i64);
    let x23: List[Expr] = Nil;
    let x24: List[Expr] = Cons(x22: prd Expr, x23: prd List[Expr]);
    let x25: List[Expr] = Cons(x20: prd Expr, x24: prd List[Expr]);
    substitute (x8 := x8), (a0 := a0), (x15 := x15), (x25 := x25);
    let x26: List[Expr] = Cons(x15: prd Expr, x25: prd List[Expr]);
    substitute (a0 := a0), (x8 := x8), (x26 := x26);
    let x27: List[Expr] = Cons(x8: prd Expr, x26: prd List[Expr]);
    substitute (x27 := x27), (a0 := a0);
    invoke a0 Add(x27: prd List[Expr])
}

def mk_ans(a: prd Expr, b: prd Expr, a0: cns Expr) {
    lit x0 <- 3;
    substitute (a := a), (b := b), (a0 := a0), (x0 := x0);
    let x1: Expr = Num(x0: ext i64);
    let x2: Expr = X;
    let x3: Expr = X;
    let x4: List[Expr] = Nil;
    let x5: List[Expr] = Cons(x3: prd Expr, x4: prd List[Expr]);
    let x6: List[Expr] = Cons(x2: prd Expr, x5: prd List[Expr]);
    let x7: List[Expr] = Cons(x1: prd Expr, x6: prd List[Expr]);
    let x8: Expr = Mul(x7: prd List[Expr]);
    lit x9 <- 0;
    substitute (a := a), (b := b), (a0 := a0), (x8 := x8), (x9 := x9);
    let x10: Expr = Num(x9: ext i64);
    lit x11 <- 3;
    substitute (a := a), (b := b), (a0 := a0), (x8 := x8), (x10 := x10), (x11 := x11);
    let x12: Expr = Num(x11: ext i64);
    let x13: List[Expr] = Nil;
    let x14: List[Expr] = Cons(x12: prd Expr, x13: prd List[Expr]);
    let x15: List[Expr] = Cons(x10: prd Expr, x14: prd List[Expr]);
    let x16: Expr = Div(x15: prd List[Expr]);
    lit x17 <- 1;
    substitute (a := a), (b := b), (a0 := a0), (x8 := x8), (x16 := x16), (x17 := x17);
    let x18: Expr = Num(x17: ext i64);
    let x19: Expr = X;
    let x20: List[Expr] = Nil;
    let x21: List[Expr] = Cons(x19: prd Expr, x20: prd List[Expr]);
    let x22: List[Expr] = Cons(x18: prd Expr, x21: prd List[Expr]);
    let x23: Expr = Div(x22: prd List[Expr]);
    lit x24 <- 1;
    substitute (a := a), (b := b), (a0 := a0), (x8 := x8), (x16 := x16), (x23 := x23), (x24 := x24);
    let x25: Expr = Num(x24: ext i64);
    let x26: Expr = X;
    let x27: List[Expr] = Nil;
    let x28: List[Expr] = Cons(x26: prd Expr, x27: prd List[Expr]);
    let x29: List[Expr] = Cons(x25: prd Expr, x28: prd List[Expr]);
    let x30: Expr = Div(x29: prd List[Expr]);
    let x31: List[Expr] = Nil;
    let x32: List[Expr] = Cons(x30: prd Expr, x31: prd List[Expr]);
    let x33: List[Expr] = Cons(x23: prd Expr, x32: prd List[Expr]);
    let x34: List[Expr] = Cons(x16: prd Expr, x33: prd List[Expr]);
    let x35: Expr = Add(x34: prd List[Expr]);
    let x36: List[Expr] = Nil;
    let x37: List[Expr] = Cons(x35: prd Expr, x36: prd List[Expr]);
    let x38: List[Expr] = Cons(x8: prd Expr, x37: prd List[Expr]);
    let x39: Expr = Mul(x38: prd List[Expr]);
    let x40: Expr = X;
    let x41: Expr = X;
    let x42: List[Expr] = Nil;
    let x43: List[Expr] = Cons(x41: prd Expr, x42: prd List[Expr]);
    let x44: List[Expr] = Cons(x40: prd Expr, x43: prd List[Expr]);
    substitute (a := a), (b := b), (a0 := a0), (x39 := x39), (a1 := a), (x44 := x44);
    let x45: List[Expr] = Cons(a1: prd Expr, x44: prd List[Expr]);
    let x46: Expr = Mul(x45: prd List[Expr]);
    lit x47 <- 0;
    substitute (a := a), (b := b), (a0 := a0), (x39 := x39), (x46 := x46), (x47 := x47);
    let x48: Expr = Num(x47: ext i64);
    let x49: List[Expr] = Nil;
    substitute
        (x48 := x48),
        (b := b),
        (a0 := a0),
        (x39 := x39),
        (x46 := x46),
        (a := a),
        (x49 := x49);
    let x50: List[Expr] = Cons(a: prd Expr, x49: prd List[Expr]);
    substitute (x46 := x46), (b := b), (a0 := a0), (x39 := x39), (x48 := x48), (x50 := x50);
    let x51: List[Expr] = Cons(x48: prd Expr, x50: prd List[Expr]);
    let x52: Expr = Div(x51: prd List[Expr]);
    lit x53 <- 1;
    substitute (x46 := x46), (b := b), (a0 := a0), (x39 := x39), (x52 := x52), (x53 := x53);
    let x54: Expr = Num(x53: ext i64);
    let x55: Expr = X;
    let x56: List[Expr] = Nil;
    let x57: List[Expr] = Cons(x55: prd Expr, x56: prd List[Expr]);
    let x58: List[Expr] = Cons(x54: prd Expr, x57: prd List[Expr]);
    let x59: Expr = Div(x58: prd List[Expr]);
    lit x60 <- 1;
    substitute
        (x46 := x46),
        (b := b),
        (a0 := a0),
        (x39 := x39),
        (x52 := x52),
        (x59 := x59),
        (x60 := x60);
    let x61: Expr = Num(x60: ext i64);
    let x62: Expr = X;
    let x63: List[Expr] = Nil;
    let x64: List[Expr] = Cons(x62: prd Expr, x63: prd List[Expr]);
    let x65: List[Expr] = Cons(x61: prd Expr, x64: prd List[Expr]);
    let x66: Expr = Div(x65: prd List[Expr]);
    let x67: List[Expr] = Nil;
    let x68: List[Expr] = Cons(x66: prd Expr, x67: prd List[Expr]);
    let x69: List[Expr] = Cons(x59: prd Expr, x68: prd List[Expr]);
    let x70: List[Expr] = Cons(x52: prd Expr, x69: prd List[Expr]);
    let x71: Expr = Add(x70: prd List[Expr]);
    let x72: List[Expr] = Nil;
    let x73: List[Expr] = Cons(x71: prd Expr, x72: prd List[Expr]);
    substitute (x39 := x39), (b := b), (a0 := a0), (x46 := x46), (x73 := x73);
    let x74: List[Expr] = Cons(x46: prd Expr, x73: prd List[Expr]);
    let x75: Expr = Mul(x74: prd List[Expr]);
    let x76: Expr = X;
    let x77: List[Expr] = Nil;
    let x78: List[Expr] = Cons(x76: prd Expr, x77: prd List[Expr]);
    substitute (x39 := x39), (b := b), (a0 := a0), (x75 := x75), (b0 := b), (x78 := x78);
    let x79: List[Expr] = Cons(b0: prd Expr, x78: prd List[Expr]);
    let x80: Expr = Mul(x79: prd List[Expr]);
    lit x81 <- 0;
    substitute (x39 := x39), (b := b), (a0 := a0), (x75 := x75), (x80 := x80), (x81 := x81);
    let x82: Expr = Num(x81: ext i64);
    let x83: List[Expr] = Nil;
    substitute
        (x39 := x39),
        (x82 := x82),
        (a0 := a0),
        (x75 := x75),
        (x80 := x80),
        (b := b),
        (x83 := x83);
    let x84: List[Expr] = Cons(b: prd Expr, x83: prd List[Expr]);
    substitute (x39 := x39), (x80 := x80), (a0 := a0), (x75 := x75), (x82 := x82), (x84 := x84);
    let x85: List[Expr] = Cons(x82: prd Expr, x84: prd List[Expr]);
    let x86: Expr = Div(x85: prd List[Expr]);
    lit x87 <- 1;
    substitute (x39 := x39), (x80 := x80), (a0 := a0), (x75 := x75), (x86 := x86), (x87 := x87);
    let x88: Expr = Num(x87: ext i64);
    let x89: Expr = X;
    let x90: List[Expr] = Nil;
    let x91: List[Expr] = Cons(x89: prd Expr, x90: prd List[Expr]);
    let x92: List[Expr] = Cons(x88: prd Expr, x91: prd List[Expr]);
    let x93: Expr = Div(x92: prd List[Expr]);
    let x94: List[Expr] = Nil;
    let x95: List[Expr] = Cons(x93: prd Expr, x94: prd List[Expr]);
    let x96: List[Expr] = Cons(x86: prd Expr, x95: prd List[Expr]);
    let x97: Expr = Add(x96: prd List[Expr]);
    let x98: List[Expr] = Nil;
    let x99: List[Expr] = Cons(x97: prd Expr, x98: prd List[Expr]);
    substitute (x39 := x39), (x75 := x75), (a0 := a0), (x80 := x80), (x99 := x99);
    let x100: List[Expr] = Cons(x80: prd Expr, x99: prd List[Expr]);
    let x101: Expr = Mul(x100: prd List[Expr]);
    lit x102 <- 0;
    substitute (x39 := x39), (x75 := x75), (a0 := a0), (x101 := x101), (x102 := x102);
    let x103: Expr = Num(x102: ext i64);
    let x104: List[Expr] = Nil;
    let x105: List[Expr] = Cons(x103: prd Expr, x104: prd List[Expr]);
    let x106: List[Expr] = Cons(x101: prd Expr, x105: prd List[Expr]);
    substitute (x39 := x39), (a0 := a0), (x75 := x75), (x106 := x106);
    let x107: List[Expr] = Cons(x75: prd Expr, x106: prd List[Expr]);
    substitute (a0 := a0), (x39 := x39), (x107 := x107);
    let x108: List[Expr] = Cons(x39: prd Expr, x107: prd List[Expr]);
    substitute (x108 := x108), (a0 := a0);
    invoke a0 Add(x108: prd List[Expr])
}

def main_loop(iters: ext i64, n: ext i64, m: ext i64, a0: cns _Cont) {
    substitute (m0 := m), (n0 := n), (m := m), (a0 := a0), (iters := iters), (n := n);
    create a1: Expr = (m: ext i64, a0: cns _Cont, iters: ext i64, n: ext i64){
        Add(sums2: prd List[Expr]) =>
            substitute (n := n), (m := m), (a0 := a0), (iters := iters), (sums2 := sums2);
            let x0: Expr = Add(sums2: prd List[Expr]);
            substitute (a0 := a0), (iters := iters), (m := m), (n := n), (x0 := x0);
            lift_main_loop_0(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, x0: prd Expr),
        Sub(subs2: prd List[Expr]) =>
            substitute (n := n), (m := m), (a0 := a0), (iters := iters), (subs2 := subs2);
            let x0: Expr = Sub(subs2: prd List[Expr]);
            substitute (a0 := a0), (iters := iters), (m := m), (n := n), (x0 := x0);
            lift_main_loop_0(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, x0: prd Expr),
        Mul(muls2: prd List[Expr]) =>
            substitute (n := n), (m := m), (a0 := a0), (iters := iters), (muls2 := muls2);
            let x0: Expr = Mul(muls2: prd List[Expr]);
            substitute (a0 := a0), (iters := iters), (m := m), (n := n), (x0 := x0);
            lift_main_loop_0(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, x0: prd Expr),
        Div(divs2: prd List[Expr]) =>
            substitute (n := n), (m := m), (a0 := a0), (iters := iters), (divs2 := divs2);
            let x0: Expr = Div(divs2: prd List[Expr]);
            substitute (a0 := a0), (iters := iters), (m := m), (n := n), (x0 := x0);
            lift_main_loop_0(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, x0: prd Expr),
        Num(i2: ext i64) =>
            substitute (n := n), (m := m), (a0 := a0), (iters := iters), (i2 := i2);
            let x0: Expr = Num(i2: ext i64);
            substitute (a0 := a0), (iters := iters), (m := m), (n := n), (x0 := x0);
            lift_main_loop_0(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, x0: prd Expr),
        X =>
            let x0: Expr = X;
            substitute (a0 := a0), (iters := iters), (m := m), (n := n), (x0 := x0);
            lift_main_loop_0(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, x0: prd Expr)
    };
    substitute (m0 := m0), (a1 := a1), (n0 := n0);
    let x1: Expr = Num(n0: ext i64);
    substitute (x1 := x1), (a1 := a1), (m0 := m0);
    let x2: Expr = Num(m0: ext i64);
    substitute (x1 := x1), (x2 := x2), (a1 := a1);
    mk_exp(x1: prd Expr, x2: prd Expr, a1: cns Expr)
}

def lift_main_loop_0(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, x0: prd Expr) {
    substitute (x0 := x0), (iters := iters), (m := m), (n := n), (a0 := a0);
    create a2: Expr = (iters: ext i64, m: ext i64, n: ext i64, a0: cns _Cont){
        Add(sums1: prd List[Expr]) =>
            substitute (a0 := a0), (iters := iters), (m := m), (n := n), (sums1 := sums1);
            let res: Expr = Add(sums1: prd List[Expr]);
            lift_main_loop_1(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, res: prd Expr),
        Sub(subs1: prd List[Expr]) =>
            substitute (a0 := a0), (iters := iters), (m := m), (n := n), (subs1 := subs1);
            let res: Expr = Sub(subs1: prd List[Expr]);
            lift_main_loop_1(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, res: prd Expr),
        Mul(muls1: prd List[Expr]) =>
            substitute (a0 := a0), (iters := iters), (m := m), (n := n), (muls1 := muls1);
            let res: Expr = Mul(muls1: prd List[Expr]);
            lift_main_loop_1(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, res: prd Expr),
        Div(divs1: prd List[Expr]) =>
            substitute (a0 := a0), (iters := iters), (m := m), (n := n), (divs1 := divs1);
            let res: Expr = Div(divs1: prd List[Expr]);
            lift_main_loop_1(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, res: prd Expr),
        Num(i1: ext i64) =>
            substitute (a0 := a0), (iters := iters), (m := m), (n := n), (i1 := i1);
            let res: Expr = Num(i1: ext i64);
            lift_main_loop_1(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, res: prd Expr),
        X =>
            let res: Expr = X;
            substitute (a0 := a0), (iters := iters), (m := m), (n := n), (res := res);
            lift_main_loop_1(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, res: prd Expr)
    };
    deriv(x0: prd Expr, a2: cns Expr)
}

def lift_main_loop_1(a0: cns _Cont, iters: ext i64, m: ext i64, n: ext i64, res: prd Expr) {
    substitute (a0 := a0), (iters := iters), (m := m), (n := n), (res := res), (n0 := n);
    let x3: Expr = Num(n0: ext i64);
    substitute
        (a0 := a0),
        (iters := iters),
        (m := m),
        (n := n),
        (res := res),
        (x3 := x3),
        (m0 := m);
    let x4: Expr = Num(m0: ext i64);
    substitute
        (x4 := x4),
        (x3 := x3),
        (m := m),
        (n := n),
        (res := res),
        (iters := iters),
        (a0 := a0);
    create a3: Expr = (m: ext i64, n: ext i64, res: prd Expr, iters: ext i64, a0: cns _Cont){
        Add(sums0: prd List[Expr]) =>
            substitute
                (a0 := a0),
                (m := m),
                (n := n),
                (res := res),
                (iters := iters),
                (sums0 := sums0);
            let expected: Expr = Add(sums0: prd List[Expr]);
            substitute
                (a0 := a0),
                (expected := expected),
                (iters := iters),
                (m := m),
                (n := n),
                (res := res);
            lift_main_loop_2(
                a0: cns _Cont,
                expected: prd Expr,
                iters: ext i64,
                m: ext i64,
                n: ext i64,
                res: prd Expr
            ),
        Sub(subs0: prd List[Expr]) =>
            substitute
                (a0 := a0),
                (m := m),
                (n := n),
                (res := res),
                (iters := iters),
                (subs0 := subs0);
            let expected: Expr = Sub(subs0: prd List[Expr]);
            substitute
                (a0 := a0),
                (expected := expected),
                (iters := iters),
                (m := m),
                (n := n),
                (res := res);
            lift_main_loop_2(
                a0: cns _Cont,
                expected: prd Expr,
                iters: ext i64,
                m: ext i64,
                n: ext i64,
                res: prd Expr
            ),
        Mul(muls0: prd List[Expr]) =>
            substitute
                (a0 := a0),
                (m := m),
                (n := n),
                (res := res),
                (iters := iters),
                (muls0 := muls0);
            let expected: Expr = Mul(muls0: prd List[Expr]);
            substitute
                (a0 := a0),
                (expected := expected),
                (iters := iters),
                (m := m),
                (n := n),
                (res := res);
            lift_main_loop_2(
                a0: cns _Cont,
                expected: prd Expr,
                iters: ext i64,
                m: ext i64,
                n: ext i64,
                res: prd Expr
            ),
        Div(divs0: prd List[Expr]) =>
            substitute
                (a0 := a0),
                (m := m),
                (n := n),
                (res := res),
                (iters := iters),
                (divs0 := divs0);
            let expected: Expr = Div(divs0: prd List[Expr]);
            substitute
                (a0 := a0),
                (expected := expected),
                (iters := iters),
                (m := m),
                (n := n),
                (res := res);
            lift_main_loop_2(
                a0: cns _Cont,
                expected: prd Expr,
                iters: ext i64,
                m: ext i64,
                n: ext i64,
                res: prd Expr
            ),
        Num(i0: ext i64) =>
            substitute (a0 := a0), (m := m), (n := n), (res := res), (iters := iters), (i0 := i0);
            let expected: Expr = Num(i0: ext i64);
            substitute
                (a0 := a0),
                (expected := expected),
                (iters := iters),
                (m := m),
                (n := n),
                (res := res);
            lift_main_loop_2(
                a0: cns _Cont,
                expected: prd Expr,
                iters: ext i64,
                m: ext i64,
                n: ext i64,
                res: prd Expr
            ),
        X =>
            let expected: Expr = X;
            substitute
                (a0 := a0),
                (expected := expected),
                (iters := iters),
                (m := m),
                (n := n),
                (res := res);
            lift_main_loop_2(
                a0: cns _Cont,
                expected: prd Expr,
                iters: ext i64,
                m: ext i64,
                n: ext i64,
                res: prd Expr
            )
    };
    substitute (x3 := x3), (x4 := x4), (a3 := a3);
    mk_ans(x3: prd Expr, x4: prd Expr, a3: cns Expr)
}

def lift_main_loop_2(
    a0: cns _Cont,
    expected: prd Expr,
    iters: ext i64,
    m: ext i64,
    n: ext i64,
    res: prd Expr
) {
    lit x5 <- 1;
    if iters == x5 {
        substitute (res := res), (expected := expected), (a0 := a0);
        create a4: Bool = (a0: cns _Cont){
            True =>
                lit x6 <- 1;
                println_i64(x6);
                substitute (a0 := a0);
                lit x10 <- 0;
                substitute (x10 := x10), (a0 := a0);
                invoke a0 Ret(x10: prd i64),
            False =>
                lit x7 <- 0;
                println_i64(x7);
                substitute (a0 := a0);
                lit x11 <- 0;
                substitute (x11 := x11), (a0 := a0);
                invoke a0 Ret(x11: prd i64)
        };
        substitute (expected := expected), (res := res), (a4 := a4);
        equal(expected: prd Expr, res: prd Expr, a4: cns Bool)
    } else {
        substitute (a0 := a0), (n := n), (iters := iters), (m := m);
        lit x8 <- 1;
        x9 <- iters - x8;
        substitute (x9 := x9), (n := n), (m := m), (a0 := a0);
        main_loop(x9: ext i64, n: ext i64, m: ext i64, a0: cns _Cont)
    }
}
