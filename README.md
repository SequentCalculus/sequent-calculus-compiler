# Compiling with the Sequent Calculus

This repository contains a compiler which compiles a high-level functional
programming language to machine code, based on the accompanying paper "Compiling
with the Sequent Calculus". The intermediate languages are based on the sequent
calculus.

To use this project, you need a working installation of Rust 2024.

## Installation

Running

```console
make install
```

will install the compiler binary into your `cargo`-binary directory as `scc`.

To uninstall, run

```console
make uninstall
```

## Usage

With the compiler binary installed (and assuming that your `cargo`-binary directory is in your path),
run

```console
scc help
```

to obtain a list of the commands the compiler can perform.
To get more details for each command, run

```console
scc <COMMAND> --help
```

All files generated by the compiler will be pur into the `target_scc` directory.

## Documentation

Running

```console
make doc
```

generates the documentation of all crates of this project, as listed in the project structure below.
The documentation then is in `target/doc` in html for viewing in a web browser.

## Project Structure

```console
.
├── app                       CLI application of the compiler executable
├── benchmarks                Benchmark programs (a submodule)
├── examples                  Example files
├── infrastructure            Infrastructure files for the runtime
└── lang
    ├── axcut                 Lower-level intermediate language AxCut
    ├── axcut2aarch64         Code generation backend for 64-Bit ARM (Aarch64)
    ├── axcut2backend         Abstraction layer for code generation backend
    ├── axcut2rv64            Code generation backend for 64-Bit RISC-V
    ├── axcut2x86_64          Code generation backend for 64-Bit x86-64
    ├── core_lang             High-level intermediate language Core
    ├── core2axcut            Translation from Core into AxCut
    ├── fun                   Surface language Fun
    ├── fun2core              Translation from Fun into Core
    └── printer               Infrastructure for pretty-printing with colorized
                              terminal and LaTeX output
```

## Using the latex backend

It is possible to generate colorized latex output for code snippets using the
`scc texify` subcommand. The colors used for syntax highlighting are not
predefined but must be declared in the header of the latex file, using, for
example, the following defaults:

```latex
\usepackage{xcolor}
% Color definitions
\definecolor{polBlack}{rgb}{0,0,0}
\definecolor{polBlue}{rgb}{0.06, 0.2, 0.65}
\definecolor{polGreen}{RGB}{0,155,85}
\definecolor{polRed}{rgb}{0.8,0.4,0.3}
\definecolor{polCyan}{rgb}{0.0, 1.0, 1.0}
\definecolor{polMagenta}{rgb}{0.8, 0.13, 0.13}
\definecolor{polYellow}{rgb}{0.91, 0.84, 0.42}
\definecolor{polWhite}{rgb}{1,1,1}
```

## The Language Grammar

The Grammar for the surface language **Fun** is defined in `lalrpop` syntax in
the file `lang/fun/src/parser/fun.lalrpop`. Here is the grammar in a more
standard form. For more concrete examples, look at the [examples](./examples) directory
or at the [benchmark](./benchmarks) programs.

```
Var ::= alphanumerical String with underlines, starting with small letter
Name ::= alphanumerical String with underlines, starting with small letter
TypeName ::= alphanumerical String with underlines, starting with captial letter
CtorName ::= alphanumerical String with underlines, starting with captial letter
DtorName ::= alphanumerical String with underlines, starting with small letter

BinOp ::= + | - | * | / | %
Cmp ::= == | != | < | <= | > | >=

Ty ::= i64 | TypeName | TypeName[Ty+]

Clause ::= CtorName => Term | CtorName(Var+) => Term
CoClause ::= DtorName => Term | DtorName(Var+) => Term

Term ::= int                                            integer literal
      |  Var                                            variable
      |  Name(Term*)                                    call of top-level function
      |  label Var { Term }                             control operator label
      |  goto Var ( Term )                              control operator goto
      |  exit Term                                      exit term
      |  if ( Term Cmp Term ) { Term } else { Term }    conditionals
      |  print_i64(Term); Term                          print integer without newline
      |  println_i64(Term); Term                        print integer with newline
      |  let Var : Ty = Term; Term                      let-binding
      |  CtorName                                       constructor without arguments
      |  CtorName(Term*)                                constructor with arguments
      |  Term.DtorName                                  destructor call without arguments
      |  Term.DtorName[Ty+]                             destructor call without arguments, with type arguments
      |  Term.DtorName(Term*)                           destructor call with arguments
      |  Term.DtorName[Ty+](Term*)                      destructor call with arguments, with type arguments
      |  Term.case { Clause+ }                          pattern match
      |  Term.case[Ty+] { Clause+ }                     pattern match, with type arguments
      |  new { CoClause+ }                              copattern match
      |  Term BinOp Term                                arithmetic binary operations
      |  (Term)                                         parenthesized term


ContextBinding ::= Var : Ty | Var :cns Ty
TypingContext ::= ContextBinding*

CtorSig ::= CtorName | CtorName(TypingContext)
Data ::= data TypeName { CtorSig+ }
      |  data TypeName[TypeName+] { CtorSig+ }

DtorSig ::= DtorName : Ty | DtorName(TypingContext) : Ty
Codata ::= codata TypeName { DtorSig+ }
        |  codata TypeName[TypeName+] { DtorSig+ }

Def ::= def Name(TypingContext) : Ty { Term }

Declaration ::= Data | Codata | Def

Program ::= Declaration+
```

Note that while data and codata declarations may have type parameters, which can also be used
by their constructors and destructors in the declaration. On the term level, however, these
type parameters must be instantiated by monomorphic types, as is visible in destructor calls and
pattern matches. That is, there is no type polymorphism on the term level, only in declarations.

Moreover, to make a program runnable, it must contain a top-level definition called `main`, which
can take several integer parameters (these are the command-line arguments) and returns an integer
(the exit code of the program).
